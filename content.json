{"posts":[{"title":"CPP-STL","text":"参考教程： cpp-STL - AlgorithmPark基本上是转载，跟着写了一遍理思路。 1. vector 容器头文件 #include&lt;vector&gt; (1)构造12345678910111213#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;vector&lt;int&gt;b;vector&lt;int&gt;a(10);vector&lt;int&gt;a(10,1);//10个整型元素的向量，每个值为1vector&lt;int&gt;a(b);//用向量b给a赋值vector&lt;int&gt;a(b.begin(),b.begin()+3);//将b中0-2个元素赋值给aint c[7]={1,2,3,4,5,6,7};vector&lt;int&gt;a(c,c+7);vector&lt;int&gt;a{1,2,3,4,5,6,7};vector&lt;int&gt;a={1,2,3,4,5,6,7}; (2)基本操作1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465void test01()//基本操作 { vector&lt;int&gt; a, b; int i=0; //b为向量，将b的0-2个元素赋值给向量a a.assign(b.begin(), b.begin() + 3); //a含有4个值为2的元素 a.assign(4, 2); //返回a的最后一个元素 a.back(); //返回a的第一个元素 a.front(); //返回a的第i元素,当且仅当a存在 a[i]; //清空a中的元素 a.clear(); //判断a是否为空，空则返回true，非空则返回false a.empty(); //删除a向量的最后一个元素 a.pop_back(); //删除a中第一个（从第0个算起）到第二个元素，也就是说删除的元素从a.begin()+1算起（包括它）一直到a.begin()+3（不包括它）结束 a.erase(a.begin() + 1, a.begin() + 3); //在a的最后一个向量后插入一个元素，其值为5 a.push_back(5); //在a的第一个元素（从第0个算起）位置(前面)插入数值5, a.insert(a.begin() + 1, 5); //在a的第一个元素（从第0个算起）位置（前面）插入3个数，其值都为5 a.insert(a.begin() + 1, 3, 5); //d为数组，在a的第一个元素（从第0个元素算起）的位置（前面）插入b的第三个元素到第5个元素（不包括b+6） int d[8]; a.insert(a.begin() + 1, d + 3, d + 6); //返回a中元素的个数 a.size(); //返回a在内存中总共可以容纳的元素个数 a.capacity(); //将a的现有元素个数调整至10个，多则删，少则补，其值随机 a.resize(10); //将a的现有元素个数调整至10个，多则删，少则补，其值为2 a.resize(10, 2); //将a的容量扩充至100， a.reserve(100); //b为向量，将a中的元素和b中的元素整体交换 a.swap(b); //b为向量，向量的比较操作还有 != &gt;= &gt; &lt;= &lt; a == b; } assign 赋值 insert 插入 resize 调整 reserve 扩充 (3)反向迭代12345678void test02(){ vector&lt;int&gt;a={1,2,3,4,5,6,7,8,9,10}; for(vector&lt;int&gt;::reverse_iterator iter=a.rbegin();iter!=a.rend();iter++) { cout&lt;&lt;*iter&lt;&lt;endl;//10 9 8 7 6 5 4 3 2 1 }} (4)插入 描述 函数签名 插入位置都在 pos 迭代器之前一个位置，返回的迭代器指向插入的第一个元素 在迭代器 pos 指定的位置之前插入一个新元素 elem，并返回表示新插入元素位置的迭代器 iterator insert(pos, elem) 在迭代器 pos 指定的位置之前插入 n 个元素 elem，并返回表示第一个新插入元素位置的迭代器 iterator insert(pos, n, elem) 在迭代器 pos 指定的位置之前，插入其他容器中位于 [first, last) 区域的所有元素，并返回表示第一个新插入元素位置的迭代器 iterator insert(pos, first, last) 在迭代器 pos 指定的位置之前，插入初始化列表（用大括号 {} 括起来的多个元素），中间有逗号隔开）中的所有的元素，并返回表示第一个新插入元素位置的迭代器 iterator insert(pos, initlist) 123456789101112void test03(){ vector&lt;int&gt;a={1,2,3,4,5,6,7,8,9,10}; vector&lt;int&gt;::iterator it1=a.begin()+4; vector&lt;int&gt;::iterator it2=a.insert(it1,{-1,-2,-3}); cout&lt;&lt;*it2&lt;&lt;endl;//-1,并返回表示第一个新插入元素位置的迭代器 for(auto k:a) { cout&lt;&lt;k&lt;&lt;&quot; &quot;;//1 2 3 4 -1 -2 -3 5 6 7 8 9 10 } cout&lt;&lt;endl;} (5) 函数 说明 pop_back() 删除 vector 容器中最后一个元素，该容器的大小（size）会减 1，但容量 (capacity) 不会发生改变。 erase(pos) 删除 vector 容器中 pos 迭代器指定位置处的元素，并返回指向被删除元素下一个位置的迭代器。该容器的大小 (size) 会减 1，但容量 (capacity) 不会发生改变。 ???swap(beg)、pop_back () 先调用 swap() 函数交换要删除的目标元素和容器最后一个元素的位置，然后使用 pop_back () 删除该目标元素。 erase(beg,end) 删除 vector 容器中位于迭代器 [beg, end) 指定区域内的所有元素，并返回指向被删除区域下一个位置元素的迭代器。该容器的大小 (size) 会减小，但容量 (capacity) 不会发生改变。 remove() 删除容器中所有和指定元素值相等的元素，并返回指向最后一个元素下一个位置的迭代器。值得一提的是，调用该函数不会改变容器的大小和容量。 clear() 删除 vector 容器中所有的元素，使其变成空的 vector 容器。该函数会改变 vector 的大小 (变为 0)，但不是改变其容量。 12345678910111213141516171819void test04(){ vector&lt;int&gt;a = { 1,2,3,4,5,6,6,6,6,7,8,9,10 }; int size = a.size(); ptrdiff_t cnt = count(a.begin(), a.end(), 6);//ptrdiff==long long，用于计算6出现的次数 auto it = remove(a.begin(), a.end(), 6);//移除所有的6，不会改变容器的大小和容量，只是覆盖 cout &lt;&lt; *it &lt;&lt; endl;//7，remove 返回的迭代器 it 指向 7，也就是第一个不为 6 的元素之后的新尾部。 cout &lt;&lt; cnt &lt;&lt; endl;//4 for (auto k : a) { cout &lt;&lt; k &lt;&lt; &quot; &quot;;//1 2 3 4 5 7 8 9 10 7 8 9 10 } cout &lt;&lt; endl; a.resize(size - cnt);//调整向量大小，除去末尾的6 for (auto k : a) { cout &lt;&lt; k &lt;&lt; &quot; &quot;;//1 2 3 4 5 7 8 9 10 }} 2.deque 容器头文件 #include&lt;deque (1)遍历容器12345678910void printdeque(const deque&lt;int&gt;&amp; d){ for(deque&lt;int&gt;::const_iterator it=d.begin();it!=d.end();it++) //注意迭代器也要换成带const的 { cout&lt;&lt;*it&lt;&lt;&quot; &quot;; //加const后容器中数据不可修改 } cout&lt;&lt;endl;} (2)构造容器1234567891011121314void test01() { deque&lt;int&gt;d1; for (int i = 0; i &lt; 10; i++) d1.push_front(i+1); printdeque(d1); //区间赋值 deque&lt;int&gt;d2(d1.begin(), d1.end()); printdeque(d2); deque&lt;int&gt;d3(10, 100); printdeque(d3); deque&lt;int&gt;d4(d3); printdeque(d4); } 程序输出： 123410 9 8 7 6 5 4 3 2 1 10 9 8 7 6 5 4 3 2 1 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 (3)赋值操作123456789101112131415161718192021void test03(){ deque&lt;int&gt;d1; for(int i=0;i&lt;10;i++) { d1.push_back(i+1); } printdeque(d1); //operator=赋值 deuqe&lt;int&gt;d2; d2=d1; printdeque(d2); //assign赋值 deque&lt;int&gt;d3; d3.assgin(d1.begin(),d1.end()); printdeque(d3); deque&lt;int&gt;d4; d4.assign(10,100); printdeque(d4); } 程序输出： 12341 2 3 4 5 6 7 8 9 10 1 2 3 4 5 6 7 8 9 10 1 2 3 4 5 6 7 8 9 10 100 100 100 100 100 100 100 100 100 100 (4)插入和删除1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;iostream&gt;#include &lt;deque&gt;using namespace std;// 打印 deque 的内容void printDeque(const deque&lt;int&gt;&amp; d) { for (int elem : d) { cout &lt;&lt; elem &lt;&lt; &quot; &quot;; } if (d.empty()) { cout &lt;&lt; &quot;(empty)&quot;; } cout &lt;&lt; endl;}void testDequeOperations() { deque&lt;int&gt; d; // 1. 头部插入 d.push_front(10); // 在头部插入 10 d.push_front(20); // 在头部插入 20 d.push_front(30); // 在头部插入 30 printDeque(d); // 输出: 30 20 10 // 2. 尾部插入 d.push_back(40); // 在尾部插入 40 d.push_back(50); // 在尾部插入 50 printDeque(d); // 输出: 30 20 10 40 50 // 3. 任意位置插入 d.insert(d.begin() + 2, 100); // 在第三个位置插入 100 d.insert(d.end() - 1, 2, 200); // 在倒数第二个位置插入两个 200 printDeque(d); // 输出: 30 20 100 10 40 200 200 50 // 4. 头部删除 d.pop_front(); // 删除头部元素 printDeque(d); // 输出: 20 100 10 40 200 200 50 // 5. 尾部删除 d.pop_back(); // 删除尾部元素 printDeque(d); // 输出: 20 100 10 40 200 200 // 6. 任意位置删除 d.erase(d.begin() + 1); // 删除第二个位置上的元素 printDeque(d); // 输出: 20 10 40 200 200 // 删除一个范围内的元素 d.erase(d.begin() + 2, d.end() - 1); // 删除第三个到倒数第二个元素 printDeque(d); // 输出: 20 10 200 // 清空整个 deque d.clear(); printDeque(d); // 输出: (empty)}int main() { testDequeOperations(); return 0;} } (5)数据存取1234567deque d1;d1[2];d1.at(2);//d1的第二个元素d1.front();d1.back();//访问d1的首尾元素 3. stack 容器头文件 #include&lt;stack&gt;后进先出 12345678910111213141516void test01(){ stack&lt;int&gt;s; s.push(10); s.push(20); s.push(30); s.push(40); int n=s.size(); for(int i=0;i&lt;n;i++) { cout&lt;&lt;s.top()&lt;&lt;&quot; &quot;;//40 30 20 10 s.pop(); //访问top后出栈 } cout&lt;&lt;endl;} 4. queue 容器头文件 #include&lt;queue&gt;先进先出 1234567891011121314151617181920212223242526272829303132333435#include&lt;queue&gt;using namespace std;void testqueue(){ queue&lt;int&gt;q; q.push(10); q.push(20); q.push(30); //创建一个temp用于打印元素 queue&lt;int&gt;temp=q; while(!q.empty()) { cout&lt;&lt;temp.front()&lt;&lt;&quot; &quot;;//输出队首元素 q.pop();//弹出队首元素 } cout&lt;&lt;endl; //获取队首尾元素 cout&lt;&lt;q.front()&lt;&lt;q.back()&lt;&lt;endl; cout&lt;&lt;q.empty()&lt;&lt;endl; cout&lt;&lt;q.size()&lt;&lt;endl; //清空队列 while(!q.empty()) { q.pop(); }}int main(){ testqueue(); return 0;} 5. string 容器(1)构造123456789101112void test01{ string s1; cout&lt;&lt;&quot;s1=&quot;&lt;&lt;s1&lt;&lt;endl; const char* str= &quot;hello world!&quot;//C风格的字符串str初始化为C++的string类型对象s2 string s2(str); cout&lt;&lt;&quot;s2=&quot;&lt;&lt;s2&lt;&lt;endl; string s3(s2); cout&lt;&lt;&quot;s3=&quot;&lt;&lt;s3&lt;&lt;endl; string s4(10,'b');//使用n个字符b初始化 cout&lt;&lt;&quot;s4=&quot;&lt;&lt;s4&lt;&lt;endl;} 1234s1= s2=hello world! s3=hello world! s4=bbbbbbbbbb (2)赋值123456789101112131415161718void test01{ string str1; str1=&quot;hello world!&quot;; cout&lt;&lt;&quot;str1=&quot;&lt;&lt;str1&lt;&lt;endl; string str2=str1; cout&lt;&lt;&quot;str2=&quot;&lt;&lt;str2&lt;&lt;endl; string str4; str4.assign(&quot;hello&quot;); cout&lt;&lt;&quot;str4=&quot;&lt;&lt;str4&lt;&lt;endl; string str5; str5.assign(&quot;hello&quot;,3);//将前3个字符赋值给str5 cout&lt;&lt;&quot;str5=&quot;&lt;&lt;str5&lt;&lt;endl; string str6; str6.assign(str5); string str7; str7.assign(10,'w');} (3)拼接1234567891011string s1=&quot;你&quot;;s1+=&quot;好&quot;;string s2=&quot;我也爱C语言&quot;;//s1.append(&quot;hello&quot;);//s1.append(&quot;you&quot;,2);//s1.append(s2); 、s1.append(s2,4,7);//从str2的第三个字符开始，截取4个加在末尾，第二个参数为起始字符的位置(位置从0开始计算)，第三个参数为字符的长度 //中文字符占2个位置，英文字符占1个位置cout&lt;&lt;&quot;s1=&quot;&lt;&lt;s1&lt;&lt;endl;//你好爱C语言 &quot;我&quot;（索引 0，长度 1）占两个字节。 &quot;也&quot;（索引 1，长度 1）占两个字节。 &quot;爱&quot;（索引 2，长度 1）占两个字节。 &quot;C&quot;（索引 3，长度 1）占一个字节。 &quot;语&quot;（索引 4，长度 1）占两个字节。 &quot;言&quot;（索引 5，长度 1）占两个字节。 (4)查找和替换123456string s=&quot;abcdefgdefg&quot;;int pos1=s.find(&quot;de&quot;);int pos2=s.find(&quot;df&quot;);//-1int pos3=s.rfind(&quot;df&quot;);//rfind是最后一次出现的位置，find是第一次出现的位置s.replace(1,3,&quot;1111&quot;);//从1号位起3个替换为1111//a1111efgdefg (5)字符串比较1234567891011121314151617void test01() { string str1 = &quot;hfllo&quot;; string str2 = &quot;hello&quot;; if (str1.compare(str2) == 0) { cout &lt;&lt; &quot;str1等于str2&quot; &lt;&lt; endl; } else if (str1.compare(str2) &gt; 0) { cout &lt;&lt; &quot;str1大于str2&quot; &lt;&lt; endl; } else { cout &lt;&lt; &quot;str1小于str2&quot; &lt;&lt; endl; } }//通过逐字符比较ASCII值，大于为1，小于为-1，等于为0,以第一个不一样的字符为准 1str1大于str2 数字 0-9：48-57 大写字母 A-Z：65-90 小写字母 a-z：97-122 (6)字符提取123456string str = &quot;hello&quot;; for (int i = 0; i &lt; 5; i++) cout &lt;&lt; str[i] &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; for (int i = 0; i &lt; 5; i++) cout &lt;&lt; str.at(i) &lt;&lt; &quot; &quot;; (7)插入和删除12345string s1=&quot;abcdefgh&quot;;s1.insert(2,&quot;xxx&quot;);//abxxxcdefghs1.erase(2,3);//删去从2开始的3个字符s1.insert(2,3,'x');//abcdefghs1.insert(2,3,'x');//abxxxcdefgh (8)子串123string s1=&quot;abd*cdf&quot;;int pos=s1.find('*');string s2=s1.substr(0,pos);//abd (9)其他 string s; // 生成一个空字符串s string s(str); // 拷贝构造函数生成str的复制品 string s(str, stridx); // 将字符串str内”始于位置stridx”的部分当作字符串的初值 string s(str, stridx, strlen); // 将字符串str内”始于stridx且长度顶多strlen”的部分作为字符串的初值 string s(cstr); // 将C字符串（以NULL结束）作为s的初值 string s(chars, chars_len); // 将C字符串前chars_len个字符作为字符串s的初值。 string s(num, ‘c’); // 生成一个字符串，包含num个c字符 string s(“value”); string s = “value”; // 将s初始化为一个字符串字面值副本 string s(begin, end); // 以区间begin/end(不包含end)内的字符作为字符串s的初值 s.~string(); //销毁所有字符，释放内存 string s; s.empty(); // s为空串 返回true s.size(); // 返回s中字符个数 类型应为：string::size_type s[n]; // 从0开始相当于下标访问 s1+s2; // 把s1和s2连接成新串 返回新串 s1=s2; // 把s1替换为s2的副本 v1 == v2; // 比较，相等返回true !=, &lt;, &lt;=, &gt;, &gt;= 惯有操作 任何一个大写字母都小于任意的小写字母 123string s(&quot;abc&quot;);s.size();strlen(s.c_str()); 1234567//把string字符串转化为C风格的字符串 string s = &quot;abcdefg&quot;; char str[1000]; strcpy(str, s.c_str()); str[0] = 'p'; str[5] = 'u'; //pbcdeug} 6. set 容器和 multiset 容器#include&lt;set&gt;set不允许容器中有重复的元素multiset允许容器中有重复的元素其他操作基本一致 (1)遍历容器1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;#include&lt;set&gt;using namespace std;void printset(const set&lt;int&gt;&amp;s){ if(s.empty()) { cout&lt;&lt;&quot;set数组为空&quot;&lt;&lt;endl; return; } for(set&lt;int&gt;::const_iterator it=s.begin();it!=s.end();it++) { cout&lt;&lt;*it&lt;&lt;&quot; &quot;; } cout&lt;&lt;endl;}void printmultiset(const multiset&lt;int&gt;&amp;m){ if(m.empty()) { cout&lt;&lt;&quot;multiset数组为空&quot;&lt;&lt;endl; return; } for(multiset&lt;int&gt;::const_iterator it=m.begin();it!=m.end();it++) { cout&lt;&lt;*it&lt;&lt;&quot; &quot;; } cout&lt;&lt;endl;} (2)插入和删除1234567891011121314151617181920212223242526set&lt;int&gt;s;s.insert(10);s.insert(20);s.insert(30); s.insert(40); s.insert(50); s.insert(60); s.insert(70); s.insert(80); s.insert(90); s.insert(100); s.insert(110); s.insert(120);printset(s);//10 20 30 40 50 60 70 80 90 100 110 120set&lt;int&gt;::iterator it=s.begin();set&lt;int&gt;::iterator it2;it2=s.erase(++++it);//删除30.删除迭代器所指元素，返回下一个元素的迭代器printset(s);//10 20 40 50 60 70 80 90 100 110 120set&lt;int&gt;::iterator it1=s.end();s.erase(it2,----it1);//删除区间[it2,----it1)的所有元素，返回下一个元素的迭代器printset(s);s.erase(110);printset(s);//10 20 120s.clear();//清空set容器printset(s);//set数组为空 (2)查找和统计1234567891011121314151617181920212223set&lt;int&gt;s;s.insert(10); s.insert(20); s.insert(30); s.insert(40); s.insert(30); s.insert(60); s.insert(70); s.insert(80); s.insert(70); s.insert(100); s.insert(110); s.insert(120); printset(s);set&lt;int&gt;::()iterator it1;//查找it1=s.find(70);//若存在，返回该键的元素的迭代器，若不存在，返回set.end()if(it1!=s.end()) cout&lt;&lt;*it&lt;&lt;endl;else cout&lt;&lt;&quot;未找到元素&quot;&lt;&lt;endl;//统计int num=s.count(30);cout&lt;&lt;num&lt;&lt;endl;//对于set而言，统计结果只有0和1 程序输出： 12310 20 30 40 60 70 80 100 110 120 70 1 (4)set 与 multiset123456789101112131415161718192021set&lt;int&gt;s;s.insert(20);s.insert(20);s.insert(30);s.insert(40);s.insert(30);s.insert(60);s.insert(70);s.insert(80);s.insert(70);s.insert(100);s.insert(110);s.insert(120);printset(s);pair&lt;set&lt;int&gt;::iterator,bool&gt;ret =s.insert(10);//insert()方法返回一个pair类型，pair&lt;set&lt;int&gt;::iterator,bool&gt;ret，这个first是迭代器，指向插入元素的位置,second是布尔值，表示是否插入成功if(ret.second) cout&lt;&lt;&quot;第一次插入成功&quot;&lt;&lt;endl;else cout&lt;&lt;&quot;第一次插入失败&quot;&lt;&lt;endl;pair&lt;set&lt;int&gt;::iterator,bool&gt;ret1 =s.insert(10);if(ret1.second) cout&lt;&lt;&quot;第二次插入成功&quot;&lt;&lt;endl;else cout&lt;&lt;&quot;第二次插入失败&quot;&lt;&lt;endl; 输出： 12320 30 40 60 70 80 100 110 120 第一次插入成功 第二次插入失败 7. map 和 multimap 容器头文件 #include&lt;map&gt;map 中所有元素都是 pair, 第一个元素为 key (键值), 起到索引作用, 第二个元素为 value（实值）所有元素都有根据元素键值自动排序 map/multimap属于关联式容器，底层结构是用二叉树实现优点：可以根据key值快速找到value值map和multimap区别:map不允许容器中有重复key值元素multimap允许容器中有重复key值元素 (1)遍历12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;#include&lt;map&gt;using namespace std;void printmap(const map&lt;int,int&gt;&amp;m){ if(m.empty()) { cout&lt;&lt;&quot;map容器为空&quot;&lt;&lt;endl; return; } for(map&lt;int,int&gt;::const_iterator it=m.begin();it!=m.end();it++) { cout&lt;&lt;&quot;学号:&quot;&lt;&lt;(*it).first&lt;&lt;&quot; 分数:&quot;&lt;&lt;(*it).second&lt;&lt;endl; } cout&lt;&lt;endl;}void test01(){ map&lt;int,int&gt;m; m.insert(pair&lt;int,int&gt;(1,60)); m.insert(pair&lt;int,int&gt;(2,95)); m.insert(pair&lt;int,int&gt;(4,73)); m.insert(pair&lt;int,int&gt;(3,81)); printmap(m);//按照key值自动排序 map&lt;int,int&gt;m2(m);//拷贝构造 printmap(m2); map&lt;int,int&gt;m3; m3=m2; printmap(m3);} (2)大小和转换1234map&lt;int,int&gt;ma;ma.size();//size()大小map&lt;int,int&gt;ma1;ma.swap(ma1);//swap()转换 (3)插入和删除123456789101112131415161718map&lt;int,int&gt;m;m.insert(pair&lt;int,int&gt;(1,60));m.insert(pair&lt;int,int&gt;(3,95));m.insert(pair&lt;int,int&gt;(4,73));m.insert(pair&lt;int,int&gt;(5,81));m.insert(make_pair(2,10));m.insert(map&lt;int,int&gt;::value_type(6,30));m[7]=40;//这种插数方法和其他的不同在于可以修改已经插入的key对应的valueprintmap(m);m.erase(m.begin(),++++m.begin());printmap(m);m.erase(4);//按照key删除printmap(m);m.clear();printmap(m); 程序输出： 123456789101112131415161718学号：1 分数：60 学号：2 分数：10 学号：3 分数：95 学号：4 分数：73 学号：5 分数：81 学号：6 分数：30 学号：7 分数：40 学号：3 分数：95 学号：4 分数：73 学号：5 分数：81 学号：6 分数：30 学号：7 分数：40 学号：3 分数：95 学号：5 分数：81 学号：6 分数：30 学号：7 分数：40 (4)查找和统计1234567891011121314151617map&lt;int,int&gt;m;m.insert(pair&lt;int, int&gt;(1,60));m.insert(pair&lt;int, int&gt;(3, 95)); m.insert(pair&lt;int, int&gt;(4, 73)); m.insert(pair&lt;int, int&gt;(5, 81)); m.insert(pair&lt;int, int&gt;(2, 84));map&lt;int,int&gt;::iterator it;it=m.find(4);if(it!=m.end()){ cout&lt;&lt;it-&gt;second&lt;&lt;endl;//73 //与cout &lt;&lt; (*it).second &lt;&lt; endl;等价}else{ cout&lt;&lt;&quot;编号不存在&quot;&lt;&lt;endl;}cout&lt;&lt;m.count(4)&lt;&lt;endl;//1 8. priority_queue头文件 #include&lt;queue&gt; priority_queue 是一个元素有序排列的队列，默认队列头部元素优先级最高。因为是一个队列，只能访问第一个元素，这也意味着优先级最高的元素总是第一个被处理。它能够实现常数时间的（默认）最大元素查找，对数代价的插入与释出 (1)构造12priority_queue&lt;int&gt;pq1;priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt;pq2; priority_queue 有三个模板参数：元素类型（T），底层容器类型（Container，默认为 vector&lt;T&gt;），以及比较方式（Compare，默认为 std::less&lt;T&gt;）。 默认构造的 priority_queue (priority_queue&lt;int&gt;) 是一个最大堆，其中最大的元素在堆顶。 通过使用 std::greater&lt;int&gt; 作为比较对象 (priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt;)，你可以创建一个最小堆，其中最小的元素在堆顶。 (2)元素访问top () 访问栈顶元素 123456789101112#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;int main(){ priority_queue&lt;int,vector&lt;int&gt;,less&lt;int&gt;&gt;pq1; pq1.push(10); pq1.push(40); pq1.push(20); cout&lt;&lt;pq1.top()&lt;&lt;endl;//40 return 0;} (3)容量empty ()size () (4)修改器push 插入元素并排序pop 删除队首元素并排序 123456789101112131415161718#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;int main(){ priority_queue&lt;int&gt;pq1; pq1.push(10); pq1.push(40); pq1.push(20); pq1.push(30); while(!pq1.empty()) { cout&lt;&lt;pq1.top()&lt;&lt;&quot; &quot;; pq1.pop(); }//40 30 20 10 //如果是priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt;pq1;则10 20 30 40 return 0;} 9. STL 常用算法下面基本上都需要 #include&lt;algorithm&gt; 头文件 (1)for_each 和 transform12345678910vector&lt;int&gt;v;for(int i=0;i&lt;10;i++){ v.push_back(i+1);}vector&lt;int&gt;vtarget;vtarget.resize(v.size());transform(v.begin(), v.end(), vtarget.begin(), Transform());for_each(vtarget.begin(), vtarget.end(), myprint());//101 102 103 104 105 106 107 108 109 110 v.begin(), v.end()：表示要转换的输入范围是 v 的起始到末尾。 vtarget.begin()：表示转换后的结果要放到 vtarget 中，从其开始位置存储。 Transform()：这是一个函数对象或仿函数，用于指定要对输入范围的每个元素执行的操作。假定的 Transform 类 Transform 需要是一个函数对象，类似于： 123456struct Transform {int operator()(int val) const { return val + 100; } }; 该类重载了 operator()，使得 Transform 类的对象能够像函数一样被调用。 在 transform 函数中，每次调用 Transform() 时，都会对输入的元素执行 val + 100 的操作。 因此，v 中的每个元素 1, 2, ..., 10 将被转换为 101, 102, ..., 110，并存储在 vtarget 中。 for_each 是 C++ 标准库中的另一个算法，用于对范围内的每个元素执行某个操作。 这行代码的参数： vtarget.begin(), vtarget.end()：表示对 vtarget 的所有元素执行操作。 myprint()：这是另一个函数对象，用于指定对每个元素要执行的操作。假定的 myprint 类 myprint 需要是一个函数对象，类似于： 123456struct myprint { void operator()(int val) const { cout &lt;&lt; val &lt;&lt; &quot; &quot;; }}; 该类重载了 operator()，使得 myprint 类的对象可以像函数一样被调用。 函数 说明 find 查找元素 find_if 按条件查找元素 adjacent_find 查找相邻重复元素 binary_search 二分查找法 count 统计元素个数 count_if 按条件统计元素个数 (2)find find 用于查找指定元素。 如果在指定的范围内找到了目标元素，它会返回指向该元素的迭代器。 如果找不到目标元素，则返回一个**结束迭代器 (end())**，表示目标元素不在该范围内。函数原型1iterator find(iterator beg, iterator end, const T&amp; value); iterator beg: 开始迭代器，表示查找范围的起点（包括 beg）。 iterator end: 结束迭代器，表示查找范围的终点（不包括 end 本身）。 value: 要查找的目标值，函数将在 [beg, end) 范围内寻找该值。1234567891011121314vector&lt;int&gt;v;for(int i=0;i&lt;10;i++){ v.push_back(i+1);}vector&lt;int&gt;::iterator it=find(v.begin(),v.end(),5);if(it==v.end()){ cout&lt;&lt;&quot;未找到&quot;&lt;&lt;endl;}else{ cout&lt;&lt;&quot;找到:&quot;&lt;&lt;*it&lt;&lt;endl;} (3)find_if功能描述:按条件查找元素函数原型: find_if(iterator beg, iterator end, _Pred); 按值查找元素,找到返回指定位置选代器,找不到返回结束选代器位置beg开始迭代器end结束迭代器_Pred 函数或者谓词(返回bool类型的仿函数) 12345678910111213141516171819class mycompare { public: bool operator()(int a) { return a &gt; 5; } }; void test01() { vector&lt;int&gt;v; for (int i = 0; i &lt; 10; i++) v.push_back(i + 1); vector&lt;int&gt;::iterator it = find_if(v.begin(), v.end(), mycompare()); if (it == v.end()) cout &lt;&lt; &quot;未找到&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;找到&quot; &lt;&lt; *it &lt;&lt; endl;//找到6 } (4)binary_search查找指定的元素，查到返回true，否则返回false注意：在无序序列中不可用,因为结果会出错降序也不行，只能用于升序序列 12345vector&lt;int&gt;v={0,1,2,3,4,5,6,7,8}; if (binary_search(v.begin(), v.end(), 6)) cout &lt;&lt; &quot;找到了&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;未找到&quot; &lt;&lt; endl; (5)adjacent_find查找相邻重复元素，返回相邻元素的第一个位置的迭代器 123456vector&lt;int&gt;v={0,2,0,3,1,4,3,3,2}; vector&lt;int&gt;::iterator pos = adjacent_find(v.begin(), v.end()); if (pos == v.end()) cout &lt;&lt; &quot;未找到&quot; &lt;&lt; endl; else cout &lt;&lt; *pos &lt;&lt; endl;//输出3 (6)count统计元素个数 123vector&lt;int&gt;v={0,1,2,3,5,3,3,6,8}; int cou = count(v.begin(), v.end(), 3); cout &lt;&lt; cou &lt;&lt; endl; (7)count_if1234567891011121314class greaterfive { public: bool operator()(int a) { return a &gt; 5; } }; void test01() { vector&lt;int&gt;v={0,1,2,7,5,6,3,6,8}; int cou = count_if(v.begin(), v.end(), greaterfive()); cout &lt;&lt; cou &lt;&lt; endl; //4} (8)sort 排序算法12345678910111213141516void myprint(int val) { cout &lt;&lt; val &lt;&lt; &quot; &quot;; } void test01() { vector&lt;int&gt;v={10,30,50,20,40,90}; for_each(v.begin(), v.end(), myprint); //10 30 50 20 40 90cout &lt;&lt; endl; sort(v.begin(), v.end()); for_each(v.begin(), v.end(), myprint); //10 20 30 40 50 90cout &lt;&lt; endl; sort(v.begin(), v.end(), greater&lt;int&gt;()); //greater&lt;int&gt;() 表示 &quot;大于&quot;，因此 sort 函数会将较大的元素排在前面，形成降序排列。for_each(v.begin(), v.end(), myprint); //90 50 40 30 20 10cout &lt;&lt; endl; } (9)random_shuffle123srand((unsigned int)time(NULL)); //设置随机数种子vector&lt;int&gt;v={0,1,2,3,4,5,6,7,8,9}; random_shuffle(v.begin(), v.end());//随机打乱v的排序 在 C++11 及更高版本中，推荐使用 std::shuffle 替代 random_shuffle 1234567891011#include &lt;algorithm&gt; // for std::shuffle#include &lt;random&gt; // for std::default_random_engineint main() { std::vector&lt;int&gt; v = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; std::random_device rd; // 用于获取随机种子 std::default_random_engine rng(rd()); // 随机数生成器 std::shuffle(v.begin(), v.end(), rng); return 0;} (10)merge可以把两个有序序列合在一起，形成一个新的有序序列 12345678910111213141516171819void myprint(int val) { cout &lt;&lt; val &lt;&lt; &quot; &quot;; } void test01() { vector&lt;int&gt;v1; vector&lt;int&gt;v2; for (int i = 0; i &lt; 10; i++) { v1.push_back(i); v2.push_back(i + 1); } vector&lt;int&gt;vTarget;//目标容器 vTarget.resize(v1.size() + v2.size()); merge(v1.begin(), v1.end(), v2.begin(), v2.end(), vTarget.begin()); for_each(vTarget.begin(), vTarget.end(), myprint); //0 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9 10cout &lt;&lt; endl; } (11)reverse逆序 12345678910111213void myprint(int val){ cout&lt;&lt;val&lt;&lt;endl;}void test(){ vector&lt;int&gt;v={10,30,40,50,20}; for_each(v.begin(),v.end(),myprint);//10 30 40 50 20 cout&lt;&lt;endl; reverse(v.begin(),v.end()); for_each(v.begin(),v.end(),myprint);//20 50 40 30 10 cout&lt;&lt;endl;} (12)copy将容器内指定范围的元素拷贝到另一容器中注意：新容器需要预留空间 12345678910111213void mypriny(int val){ cout&lt;&lt;val&lt;&lt;endl;}void test(){ vector&lt;int&gt;v={10,30,40,50,20}; vector&lt;int&gt;v2; v2.resize(v.size()); copy(v.begin(),v.end(),v2.begin()); for_each(v2.begin(),v2.end(),myprint);//10 30 40 50 20 cout&lt;&lt;endl;} (13)replace 和 replace_ifreplace将容器内指定范围的旧元素修改为新元素replace_if将区间内满足条件替换成指定元素 12345678910111213141516171819202122232425void myprint(int val) { cout &lt;&lt; val &lt;&lt; &quot; &quot;; } //compare是一个仿函数（函数对象）。通过重载 operator()，使得 compare 类的对象可以像函数一样被调用。class compare { public: bool operator()(int a) { return a &gt;= 40; } }; void test01() { vector&lt;int&gt;v={10,30,40,30,20,10,30,40,50,20}; for_each(v.begin(), v.end(), myprint); //10 30 40 30 20 10 30 40 50 20cout &lt;&lt; endl; replace(v.begin(), v.begin() + 4, 30, 300); //[v.begin(), v.begin() + 4)所有值为 30 的元素替换为 300for_each(v.begin(), v.end(), myprint); //10 300 40 300 20 10 30 40 50 20cout &lt;&lt; endl; replace_if(v.begin(), v.end(), compare(), 66); for_each(v.begin(), v.end(), myprint); //10 66 66 66 20 10 30 66 66 20cout &lt;&lt; endl; } (14)swap交换 123456vector&lt;int&gt;v={10,30,40,30,20,10,30,40,50,20}; vector&lt;int&gt;v1; for (int i = 0; i &lt; 10; i++) v1.push_back(i + 1);swap(v, v1); for_each(v.begin(), v.end(), myprint); cout &lt;&lt; endl; (15)accumulate 和 fill#include&lt;numeric&gt; accumulate计算容器元素累计总和fill向容器中添加元素 1234567891011121314151617181920212223void myprint(int val) { cout &lt;&lt; val &lt;&lt; &quot; &quot;; } void test01() { vector&lt;int&gt;v{10,30,40,30,20,10,30,40,50,20}; for_each(v.begin(), v.end(), myprint); cout &lt;&lt; endl; int total=accumulate(v.begin(), v.end(), 0); //第三个参数表示起始累加值，0表示最后结果加0 cout &lt;&lt; total &lt;&lt; endl; } void test02() { vector&lt;int&gt;v; v.resize(10); for_each(v.begin(), v.end(), myprint); cout &lt;&lt; endl; fill(v.begin(), v.end() - 2, 6); for_each(v.begin(), v.end(), myprint); cout &lt;&lt; endl; } 输出： 123410 30 40 30 20 10 30 40 50 20 2800 0 0 0 0 0 0 0 0 0 6 6 6 6 6 6 6 6 0 0 (16)交集，并集，差集set_intersection求两个容器的交集set_union并集set_difference差集 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt; // for set_intersection, set_union, set_differenceusing namespace std;void printVector(const vector&lt;int&gt;&amp; v) { for (int val : v) { cout &lt;&lt; val &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl;}int main() { // 两个有序的 vector 容器 vector&lt;int&gt; v1 = {1, 2, 3, 4, 5, 6}; vector&lt;int&gt; v2 = {4, 5, 6, 7, 8, 9}; vector&lt;int&gt; result; // 用于存储结果 // 求交集 result.resize(min(v1.size(), v2.size())); // 交集的最大可能大小为两个容器的最小值 auto it = set_intersection(v1.begin(), v1.end(), v2.begin(), v2.end(), result.begin()); result.resize(it - result.begin()); // 调整结果大小为实际交集元素的大小 cout &lt;&lt; &quot;Intersection of v1 and v2: &quot;; printVector(result); // 输出交集 // 求并集 result.clear(); result.resize(v1.size() + v2.size()); // 并集的最大可能大小为两个容器的和 it = set_union(v1.begin(), v1.end(), v2.begin(), v2.end(), result.begin()); result.resize(it - result.begin()); // 调整结果大小为实际并集元素的大小 cout &lt;&lt; &quot;Union of v1 and v2: &quot;; printVector(result); // 输出并集 // 求差集 v1 - v2 result.clear(); result.resize(v1.size()); // 差集的最大可能大小为第一个容器的大小 it = set_difference(v1.begin(), v1.end(), v2.begin(), v2.end(), result.begin()); result.resize(it - result.begin()); // 调整结果大小为实际差集元素的大小 cout &lt;&lt; &quot;Difference of v1 and v2 (v1 - v2): &quot;; printVector(result); // 输出差集 // 求差集 v2 - v1 result.clear(); result.resize(v2.size()); // 差集的最大可能大小为第二个容器的大小 it = set_difference(v2.begin(), v2.end(), v1.begin(), v1.end(), result.begin()); result.resize(it - result.begin()); // 调整结果大小为实际差集元素的大小 cout &lt;&lt; &quot;Difference of v2 and v1 (v2 - v1): &quot;; printVector(result); // 输出差集 return 0;} (17)next_premutation全排列 1234567891011121314vector&lt;int&gt;vec; for (int i = 0; i &lt; 3; i++) { vec.emplace_back(i + 1); //emplace_back(i + 1)是一个更有效的插入方式（类似于 push_back），用来在容器末尾直接构造元素。} for (auto k : vec) cout &lt;&lt; k &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; while (next_permutation(vec.begin(), vec.end())) { for (auto k : vec) cout &lt;&lt; k &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; } next_permutation 是 C++ &lt;algorithm&gt; 头文件中的一个函数，用于生成从当前排列组合的下一个字典序排列。 如果当前的排列组合已经是最大的排列组合，则 next_permutation 会返回 false，否则返回 true。 需要注意，next_permutation 只能在有序的容器上工作，因此 vec 必须按升序（或其他顺序）排列才能生成所有排列组合。输出：1234561 2 3 1 3 2 2 1 3 2 3 1 3 1 2 3 2 1 (18)lower_bound 和 upper_boundlower_bound( )和upper_bound( )都是利用二分查找的方法在一个排好序的数组中进行查找的。 在从小到大的排序数组中，lower_bound( begin,end,num)：从数组的begin位置到end-1位置二分查找第一个大于或等于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。 upper_bound( begin,end,num)：从数组的begin位置到end-1位置二分查找第一个大于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。 也可以用于vector容器，返回值是迭代器 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int cmd(int a, int b) { return a &gt; b;}int main() { int num[6] = { 1, 2, 4, 7, 15, 34 }; // 默认的排序是从小到大，因此这里其实是多余的操作 sort(num, num + 6); // 按从小到大排序 // 使用 lower_bound 查找第一个大于或等于 7 的位置 int pos1 = lower_bound(num, num + 6, 7) - num; // lower_bound 返回的迭代器减去 num 的起始地址，得到相应的位置索引。 cout &lt;&lt; pos1 &lt;&lt; &quot; &quot; &lt;&lt; num[pos1] &lt;&lt; endl; // 输出：3 7 // 使用 upper_bound 查找第一个大于 7 的位置 int pos2 = upper_bound(num, num + 6, 7) - num; cout &lt;&lt; pos2 &lt;&lt; &quot; &quot; &lt;&lt; num[pos2] &lt;&lt; endl; // 输出：4 15 // 按从大到小排序 sort(num, num + 6, cmd); // cmd 定义为从大到小排序 // 使用 lower_bound 查找第一个小于或等于 7 的位置 int pos3 = lower_bound(num, num + 6, 7, greater&lt;int&gt;()) - num; cout &lt;&lt; pos3 &lt;&lt; &quot; &quot; &lt;&lt; num[pos3] &lt;&lt; endl; // 输出：2 7 // 使用 upper_bound 查找第一个小于 7 的位置 int pos4 = upper_bound(num, num + 6, 7, greater&lt;int&gt;()) - num; cout &lt;&lt; pos4 &lt;&lt; &quot; &quot; &lt;&lt; num[pos4] &lt;&lt; endl; // 输出：3 4 return 0;}","link":"/2024/10/03/STL/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2023/12/13/hello-world/"},{"title":"Unity2D小游戏","text":"演示视频","link":"/2024/07/19/Unity2D/"},{"title":"docker学习笔记","text":"小白的docker学习全过程 参考文献 黑马程序员Docker快速入门到项目部署，MySQL部署+Nginx部署+docker自定义镜像+DockerCompose项目实战一套搞定_哔哩哔哩_bilibili Ubuntu · Docker – 从入门到实践 (docker-practice.github.io) Docker 教程 | 菜鸟教程 (runoob.com) 介绍 开源的应用容器引擎，基于 GO 语言 可以让开发者打包应用以及依赖报到一个轻量级可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。 概念 镜像 image ，相当于一个 root 文件系统 容器 container ,镜像是静态的定义，容器是镜像运行时的实体，容器可以被创建，启动，停止，删除，暂停等等。 仓库 respository，一个代码控制中心，用来保存镜像,目前 Docker 官方维护了一个公共仓库 Docker Hub。大部分需求都可以通过在 Docker Hub 中直接下载镜像来实现。 Dockerfile ,一个文本文件，包含了构建 Docker 镜像的所有指令。Docker Dockerfile | 菜鸟教程 (runoob.com) Docker Compose, Compose 是用于定义和运行多容器 Docker 应用程序的工具。通过Compose，可以使用 YML 文件来配置应用程序需要的所有服务。然后，使用一个命令，就可以从 YML 文件配置中创建并启动所有服务。Docker Compose | 菜鸟教程 (runoob.com) Swarm 集群管理，Swarm 集群管理 | 菜鸟教程 (runoob.com) 准备1234567891011121314151617181920212223242526272829PS C:\\Users\\zhuyu&gt; wsl --list --verbose NAME STATE VERSION* Ubuntu Running 2PS C:\\Users\\zhuyu&gt; wslWelcome to fish, the friendly interactive shellType help for instructions on how to use fishzyh@QAQ /m/c/U/zhuyu&gt; neofetch .-/+oossssoo+/-. zyh@QAQ `:+ssssssssssssssssss+:` ------- -+ssssssssssssssssssyyssss+- OS: Ubuntu 22.04.3 LTS on Windows 10 x86_64 .ossssssssssssssssssdMMMNysssso. Kernel: 5.15.153.1-microsoft-standard-WSL2 /ssssssssssshdmmNNmmyNMMMMhssssss/ Uptime: 5 mins +ssssssssshmydMMMMMMMNddddyssssssss+ Packages: 521 (dpkg), 6 (snap) /sssssssshNMMMyhhyyyyhmNMMMNhssssssss/ Shell: fish 3.3.1.ssssssssdMMMNhsssssssssshNMMMdssssssss. Terminal: Windows Terminal+sssshhhyNMMNyssssssssssssyNMMMysssssss+ CPU: 11th Gen Intel i5-1135G7 (8) @ 2.419GHzossyNMMMNyMMhsssssssssssssshmmmhssssssso GPU: 613e:00:00.0 Microsoft Corporation Device 008eossyNMMMNyMMhsssssssssssssshmmmhssssssso Memory: 525MiB / 7808MiB+sssshhhyNMMNyssssssssssssyNMMMysssssss+.ssssssssdMMMNhsssssssssshNMMMdssssssss. /sssssssshNMMMyhhyyyyhdNMMMNhssssssss/ +sssssssssdmydMMMMMMMMddddyssssssss+ /ssssssssssshdmNNNNmyNMMMMhssssss/ .ossssssssssssssssssdMMMNysssso. -+sssssssssssssssssyyyssss+- `:+ssssssssssssssssss+:` .-/+oossssoo+/-.zyh@QAQ /m/c/U/zhuyu&gt; 解释检查 WSL 安装状态：wsl --list --verbose进入 WSL：wsl展示系统信息： neofetch 是一个命令行工具，用于显示系统信息和操作系统的 ASCII 艺术图案。 安装我按照这个教程来的：Ubuntu · Docker – 从入门到实践 (docker-practice.github.io) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239Welcome to fish, the friendly interactive shellType help for instructions on how to use fishzyh@QAQ ~&gt; $ sudo apt-get updatefish: Expected a variable name after this $.zyh@QAQ ~&gt; $ sudo apt-get updatefish: Expected a variable name after this $.zyh@QAQ ~&gt; sudo apt-get update[sudo] password for zyh:Hit:1 http://mirrors.matrix.moe/ubuntu jammy InReleaseGet:2 http://mirrors.matrix.moe/ubuntu jammy-updates InRelease [128 kB]Get:3 http://mirrors.matrix.moe/ubuntu jammy-backports InRelease [127 kB]Get:4 http://mirrors.matrix.moe/ubuntu jammy-security InRelease [129 kB]Get:5 http://mirrors.matrix.moe/ubuntu jammy-updates/main amd64 Packages [2058 kB]Get:6 http://mirrors.matrix.moe/ubuntu jammy-updates/main Translation-en [355 kB]Get:7 http://mirrors.matrix.moe/ubuntu jammy-updates/main amd64 c-n-f Metadata [17.8 kB]Get:8 http://mirrors.matrix.moe/ubuntu jammy-updates/restricted amd64 Packages [2495 kB]Get:9 http://mirrors.matrix.moe/ubuntu jammy-updates/restricted Translation-en [429 kB]Get:10 http://mirrors.matrix.moe/ubuntu jammy-updates/universe amd64 Packages [1124 kB]Get:11 http://mirrors.matrix.moe/ubuntu jammy-updates/universe Translation-en [261 kB]Get:12 http://mirrors.matrix.moe/ubuntu jammy-updates/universe amd64 c-n-f Metadata [26.1 kB]Get:13 http://mirrors.matrix.moe/ubuntu jammy-backports/universe amd64 Packages [28.8 kB]Get:14 http://mirrors.matrix.moe/ubuntu jammy-backports/universe amd64 c-n-f Metadata [672 B]Get:15 http://mirrors.matrix.moe/ubuntu jammy-security/main amd64 Packages [1839 kB]Get:16 http://mirrors.matrix.moe/ubuntu jammy-security/main Translation-en [298 kB]Get:17 http://mirrors.matrix.moe/ubuntu jammy-security/main amd64 c-n-f Metadata [13.3 kB]Get:18 http://mirrors.matrix.moe/ubuntu jammy-security/restricted amd64 Packages [2431 kB]Get:19 http://mirrors.matrix.moe/ubuntu jammy-security/restricted Translation-en [418 kB]Get:20 http://mirrors.matrix.moe/ubuntu jammy-security/universe amd64 Packages [903 kB]Get:21 http://mirrors.matrix.moe/ubuntu jammy-security/universe Translation-en [177 kB]Get:22 http://mirrors.matrix.moe/ubuntu jammy-security/universe amd64 c-n-f Metadata [19.3 kB]Fetched 13.3 MB in 5s (2688 kB/s)Reading package lists... Donezyh@QAQ ~&gt; sudo apt-get install \\ apt-transport-https \\ ca-certificates \\ curl \\ gnupg \\ lsb-releaseReading package lists... DoneBuilding dependency tree... DoneReading state information... Donelsb-release is already the newest version (11.1.0ubuntu4).lsb-release set to manually installed.ca-certificates is already the newest version (20230311ubuntu0.22.04.1).ca-certificates set to manually installed.gnupg is already the newest version (2.2.27-3ubuntu2.1).gnupg set to manually installed.The following additional packages will be installed: libcurl4The following NEW packages will be installed: apt-transport-httpsThe following packages will be upgraded: curl libcurl42 upgraded, 1 newly installed, 0 to remove and 144 not upgraded.Need to get 485 kB of archives.After this operation, 172 kB of additional disk space will be used.Do you want to continue? [Y/n] yGet:1 http://mirrors.matrix.moe/ubuntu jammy-updates/universe amd64 apt-transport-https all 2.4.13 [1510 B]Get:2 http://mirrors.matrix.moe/ubuntu jammy-updates/main amd64 curl amd64 7.81.0-1ubuntu1.18 [194 kB]Get:3 http://mirrors.matrix.moe/ubuntu jammy-updates/main amd64 libcurl4 amd64 7.81.0-1ubuntu1.18 [289 kB]Fetched 485 kB in 0s (1154 kB/s)Selecting previously unselected package apt-transport-https.(Reading database ... 28748 files and directories currently installed.)Preparing to unpack .../apt-transport-https_2.4.13_all.deb ...Unpacking apt-transport-https (2.4.13) ...Preparing to unpack .../curl_7.81.0-1ubuntu1.18_amd64.deb ...Unpacking curl (7.81.0-1ubuntu1.18) over (7.81.0-1ubuntu1.14) ...Preparing to unpack .../libcurl4_7.81.0-1ubuntu1.18_amd64.deb ...Unpacking libcurl4:amd64 (7.81.0-1ubuntu1.18) over (7.81.0-1ubuntu1.14) ...Setting up apt-transport-https (2.4.13) ...Setting up libcurl4:amd64 (7.81.0-1ubuntu1.18) ...Setting up curl (7.81.0-1ubuntu1.18) ...Processing triggers for man-db (2.10.2-1) ...Processing triggers for libc-bin (2.35-0ubuntu3.4) ...zyh@QAQ ~&gt; curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpgzyh@QAQ ~&gt; echo \\ &quot;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://mirrors.aliyun.com/docker-ce/linux/ubuntu \\ $(lsb_release -cs) stable&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/nullfish: $(...) is not supported. In fish, please use '(lsb_release)'. $(lsb_release -cs) stable&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null^zyh@QAQ ~&gt; echo \\ &quot;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://mirrors.aliyun.com/docker-ce/linux/ubuntu \\ $(lsb_release -cs) stable&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/nullfish: $(...) is not supported. In fish, please use '(lsb_release)'. $(lsb_release -cs) stable&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null^zyh@QAQ ~&gt; echo \\ &quot;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://mirrors.aliyun.com/docker-ce/linux/ubuntu \\ $(lsb_release -cs) stable&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null echo \\ &quot;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://mirrors.aliyun.com/docker-ce/linux/ubuntu \\ (lsb_release -cs) stable&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/nullfish: $(...) is not supported. In fish, please use '(lsb_release)'. $(lsb_release -cs) stable&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null^zyh@QAQ ~&gt; echo \\ &quot;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://mirrors.aliyun.com/docker-ce/linux/ubuntu \\ $(lsb_release -cs) stable&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null echo \\ &quot;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://mirrors.aliyun.com/docker-ce/linux/ubuntu \\ (lsb_release -cs) stable&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null ^Czyh@QAQ ~&gt; echo \\ &quot;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://mirrors.aliyun.com/docker-ce/linux/ubuntu \\ (lsb_release -cs) stable&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/nullzyh@QAQ ~&gt; sudo apt-get updateHit:1 http://mirrors.matrix.moe/ubuntu jammy InReleaseHit:2 http://mirrors.matrix.moe/ubuntu jammy-updates InReleaseHit:3 http://mirrors.matrix.moe/ubuntu jammy-backports InReleaseHit:4 http://mirrors.matrix.moe/ubuntu jammy-security InReleaseIgn:5 https://mirrors.aliyun.com/docker-ce/linux/ubuntu (lsb_release InReleaseErr:6 https://mirrors.aliyun.com/docker-ce/linux/ubuntu (lsb_release Release 404 Not Found [IP: 36.250.255.105 443]Reading package lists... DoneE: The repository 'https://mirrors.aliyun.com/docker-ce/linux/ubuntu (lsb_release Release' does not have a Release file.N: Updating from such a repository can't be done securely, and is therefore disabled by default.N: See apt-secure(8) manpage for repository creation and user configuration details.zyh@QAQ ~ [100]&gt; lsb_release -csjammyzyh@QAQ ~&gt; deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://mirrors.aliyun.com/docker-ce/linux/ubuntu jammy stableCommand 'deb' not found, did you mean: command 'dub' from snap dub (1.19.0) command 'den' from snap den (1.2.0-0) command 'dub' from deb dub (1.27.0-2) command 'dcb' from deb iproute2 (5.15.0-1ubuntu2) command 'dab' from deb bsdgames (2.17-29) command 'dex' from deb dex (0.9.0-1) command 'debc' from deb devscripts (2.22.1ubuntu1) command 'edb' from deb edb-debugger (1.3.0-1) command 'deb3' from deb quilt (0.66-2.1) command 'debi' from deb devscripts (2.22.1ubuntu1) command 'derb' from deb icu-devtools (70.1-2)See 'snap info &lt;snapname&gt;' for additional versions.zyh@QAQ ~ [127]&gt; echo &quot;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://mirrors.aliyun.com/docker-ce/linux/ubuntu jammy stable&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/nullzyh@QAQ ~&gt; sudo apt-get updateHit:1 http://mirrors.matrix.moe/ubuntu jammy InReleaseHit:2 http://mirrors.matrix.moe/ubuntu jammy-updates InReleaseHit:3 http://mirrors.matrix.moe/ubuntu jammy-backports InReleaseHit:4 http://mirrors.matrix.moe/ubuntu jammy-security InReleaseGet:5 https://mirrors.aliyun.com/docker-ce/linux/ubuntu jammy InRelease [48.8 kB]Get:6 https://mirrors.aliyun.com/docker-ce/linux/ubuntu jammy/stable amd64 Packages [39.3 kB]Fetched 88.2 kB in 1s (122 kB/s)Reading package lists... Donezyh@QAQ ~&gt; sudo apt-get install docker-ce docker-ce-cli containerd.io docker-compose-pluginReading package lists... DoneBuilding dependency tree... DoneReading state information... DoneThe following additional packages will be installed: dbus-user-session docker-buildx-plugin docker-ce-rootless-extras libslirp0 pigz slirp4netnsSuggested packages: aufs-tools cgroupfs-mount | cgroup-liteThe following NEW packages will be installed: containerd.io dbus-user-session docker-buildx-plugin docker-ce docker-ce-cli docker-ce-rootless-extras docker-compose-plugin libslirp0 pigz slirp4netns0 upgraded, 10 newly installed, 0 to remove and 144 not upgraded.Need to get 122 MB of archives.After this operation, 440 MB of additional disk space will be used.Do you want to continue? [Y/n] yGet:1 https://mirrors.aliyun.com/docker-ce/linux/ubuntu jammy/stable amd64 containerd.io amd64 1.7.22-1 [29.5 MB]Get:2 http://mirrors.matrix.moe/ubuntu jammy/universe amd64 pigz amd64 2.6-1 [63.6 kB]Get:3 http://mirrors.matrix.moe/ubuntu jammy-updates/main amd64 dbus-user-session amd64 1.12.20-2ubuntu4.1 [9442 B]Get:4 http://mirrors.matrix.moe/ubuntu jammy/main amd64 libslirp0 amd64 4.6.1-1build1 [61.5 kB]Get:5 http://mirrors.matrix.moe/ubuntu jammy/universe amd64 slirp4netns amd64 1.0.1-2 [28.2 kB]Get:6 https://mirrors.aliyun.com/docker-ce/linux/ubuntu jammy/stable amd64 docker-buildx-plugin amd64 0.16.2-1~ubuntu.22.04~jammy [29.9 MB]Get:7 https://mirrors.aliyun.com/docker-ce/linux/ubuntu jammy/stable amd64 docker-ce-cli amd64 5:27.2.1-1~ubuntu.22.04~jammy [15.0 MB]Get:8 https://mirrors.aliyun.com/docker-ce/linux/ubuntu jammy/stable amd64 docker-ce amd64 5:27.2.1-1~ubuntu.22.04~jammy [25.6 MB]Get:9 https://mirrors.aliyun.com/docker-ce/linux/ubuntu jammy/stable amd64 docker-ce-rootless-extras amd64 5:27.2.1-1~ubuntu.22.04~jammy [9572 kB]Get:10 https://mirrors.aliyun.com/docker-ce/linux/ubuntu jammy/stable amd64 docker-compose-plugin amd64 2.29.2-1~ubuntu.22.04~jammy [12.5 MB]Fetched 122 MB in 1min 7s (1832 kB/s)Selecting previously unselected package pigz.(Reading database ... 28752 files and directories currently installed.)Preparing to unpack .../0-pigz_2.6-1_amd64.deb ...Unpacking pigz (2.6-1) ...Selecting previously unselected package containerd.io.Preparing to unpack .../1-containerd.io_1.7.22-1_amd64.deb ...Unpacking containerd.io (1.7.22-1) ...Selecting previously unselected package dbus-user-session.Preparing to unpack .../2-dbus-user-session_1.12.20-2ubuntu4.1_amd64.deb ...Unpacking dbus-user-session (1.12.20-2ubuntu4.1) ...Selecting previously unselected package docker-buildx-plugin.Preparing to unpack .../3-docker-buildx-plugin_0.16.2-1~ubuntu.22.04~jammy_amd64.deb ...Unpacking docker-buildx-plugin (0.16.2-1~ubuntu.22.04~jammy) ...Selecting previously unselected package docker-ce-cli.Preparing to unpack .../4-docker-ce-cli_5%3a27.2.1-1~ubuntu.22.04~jammy_amd64.deb ...Unpacking docker-ce-cli (5:27.2.1-1~ubuntu.22.04~jammy) ...Selecting previously unselected package docker-ce.Preparing to unpack .../5-docker-ce_5%3a27.2.1-1~ubuntu.22.04~jammy_amd64.deb ...Unpacking docker-ce (5:27.2.1-1~ubuntu.22.04~jammy) ...Selecting previously unselected package docker-ce-rootless-extras.Preparing to unpack .../6-docker-ce-rootless-extras_5%3a27.2.1-1~ubuntu.22.04~jammy_amd64.deb ...Unpacking docker-ce-rootless-extras (5:27.2.1-1~ubuntu.22.04~jammy) ...Selecting previously unselected package docker-compose-plugin.Preparing to unpack .../7-docker-compose-plugin_2.29.2-1~ubuntu.22.04~jammy_amd64.deb ...Unpacking docker-compose-plugin (2.29.2-1~ubuntu.22.04~jammy) ...Selecting previously unselected package libslirp0:amd64.Preparing to unpack .../8-libslirp0_4.6.1-1build1_amd64.deb ...Unpacking libslirp0:amd64 (4.6.1-1build1) ...Selecting previously unselected package slirp4netns.Preparing to unpack .../9-slirp4netns_1.0.1-2_amd64.deb ...Unpacking slirp4netns (1.0.1-2) ...Setting up dbus-user-session (1.12.20-2ubuntu4.1) ...Setting up docker-buildx-plugin (0.16.2-1~ubuntu.22.04~jammy) ...Setting up containerd.io (1.7.22-1) ...Created symlink /etc/systemd/system/multi-user.target.wants/containerd.service → /lib/systemd/system/containerd.service.Setting up docker-compose-plugin (2.29.2-1~ubuntu.22.04~jammy) ...Setting up docker-ce-cli (5:27.2.1-1~ubuntu.22.04~jammy) ...Setting up libslirp0:amd64 (4.6.1-1build1) ...Setting up pigz (2.6-1) ...Setting up docker-ce-rootless-extras (5:27.2.1-1~ubuntu.22.04~jammy) ...Setting up slirp4netns (1.0.1-2) ...Setting up docker-ce (5:27.2.1-1~ubuntu.22.04~jammy) ...Created symlink /etc/systemd/system/multi-user.target.wants/docker.service → /lib/systemd/system/docker.service.Created symlink /etc/systemd/system/sockets.target.wants/docker.socket → /lib/systemd/system/docker.socket.Processing triggers for man-db (2.10.2-1) ...Processing triggers for libc-bin (2.35-0ubuntu3.4) ...zyh@QAQ ~&gt; sudo systemctl enable dockerSynchronizing state of docker.service with SysV service script with /lib/systemd/systemd-sysv-install.Executing: /lib/systemd/systemd-sysv-install enable dockerzyh@QAQ ~&gt; sudo systemctl start dockerzyh@QAQ ~&gt; sudo groupadd dockergroupadd: group 'docker' already existszyh@QAQ ~ [9]&gt; docker run --rm hello-worlddocker: permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock: Head &quot;http://%2Fvar%2Frun%2Fdocker.sock/_ping&quot;: dial unix /var/run/docker.sock: connect: permission denied.See 'docker run --help'.zyh@QAQ ~ [126]&gt; 解决 Unable to find image 'hello-world:latest' locally 的问题。 1234567891011121314151617181920212223242526272829303132333435363738394041Welcome to fish, the friendly interactive shellType help for instructions on how to use fishzyh@QAQ ~&gt; docker run --rm hello-worldUnable to find image 'hello-world:latest' locallydocker: Error response from daemon: Get &quot;https://registry-1.docker.io/v2/&quot;: context deadline exceeded (Client.Timeout exceeded while awaiting headers).See 'docker run --help'.zyh@QAQ ~ [125]&gt; sudo vim /etc/docker/daemon.json[sudo] password for zyh:zyh@QAQ ~&gt; sudo systemctl daemon-reloadzyh@QAQ ~&gt; sudo systemctl restart dockerzyh@QAQ ~&gt; docker run --rm hello-worldUnable to find image 'hello-world:latest' locallylatest: Pulling from library/hello-worldc1ec31eb5944: Pull completeDigest: sha256:91fb4b041da273d5a3273b6d587d62d518300a6ad268b28628f74997b93171b2Status: Downloaded newer image for hello-world:latestHello from Docker!This message shows that your installation appears to be working correctly.To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub. (amd64) 3. The Docker daemon created a new container from that image which runs the executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it to your terminal.To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bashShare images, automate workflows, and more with a free Docker ID: https://hub.docker.com/For more examples and ideas, visit: https://docs.docker.com/get-started/zyh@QAQ ~&gt; 使用 daocloud 镜像加速： 123456{ &quot;registry-mirrors&quot;: [ &quot;https://docker.m.daocloud.io&quot; ]} `` 使用 查看 docker 版本1docker --version 启动 docker 服务1sudo systemctl start docker 检查 docker 服务状态1sudo systemctl status docker 运行第一个容器1docker run hello-world 或者1docker run --rm hello-world 拉取镜像1docker pull nginx ps: nginx 是一个高性能的 HTTP 和反向代理 web 服务器 列出 docker 镜像1docker images 运行容器1docker run -d -p 8080:80 nginx 会将 nginx 容器的端口 80 投射到宿主机的 8080 端口，可以通过 https://localhost:8080 访问 Nginx 服务。 列出所有容器1docker ps 1docker ps -a 启动容器1docker start XX 停止容器1docker stop XX 删除容器1docker rm XX 删除本地镜像1docker rmi XX 查看容器日志1docker logs XX 进入容器内部1docker exec -it XX /bin/sh docker compose运行以下命令以下载 Docker Compose 的当前稳定版本：将可执行权限应用于二进制文件：创建软链：测试是否安装成功： 1234567891011121314zyh@QAQ ~ [3]&gt; set os (uname -s) set arch (uname -m) sudo curl -L &quot;https://github.com/docker/compose/releases/download/v2.2.2/docker-compose-$os-$arch&quot; -o /usr/local/bin/docker-compose % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed 0 0 0 0 0 0 0 0 --:--:-- 0:00:01 --:--:-- 0100 23.5M 100 23.5M 0 0 55309 0 0:07:25 0:07:25 --:--:-- 47077zyh@QAQ ~&gt; sudo chmod +x /usr/local/bin/docker-compose[sudo] password for zyh:zyh@QAQ ~&gt; sudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-composezyh@QAQ ~&gt; docker-compose --versionDocker Compose version v2.2.2 测试：使用一个简单的 docker-compose.yml 文件来运行一个 Nginx 容器。测试步骤： 创建一个测试文件夹，并进入该文件夹： 12mkdir dockercomposetestcd dockercomposetest 创建一个 docker-compose.yml 文件： 1nano docker-compose.yml 在文件中粘贴以下内容： 123456version: '3'services: web: image: nginx:alpine ports: - &quot;8080:80&quot; 这个文件会使用 nginx:alpine 镜像，并将本地的 8080 端口映射到容器的 80 端口。 运行 Docker Compose： 1sudo docker-compose up 如果 Docker Compose 正常工作，看到下面的输出，表明 Nginx 容器启动成功： 12345678910111213141516171819202122232425262728293031323334353637383940zyh@QAQ ~/dockercomposetest&gt; sudo docker-compose up[+] Running 9/9 ⠿ web Pulled 30.8s ⠿ 43c4264eed91 Pull complete 2.4s ⠿ 5b19511a843d Pull complete 2.6s ⠿ 652d69a25e85 Pull complete 2.6s ⠿ 51676974aef5 Pull complete 2.7s ⠿ bb16f69e8876 Pull complete 2.7s ⠿ 6fb07faa0055 Pull complete 2.7s ⠿ c298c5a0cd21 Pull complete 4.8s ⠿ 0c02f601d0ee Pull complete 12.0s[+] Running 2/2 ⠿ Network dockercomposetest_default Created 0.2s ⠿ Container dockercomposetest-web-1 Created 0.2sAttaching to dockercomposetest-web-1dockercomposetest-web-1 | /docker-entrypoint.sh: /docker-entrypoint.d/ is not empty, will attempt to perform configurationdockercomposetest-web-1 | /docker-entrypoint.sh: Looking for shell scripts in /docker-entrypoint.d/dockercomposetest-web-1 | /docker-entrypoint.sh: Launching /docker-entrypoint.d/10-listen-on-ipv6-by-default.shdockercomposetest-web-1 | 10-listen-on-ipv6-by-default.sh: info: Getting the checksum of /etc/nginx/conf.d/default.confdockercomposetest-web-1 | 10-listen-on-ipv6-by-default.sh: info: Enabled listen on IPv6 in /etc/nginx/conf.d/default.confdockercomposetest-web-1 | /docker-entrypoint.sh: Sourcing /docker-entrypoint.d/15-local-resolvers.envshdockercomposetest-web-1 | /docker-entrypoint.sh: Launching /docker-entrypoint.d/20-envsubst-on-templates.shdockercomposetest-web-1 | /docker-entrypoint.sh: Launching /docker-entrypoint.d/30-tune-worker-processes.shdockercomposetest-web-1 | /docker-entrypoint.sh: Configuration complete; ready for start updockercomposetest-web-1 | 2024/09/24 16:43:16 [notice] 1#1: using the &quot;epoll&quot; event methoddockercomposetest-web-1 | 2024/09/24 16:43:16 [notice] 1#1: nginx/1.27.1dockercomposetest-web-1 | 2024/09/24 16:43:16 [notice] 1#1: built by gcc 13.2.1 20240309 (Alpine 13.2.1_git20240309)dockercomposetest-web-1 | 2024/09/24 16:43:16 [notice] 1#1: OS: Linux 5.15.153.1-microsoft-standard-WSL2dockercomposetest-web-1 | 2024/09/24 16:43:16 [notice] 1#1: getrlimit(RLIMIT_NOFILE): 1048576:1048576dockercomposetest-web-1 | 2024/09/24 16:43:16 [notice] 1#1: start worker processesdockercomposetest-web-1 | 2024/09/24 16:43:16 [notice] 1#1: start worker process 30dockercomposetest-web-1 | 2024/09/24 16:43:16 [notice] 1#1: start worker process 31dockercomposetest-web-1 | 2024/09/24 16:43:16 [notice] 1#1: start worker process 32dockercomposetest-web-1 | 2024/09/24 16:43:16 [notice] 1#1: start worker process 33dockercomposetest-web-1 | 2024/09/24 16:43:16 [notice] 1#1: start worker process 34dockercomposetest-web-1 | 2024/09/24 16:43:16 [notice] 1#1: start worker process 35dockercomposetest-web-1 | 2024/09/24 16:43:16 [notice] 1#1: start worker process 36dockercomposetest-web-1 | 2024/09/24 16:43:16 [notice] 1#1: start worker process 37dockercomposetest-web-1 | 172.19.0.1 - - [24/Sep/2024:16:43:39 +0000] &quot;GET / HTTP/1.1&quot; 200 615 &quot;-&quot; &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/129.0.0.0 Safari/537.36 Edg/129.0.0.0&quot; &quot;-&quot; 打开浏览器并访问 http://localhost:8080，看到 Nginx 的欢迎页面，表明 Docker Compose 运行成功。 停止容器，按 Ctrl+C，然后运行以下命令来清理环境： 1sudo docker-compose down 实战这里以我的项目 project: 基于Springboot+Vue的亚健康管理系统 (gitee.com) 为例，将这个 web 项目部署到 docker 中运行。通过Docker容器化的方式，不需要在本地（Windows或WSL）安装Node.js、MySQL、Java等开发依赖，这些依赖项完全可以由Docker来管理。Docker容器会为每个服务提供一个独立的运行环境，本地机器不需要直接安装这些服务。只需要安装Docker和Docker Compose工具，剩下的依赖都在Docker中管理。通过Git和Docker Compose，团队成员可以轻松启动、重建和管理开发环境，简化协作流程。 项目调研关键信息将一个包含 Vue、Spring Boot 和 MySQL 的项目部署到 Docker 中的过程涉及构建多个 Docker 容器来分别运行前端、后端和数据库。需要考虑以下关键信息： Vue 项目的打包配置： Vue 项目是否已经通过 npm run build 或者 yarn build 进行生产环境打包？ 是否有 Dockerfile 或现成的部署脚本？ Spring Boot 应用的构建方式： Spring Boot 项目是否使用 Maven 或 Gradle 进行构建？ 是否已生成了 .jar 文件，或者是否有 Dockerfile 来构建 Spring Boot 容器？ MySQL 配置： MySQL 数据库的版本？ 数据库的初始化脚本（如有的话）？ MySQL 的数据库配置，是否需要挂载外部数据卷保存数据？ 应用的连接配置： Vue 前端如何连接到 Spring Boot 后端？（例如，API 地址在开发时是否通过代理，或者已经设置为生产环境的 URL） Spring Boot 如何连接 MySQL？是否有外部配置（如 application.properties 或 application.yml 中的数据库连接设置）？ 其他配置： 是否有任何环境变量，配置文件或 secrets 需要传递给容器？ 是否需要使用 Docker Compose 来管理多个容器（例如前端、后端、数据库）？ 实际情况 ： vue项目还没打包，没有dockerfile 2.springboot采用maven构建，没有.jar文件，没有dockerfile 其中pom.xml为：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;3.2.5&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;demo&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;17&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!--SpringMvc--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--mybatis--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.0.3&lt;/version&gt; &lt;/dependency&gt; &lt;!--MySQL--&gt; &lt;dependency&gt; &lt;groupId&gt;com.mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-j&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;!--lombok--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter-test&lt;/artifactId&gt; &lt;version&gt;3.0.3&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-spring-boot3-starter&lt;/artifactId&gt; &lt;version&gt;3.5.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;/groupId&gt; &lt;artifactId&gt;hutool-all&lt;/artifactId&gt; &lt;version&gt;5.8.25&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;excludes&gt; &lt;exclude&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/exclude&gt; &lt;/excludes&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/project&gt; 我不知道mysql的版本；MySQL 的数据库配置需要挂载外部数据卷保存数据 vue前端和springboot后端通过跨域配置进行连接 ,vue.config.js内容为: 1234567891011121314151617181920212223242526272829 // 跨域配置module.exports = { devServer: { //记住，别写错了devServer//设置本地默认端口 选填 //port: 9876, proxy: { //设置代理，必须填 '/api': { //设置拦截器 拦截器格式 斜杠+拦截器名字，名字可以自己定 target: 'http://localhost:9091', //代理的目标地址 changeOrigin: true, //是否设置同源，输入是的 pathRewrite: { //路径重写 '^/api': '' //选择忽略拦截器里面的内容 } } } }} 没有环境变量，配置文件或 secrets 需要传递给容器需要使用 Docker Compose 来管理多个容器，即前端、后端、数据库 大致的部署流程 为 Vue 应用创建 Dockerfile：该 Dockerfile 用于将 Vue 应用打包为静态文件并部署到 Nginx 或其他 web 服务器中。 为 Spring Boot 应用创建 Dockerfile：这个 Dockerfile 将包含 Java 环境和 Spring Boot .jar 文件。 使用 Docker Compose 配置文件：编写 docker-compose.yml 文件，用于启动 Vue 前端、Spring Boot 后端和 MySQL 数据库的三个服务。 方案注意：下面有两种方案，我采取的是方案二 方案一：使用Docker Desktop的WSL集成Docker Desktop，启用WSL 2 集成，这样Docker Desktop会将WSL与Windows的Docker环境整合在一起。 打开Docker Desktop，在设置中启用 WSL 2 integration，并选择你使用的WSL发行版（如Ubuntu）。 在Windows PowerShell或WSL中运行Docker：在Windows的PowerShell中：1cd D:\\Desktop\\project docker-compose up --build 在WSL中：1cd /mnt/d/Desktop/project docker-compose up --build 优点：这种方式将WSL与Windows Docker紧密结合，无论你是在Windows还是WSL中操作Docker，都可以使用相同的Docker环境。 方案二：将项目目录映射到WSL中的文件系统如果你想继续使用WSL中的Docker，而不能直接在WSL中访问Windows文件系统，那么可以通过以下方法解决： 挂载Windows的文件系统到WSL： 在WSL中，Windows的文件系统已经挂载在/mnt/目录下。例如，C:\\盘的文件可以在WSL中通过/mnt/c/访问。 在WSL中访问Windows上的项目： 你可以在WSL中通过/mnt/目录访问Windows的文件。例如，如果你的项目在D:\\Desktop\\project下，你可以在WSL中访问它：1cd /mnt/d/Desktop/project 在WSL中运行Docker命令： 进入项目目录后，你可以在WSL的fish shell中运行Docker命令：1docker-compose up --build 优点： 这种方式允许你使用WSL中的Docker，但仍然能够访问Windows文件系统，避免了项目文件复制的麻烦。 方案三：将项目文件复制到WSL的文件系统中如果你希望项目文件完全在WSL的Linux文件系统中，你可以将项目文件从Windows复制到WSL中，之后再通过WSL的Docker进行操作。 复制项目到WSL：在PowerShell中运行以下命令，将项目复制到WSL的文件系统中（例如，复制到/home/your-user/projects目录）： 1cp -r D:\\Desktop\\project\\health_manage_springboot \\\\wsl$\\Ubuntu\\home\\your-user\\projects\\ 在WSL中进入项目目录：打开WSL的终端，进入项目目录：1cd ~/projects/health_manage_springboot 运行Docker命令：在项目目录下，运行docker-compose up --build命令：1docker-compose up --build 优点：这种方式将项目文件复制到WSL的Linux文件系统中，确保在WSL环境下操作更加流畅，避免文件系统访问的问题。 操作通过创建 Dockerfile、配置 Docker Compose 文件，将前端、后端和数据库拆解为不同的容器。 1. 打包 Vue 项目在部署到 Docker 之前，Vue 项目需要打包成静态文件。 步骤： 确保你已经安装了 Node. js。 在项目根目录下，执行以下命令打包 Vue 项目：12npm installnpm run build 这将生成一个 dist 目录，里面是打包好的静态资源文件。 2. 创建 Vue 的 Dockerfile在 Vue 项目的根目录中，创建一个 Dockerfile，用于构建一个运行 Vue 静态文件的 Nginx 容器。 Dockerfile (Vue)1234567891011121314151617181920212223242526272829303132# 选择node环境作为构建阶段FROM node:16 AS build-stage# 设置工作目录WORKDIR /app# 将package.json和package-lock.json复制到容器中COPY package*.json ./# 安装依赖RUN npm install# 将项目代码复制到容器中COPY . .# 打包项目RUN npm run build# Nginx用于托管打包后的静态文件FROM nginx:alpine AS production-stage# 将Nginx配置文件替换为自定义配置文件COPY nginx.conf /etc/nginx/nginx.conf# 将打包后的静态文件复制到Nginx的html目录COPY --from=build-stage /app/dist /usr/share/nginx/html# 暴露80端口EXPOSE 80# 启动NginxCMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;] Nginx 配置文件 (nginx. conf)你需要创建一个 nginx.conf 文件，指定如何处理前端资源： 1234567891011121314151617181920212223242526272829303132333435# nginx.confworker_processes auto;events { worker_connections 1024;}http { include /etc/nginx/mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; # 配置server块，处理前端请求和API代理 server { listen 80; server_name localhost; location / { root /usr/share/nginx/html; index index.html index.htm; try_files $uri $uri/ /index.html; } # 代理API请求到后端Spring Boot服务 location /api/ { proxy_pass http://backend:9091/; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; } }} 3. 打包 Spring Boot 项目为了将 Spring Boot 项目部署到 Docker 中，我们需要先生成一个可执行的 JAR 文件。 使用系统环境中的Maven： 在项目根目录下，使用 Maven 打包 Spring Boot 项目：1mvn clean package 这将在 target 目录中生成一个 JAR 文件。 IDEA的Maven工具：这里由于我开发时使用的 maven 是 idea 自带的，在终端运行时会报错，故使用 IDE 自带的 Maven 项目进行打包。 打开IntelliJ IDEA，进入Spring Boot项目。 点击右侧的“Maven”工具窗口（如果看不到，可以通过View -&gt; Tool Windows -&gt; Maven来打开）。 展开项目中的Maven模块，找到Lifecycle。 在Lifecycle下，找到clean和package两个任务。 先双击clean，然后再双击package。 这样，IntelliJ IDEA会使用自带的Maven来清理项目并打包为JAR文件。打包完成后，生成的JAR文件会在target目录下。 4. 创建 Spring Boot 的 Dockerfile在 Spring Boot 项目的根目录中，创建一个 Dockerfile，用于构建 Spring Boot 容器。 Dockerfile (Spring Boot)1234567891011121314# 使用openjdk作为基础镜像FROM openjdk:17-jdk-alpine# 设置工作目录WORKDIR /app# 复制打包好的JAR文件到容器中COPY target/demo-0.0.1-SNAPSHOT.jar app.jar# 暴露9091端口EXPOSE 9091# 启动Spring Boot应用ENTRYPOINT [&quot;java&quot;, &quot;-jar&quot;, &quot;app.jar&quot;] 5. MySQL 容器配置为了将 MySQL 运行在 Docker 中，我们可以直接使用官方的 MySQL 镜像，并通过 Docker Compose 配置其数据库、用户和挂载外部数据卷来保存数据。在 6 中可以完成这个需求。 6. 创建 Docker Compose 文件Docker Compose 文件用于管理这三个服务（Vue 前端、Spring Boot 后端、MySQL 数据库）。 docker-compose. yml12345678910111213141516171819202122232425262728293031323334353637383940414243version: '3'services: # Vue前端 frontend: build: context: ./vue-project # 指定Vue项目的根目录 dockerfile: Dockerfile dns: - 8.8.8.8 - 8.8.4.4 #这里指定使用Google DNS服务器（8.8.8.8和8.8.4.4），因为我在npm install时出现ETIMEOUT，故设置Google的公共DNS服务器解决该问题。也可以通过增加网络超时时间或者本地安装依赖导入node_modules解决 ports: - &quot;8080:80&quot; # 将容器的80端口映射到主机的8080端口 depends_on: - backend # 确保后端先启动 # Spring Boot后端 backend: build: context: ./springboot-project # 指定Spring Boot项目的根目录 dockerfile: Dockerfile ports: - &quot;9091:9091&quot; # 映射后端服务端口 environment: SPRING_DATASOURCE_URL: jdbc:mysql://db:3306/health?useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=UTC SPRING_DATASOURCE_USERNAME: root SPRING_DATASOURCE_PASSWORD: 123456 depends_on: - db # 确保数据库先启动 # MySQL数据库 db: image: mysql:8.0 # MySQL镜像 environment: MYSQL_ROOT_PASSWORD: 123456 # 设置root密码 MYSQL_DATABASE: health # 初始化数据库 volumes: - db_data:/var/lib/mysql # 挂载卷，用于持久化存储 - /mnt/d/Desktop/project/health_management.sql:/docker-entrypoint-initdb.d/health_management.sql # 挂载SQL文件 ports: - &quot;3306:3306&quot; # 映射MySQL端口volumes: db_data: # 数据卷用于存储MySQL数据 7. 使用 Docker Compose 启动服务 在 WSL 中导航到项目的根目录1cd /mnt/d/Desktop/project 运行 docker compose 命令1docker-compose up --build 这个命令会： 构建 Vue 前端、Spring Boot 后端和 MySQL 的容器镜像。 使用 Nginx 托管 Vue 前端的静态文件。 将前端请求代理到后端 Spring Boot 应用。 启动 MySQL 并将数据保存在本地挂载卷中。 8. 检查服务是否正常运行 访问 http://localhost:8080 来查看 Vue 前端是否正常工作。 后端 Spring Boot 服务应该在 http://localhost:9091 正常运行。 通过 docker logs &lt;container_name&gt; 查看各个容器的日志，确保一切正常。 如果导入 sql 文件出现问题，检查SQL文件是否已经成功导入：进入 mysql 容器：1docker exec -it &lt;container_id&gt; /bin/bash (用 docker ps -a 获取 container_id)登录 mysql:1mysql -u root t-p 检查数据库中是否有你导入的表和数据：12USE health; SHOW TABLES; 如果 SQL 文件没有挂载成功的话可以采取手动导入 SQL 文件:注意这里的 sql 表格如果你是从 gitee 上直接 clone 的需要删除 CREATE DATABASE health; 这条语句，因为数据库 health 已经存在。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455zyh@QAQ /m/d/D/project (master)&gt; docker exec -it 649ab335c63b /bin/bashbash-5.1# mysql -u root -pEnter password:Welcome to the MySQL monitor. Commands end with ; or \\g.Your MySQL connection id is 13Server version: 8.0.39 MySQL Community Server - GPLCopyright (c) 2000, 2024, Oracle and/or its affiliates.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.mysql&gt; USE health;Reading table information for completion of table and column namesYou can turn off this feature to get a quicker startup with -ADatabase changedmysql&gt; SHOW TABLES;+------------------+| Tables_in_health |+------------------+| body || user |+------------------+2 rows in set (0.00 sec)mysql&gt; SELECT * FROM user;+----+----------+----------+-------------+------+----------------------+--------+| id | username | password | number | role | email | avatar |+----+----------+----------+-------------+------+----------------------+--------+| 1 | gss | 123456 | 13343243242 | 1 | super@aliyun.com | || 2 | zhangsan | 123456 | NULL | 1 | zhangsan@gmail.com | || 3 | lisi | 123456 | NULL | 1 | lisi@gmail.com | || 4 | wangwu | 123456 | NULL | 0 | wangwu@gmail.com | || 5 | zhaoer | 123456 | NULL | 0 | zhaoer@gmail.com | || 6 | songliu | 123456 | 4322432434 | 0 | songliu@gmail.com | || 13 | Alice | 123456 | 234532111 | 0 | alice@example.com | || 14 | Bob | 123456 | 13564736363 | 0 | bob@example.com | || 15 | Charlie | 123456 | 25323626 | 0 | charlie@example.com | || 16 | David1 | 123456 | 145256264 | 0 | david@example.com | || 17 | Emma | 123456 | 152334445 | 0 | emma@example.com | || 18 | Frank | 123456 | 1566543646 | 0 | frank@example.com | || 19 | Grace | 123456 | 1435253535 | 0 | grace@example.com | || 20 | Henry | 123456 | 15325363463 | 0 | henry@example.com | || 21 | Isabella | 123456 | 15353435 | 0 | isabella@example.com | || 22 | Jacob | 123456 | 114523424 | 0 | jacob@example.com | || 31 | test | 123456 | NULL | 0 | | |+----+----------+----------+-------------+------+----------------------+--------+17 rows in set (0.00 sec)mysql&gt; 上述信息表示一切功能正常。 补充 ： 停止正在运行的容器：1docker-compose down 停止并删除所有服务容器、网络和卷（不删除数据卷）再次启动：1docker-compose up --build 停止容器而不删除1docker-compose stop 再次启动：1docker-compose start 查看当前运行的容器1docker ps 包含历史：1docker ps -a","link":"/2024/09/25/docker%E5%AD%A6%E4%B9%A0/"},{"title":"算法","text":"初级算法 - LeetBook - 力扣（LeetCode） 数组 删除排序数组中的重复项给你一个非严格递增排列的数组 nums ，请你原地删除重复出现的元素，使每个元素只出现一次，返回删除后数组的新长度。元素的相对顺序应该保持一致。然后返回 nums 中唯一元素的个数。 考虑 nums 的唯一元素的数量为 k ，你需要做以下事情确保你的题解可以被通过： 更改数组 nums ，使 nums 的前 k 个元素包含唯一元素，并按照它们最初在 nums 中出现的顺序排列。nums 的其余元素与 nums 的大小不重要。返回 k 。 双指针解题 12345678910111213141516171819class Solution{public:int removeDuplicates(vector&lt;int&gt;&amp; nums){ int n=nums.size(); if(n=0){ return 0; } int fast=1,slow=1; while(fast&lt;n){ if(nums[fast]!=nums[fast-1]){ nums[slow]=nums[fast]; ++slow; } ++fast; } return slow;}}; 买卖股票的最佳时机 II给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。 在每一天，你可以决定是否购买和/或出售股票。你在任何时候最多只能持有一股股票。你也可以先购买，然后在同一天出售。 返回你能获得的最大利润。 12345678910111213class Solution{public: int maxProfit(vector&lt;int&gt;&amp;prices){ int n=prices.size(); int tot=0; for(int i=1;i&lt;n;i++){ if(prices[i]&gt;price[i-1]){ tot+=price[i]-price[i-1]; } } return tot; }}; 旋转数组 给定一个整数数组 nums，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。 使用一个新的数组 123456789101112131415161718class Solution{public: void rotate(vector&lt;int&gt;&amp;nums,int k){ int len=nums.size(); k=k%len; vector&lt;int&gt;res(len); //将后k个元素移到前面 for(int i=0;i&lt;k;i++){ res[i]=nums[len-k+i]; } //将前len-k个元素移到后面 for(int i=0;i&lt;len-k;i++){ res[k+i]=nums[i]; } //将结果复制回nums nums=res; }};也可以这样 1234567891011class Solution{public: void rotate(vector&lt;int&gt;&amp;nums,int k){ int n=nums.size(); vector&lt;int&gt;newArr(n); for(int i=0;i&lt;n;i++){ newArr[(i+k)%n]=nums[i]; } nums.assign(newArr.begin(),newArr.end()); }}; 存在重复元素给你一个整数数组 nums 。如果任一值在数组中出现 至少两次 ，返回 true ；如果数组中每个元素互不相同，返回 false 。题解：考虑排序，排序后数组的重复元素一定出现在相邻位置中 12345678910111213class Solution {public: bool containsDuplicate(vector&lt;int&gt;&amp; nums) { sort(nums.begin(),nums.end()); int n=nums.size(); for(int i=0;i&lt;n-1;i++){ if(nums[i]==nums[i+1]){ return true; } } return false;}; 只出现一次的数字 给你一个非空整数数组 nums ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。 第一次的解法（没有考虑线性时间复杂度）这么写是因为收到前面思路的影响 1234567891011121314151617181920212223242526272829303132class Solution {public: int singleNumber(vector&lt;int&gt;&amp; nums) { sort(nums.begin(), nums.end()); int n = nums.size(); // 如果数组只有一个元素，直接返回 if (n == 1) { return nums[0]; } // 检查第一个元素是否是唯一的 if (nums[0] != nums[1]) { return nums[0]; } // 检查最后一个元素是否是唯一的 if (nums[n - 1] != nums[n - 2]) { return nums[n - 1]; } // 从第二个元素到倒数第二个元素进行检查 for (int i = 1; i &lt; n - 1; i++) { if (nums[i] != nums[i - 1] &amp;&amp; nums[i] != nums[i + 1]) { return nums[i]; } } return -1; }}; 如果要考虑线性时间复杂度 O (n): 12345678910111213141516171819class Solution {public: int singleNumber(vector&lt;int&gt;&amp; nums) { int result = 0; for (int num : nums) { result ^= num; } return result; }}; 这个异或解法的时间复杂度是 O(n)，空间复杂度是 O(1)考虑线性时间复杂度和常量空间复杂度：异或运算异或运算有以下性质： a ^ a = 0（任何数与自己异或的结果是0） a ^ 0 = a（任何数与0异或的结果是这个数本身） 异或运算满足交换律和结合律。 因此，如果数组中除了一个数以外其他数都出现两次，那么将所有数进行异或运算，结果就是那个只出现一次的数。 ps: 复习位运算的规律：（相同为０不同为１）1^1=0;1^0=1;0^1=1;0^0=0;6. 两个数组的交集Ⅱ 给你两个整数数组 nums 1 和 nums 2 ，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。法一：哈希表遍历第一个数组，在哈希表中记录第一个数组中每个数字以及出现的次数，然后遍历第二个数组，如果哈希表中存在这个数字，将这个数字添加到答案，并减少哈希表中该数字出现的次数。 123456789101112131415161718192021222324class Solution{public: vector&lt;int&gt;intersect(vector&lt;int&gt;&amp;nums1,vector&lt;int&gt;&amp;nums2){ if(nums1.size()&gt;nums2.size()){ return intersect(nums2,nums1); } unordered_map&lt;int,int&gt;m; for(int num:nums1){ ++m[num]; } vector&lt;int&gt;intersection; for(int num:nums2){ if(m.count(num)){ intersection.push_back(num); --m[num]; if(m[num]==0){ m.erase(num); } } } return intersection; }}","link":"/2024/09/14/%E6%89%93%E5%8D%A1%E8%B4%B4/"},{"title":"基于Springboot+Vue的WebApp开发实验报告","text":"Java与面向对象设计的大作业，实验报告docx用pandoc转成了md。 【实验目的】 掌握Java与面向对象基本原理和概念。 掌握Java与面向对象编程思想和主流技术或框架。 掌握基于Java开发完整软件Demo，并能演示。 【实验装备】 个人笔记本，idea，JDK环境，mysql，navicat, vue，git等。 【实验内容】 基于所选择的主题方向，调研、分析和设计3-5个核心场景（模块）作为研究对象，根据掌握的Java和相关知识，实现相对完整的WebApp应用。以Java为基础，可以自由选择搭配其它技术和框架，输出详细的设计文档、项目源代码和可运行的Demo视频。 【实验要求】 按实验内容输出详细设计、实现、运行关键截图，要求行文整洁、紧凑、顺畅。 代码以团队gitee形式提交，视频以百度网盘形式提交，可限时公开访问。 团队Gitee: JavaGroup (gitee.com) 本项目代码: JavaGroup/project(gitee.com) 视频百度网盘：链接提取码：2s45 实验报告需要交代团队成员分工，以及自己承担的任务（要求任务量合理，鼓励交叉参与）；个人报告要求完整，团队成果部分精炼描述，侧重个人为主部分加以详细描述。 【实验分析】 输出实验分析总结和心得体会。 【参考资料】 参考教程：带你从0搭建一个Springboot+vue前后端分离项目，真的很简单！_哔哩哔哩_bilibili 参考资料： 1. 一个 Vue 3 UI 框架 | Element Plus(element-plus.org) 2. Vue.js 教程 | Vue.js 中文文档(cn.vuejs.org) 3. SpringBoot+Vue个人健康管理系统Java毕业设计_哔哩哔哩_bilibili(主要参考要实现什么功能) 这个源代码上传至：JavaGroup/health_management(gitee.com) 【目录】 一.背景分析 经过了解和学习，为实现健康管理系统，我们采取了一种现代化的前后端分离架构，以下是我们选用的关键技术和工具： 1.前端技术 Vue.js：作为一个渐进式JavaScript框架，Vue.js被用于创建高效、灵活的用户界面。它的组件化架构让我们能够重用代码并加快开发速度。 Element-Plus：基于Vue3的桌面端组件库，提供了一套丰富的UI组件，帮助我们在保持界面美观的同时，减少了开发和设计的工作量。 2.后端技术 SpringBoot：简化了基于Spring的应用开发过程，使得我们能够快速搭建和部署微服务。SpringBoot自动配置的特性大幅度减轻了配置工作，让我们能够专注于业务逻辑的实现。 MyBatis：它是一个支持定制SQL、存储过程以及高级映射的持久层框架。MyBatis消除了几乎所有的JDBC代码，并手动设置参数以及获取结果集。通过简单的XML或注解，我们能够将接口映射成数据库中的记录。 Lombok：一个Java库，通过使用注解，能够自动化生成模板代码，如getters、setters、constructors等。Lombok极大地简化了我们的Java代码，使得它更加简洁易读。 3.数据库管理 MySQL：我们选择MySQL作为后端数据库，借助其强大和广泛支持的特性来存储应用数据。 Navicat：作为一款强大的数据库管理工具，Navicat让数据库的管理变得轻松便捷。它不仅支持MySQL，还支持大量其它数据库，提供直观的GUI方便进行数据管理、开发和维护。 二.需求分析 我们计划实现3-5个主核心功能，参考健康管理系统|拾果健康(sghealth.cn)及网上找到一些健康管理系统找到大概想实现的功能。在写好vue+springboot基本框架，搭建好跨域配置，写好依赖，写好基本的响应码，数据库配置，引入数据库表格写好mapper,controller,entity等等后，决定按功能分工，各自实现负责的功能的前端+后端。虽然前后端分离，但是功能一个人同时写，不断加功能完善项目，同时锻炼写前端和后端的能力。 三.系统设计 下面是我们当时设计的方案： 系统：管理员、用户 登录界面参考： 首页 健康信息上传 商品推荐 运动知识 评估与建议 随后进行抽签，选择各自要实现的功能。抽签决定好后先写好头部和侧边栏，新建不同的.vue和路由，之后每个人写自己的.vue并根据需要补充后端.java即可。 四.系统实现 团队成果： 采用前端部分使用Vue.js和Element-Plus来构建用户界面，后端使用SpringBoot和MyBatis进行业务逻辑的处理和数据持久化，同时使用Navicat来管理MySQL数据库，并借助Lombok简化Java代码的开发。 个人报告： 我的任务：准备阶段学习git，gitee的使用和navicat，idea的配置并创建gitee团队；正式写项目时负责4个小功能，分别是登录、注册、设置、健康问答。并简单改动一下其他部分的细节。最后整理项目时导出sql文件，写项目README。 我的gitee：Zhuyuehan (strangersinsist) -Gitee 1).准备阶段： 参照JavaGroup/health_management(gitee.com)学会怎么运行前端后端数据库,git的一些操作。 2).正式项目： 1.登录前端Login.vue，并在health_manage_vue\\src\\router\\index.js设置路由，点击按钮触发js,通过post与后端进行交互。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;script&gt;import request from &quot;@/utils/request&quot;;export default { name: &quot;Login&quot;, components: {User,Lock}, data(){ return { form:{}, rules:{ username:[ {required:true,message:&quot;请输入用户名&quot;,trigger:'blur'}, ], password:[ {required:true,message:&quot;请输入密码&quot;,trigger:'blur'}, ], } } }, methods:{ login(){ request.post(&quot;/api/user/login&quot;,this.form).then(res =&gt;{ console.log(res); if(res.code == '200'){ this.$message({ type: &quot;success&quot;, message:&quot;登录成功&quot; }) //改一下试图存缓存 sessionStorage.setItem(&quot;user&quot;, JSON.stringify(res.data)); this.$router.push(&quot;/&quot;) }else{ this.$message({ type:&quot;error&quot;, message:&quot;用户名或密码错误&quot; }) } }) } }}import { User,Lock,} from '@element-plus/icons-vue'&lt;/script&gt;&lt;template&gt; &lt;div class=&quot;login-container&quot;&gt; &lt;div class=&quot;login-card&quot;&gt; &lt;h1 class=&quot;login-title&quot;&gt;欢迎登录&lt;/h1&gt; &lt;el-form :model=&quot;form&quot; :rules=&quot;rules&quot; class=&quot;login-form&quot; ref=&quot;loginForm&quot; size=&quot;large&quot;&gt; &lt;el-form-item prop=&quot;username&quot; class=&quot;form-item&quot;&gt; &lt;el-icon class=&quot;icon&quot;&gt;&lt;User /&gt;&lt;/el-icon&gt; &lt;el-input v-model=&quot;form.username&quot; placeholder=&quot;用户名：&quot; class=&quot;input-field&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item prop=&quot;password&quot; class=&quot;form-item&quot;&gt; &lt;el-icon class=&quot;icon&quot;&gt;&lt;Lock /&gt;&lt;/el-icon&gt; &lt;el-input type=&quot;password&quot; v-model=&quot;form.password&quot; placeholder=&quot;密码：&quot; class=&quot;input-field&quot; show-password&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;div class=&quot;form-actions&quot;&gt; &lt;el-button class=&quot;action-button&quot; @click=&quot;login&quot;&gt;登录&lt;/el-button&gt; &lt;el-button class=&quot;action-button&quot; @click=&quot;this.$router.push('/register')&quot;&gt;注册&lt;/el-button&gt; &lt;/div&gt; &lt;/el-form&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;//这部分为了优化界面写的比较多，省略，详细看gitee代码&lt;/style&gt; 后端和队友共用的Result.java，User.java，UserMapper.java和UserController.java，用于获取数据库信息及返回数据给前端，我在队友写的代码基础上增加了需要的部分UserController.java: 12345678910111213141516171819202122232425262728package com.example.demo.controller;import …@RestController@RequestMapping(&quot;/user&quot;)public class UserController { @Resource UserMapper userMapper; @PostMapping(&quot;/login&quot;) public Result&lt;?&gt; login(@RequestBody User user){ User res = userMapper.selectOne(Wrappers.&lt;User&gt;lambdaQuery().eq(User::getUsername,user.getUsername()).eq(User::getPassword,user.getPassword())); if(res ==null){ return Result.fail(&quot;用户名或密码错误&quot;); } return Result.success(res); } @PostMapping(&quot;/register&quot;) public Result&lt;?&gt; register(@RequestBody User user){ User res = userMapper.selectOne(Wrappers.&lt;User&gt;lambdaQuery().eq(User::getUsername,user.getUsername())); if(res !=null){ return Result.fail(&quot;用户名重复&quot;); } if(user.getPassword()==null){ user.setPassword(&quot;123456&quot;); } userMapper.insert(user); return Result.success(user); } 最初是这样： 经过美化： 2.注册 与登录基本类似，前端Register.vue，并在index.js设置路由。详细代码可以看gitee。(这个后面和登录用了同样的方式美化了一下) 3.设置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;script&gt;import request from &quot;@/utils/request&quot;;export default { name: &quot;Setting&quot;, components: { }, data(){ return{ form:{}, input:&quot;&quot; } }, created(){ let str=sessionStorage.getItem(&quot;user&quot;)||&quot;{}&quot; this.form=JSON.parse(str) }, methods:{ handleClose(){ this.$router.push('/home'); }, update(){ request.put(&quot;api/user&quot;,this.form).then(res =&gt;{ console.log(res); if(res.code == '200'){ this.$message({ type: &quot;success&quot;, message:&quot;更新成功&quot; }) sessionStorage.setItem(&quot;user&quot;,JSON.stringify(this.form)) this.$router.push('/home'); }else{ this.$message({ type:&quot;error&quot;, message:&quot;更新失败&quot; }) } }) } }}&lt;/script&gt;&lt;template&gt; &lt;div&gt; &lt;el-dialog v-model=&quot;form&quot; title=&quot;个人信息编辑&quot; width=&quot;500&quot; @close=&quot;handleClose&quot;&gt; &lt;el-form :model=&quot;form&quot;&gt; &lt;el-form-item label=&quot;用户名&quot; :label-width=&quot;formLabelWidth&quot;&gt; &lt;el-input v-model=&quot;form.username&quot; disabled&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;密码&quot; :label-width=&quot;formLabelWidth&quot;&gt; &lt;el-input v-model=&quot;form.password&quot; show-password&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;手机号&quot; :label-width=&quot;formLabelWidth&quot;&gt; &lt;el-input v-model=&quot;form.number&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;邮箱&quot; :label-width=&quot;formLabelWidth&quot;&gt; &lt;el-input v-model=&quot;form.email&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;div class=&quot;dialog-footer&quot;&gt; &lt;el-button @click=&quot;this.$router.push('/home')&quot;&gt;取消&lt;/el-button&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;update&quot;&gt; 确认 &lt;/el-button&gt; &lt;/div&gt; &lt;/el-dialog&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;&lt;/style&gt; 这个是header.vue部分的设置，写这部分是新增了vue和路由实现的。这部分不难，是在element plus中找了表单，再写好script部分，获取的user信息就好了。后来优化这部分时补充handleClose方法点击叉号跳转/home页面，使操作更加流畅。 4.健康问答 前端实现：HomeView.vue: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&lt;template&gt;&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;chatbox&quot;&gt; &lt;h2 class=&quot;title&quot;&gt;健康问答&lt;/h2&gt; &lt;div class=&quot;messages&quot; ref=&quot;messageBox&quot;&gt; &lt;div v-for=&quot;(message, index) in messages&quot; :key=&quot;index&quot; :class=&quot;{'message-container': true, 'user-message': message.sender === 'User', 'bot-message': message.sender !== 'User'}&quot; &gt; &lt;el-avatar class=&quot;message-avatar&quot; style=&quot;background-color: cornflowerblue;color: black&quot;&gt;{{message.sender === 'User' ? 'User' : 'Bot'}}&lt;/el-avatar&gt; &lt;div class=&quot;message-content&quot;&gt;{{message.text}}&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;input-section&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;userinput&quot; v-model=&quot;userInput&quot; @keyup.enter=&quot;sendMessage&quot; placeholder=&quot;输入：&quot; /&gt; &lt;button class=&quot;send&quot; @click=&quot;sendMessage&quot; &gt; 发送 &lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import axios from 'axios'export default { name: 'HomeView', components: { }, data(){ return{ userInput: '', messages: [], } }, methods:{ async callAPIMethod(input) { try { const response = await axios.post('http://localhost:9091/reply', { message: input }); return response.data; } catch (error) { console.error(error); } }, async sendMessage() { this.messages.push({ sender: 'User', text: this.userInput, }); console.log(&quot;Ready to send message: &quot; + this.userInput); const response = await this.callAPIMethod(this.userInput); console.log(&quot;Received message: &quot; + response); if(response) { this.messages.push({ sender: 'Bot', text: response, }); } this.$refs.messageBox.scrollTop = this.$refs.messageBox.scrollHeight; this.userInput = ''; }, },}&lt;/script&gt;&lt;style scoped&gt;//这部分太长了省略，详细看gitee代码&lt;/style&gt; 后端实现：MessageController.java 1234567891011121314151617181920212223242526272829package com.example.demo.controller;import …class Message { private String message; // getter // setter}@CrossOrigin(origins = &quot;http://localhost:8080&quot;)@RestControllerpublic class MessageController { @PostMapping(&quot;/reply&quot;) public String reply(@RequestBody Message message) { Random rand = new Random(); String[] responses = {&quot;保持健康~&quot;, &quot;锻炼身体！&quot;, &quot;饮食规律~&quot;}; if (&quot;你好&quot;.equals(message.getMessage())) { return &quot;你好&quot;; } else if (&quot;什么是亚健康管理系统&quot;.equals(message.getMessage())) { return &quot;这个亚健康管理系统是人工智能学院java小组开发的。包括主页，运动知识，健康购物，评估与建议，健康信息上传的功能&quot;; } //省略一些else if else { return responses[rand.nextInt(responses.length)]; } }} 这部分本来我想连一个大语言模型的api，但是后来找不到适合的免费api，并且觉得如果是健康管理系统的话可能直接连一个大模型不太合适，要手动个性化设置一下，遂写了一些回复语代替，比较简洁，仅供演示。如果问”你好”和”什么是亚健康管理系统&quot;等会回复特定的话，问其他就在&quot;保持健康~&quot;,&quot;锻炼身体！&quot;, &quot;饮食规律~&quot;中随机回复一个。 最初是下面左图所示，右图是后来美化了一下。 5.一些其他的小细节 1）头部username显示 最初： 改动后： 显示具体的用户名 123&lt;template #title&gt; &lt;el-avatar style=&quot;background-color: cornflowerblue;color: black&quot;&gt;{{ user.username }}&lt;/el-avatar&gt; &lt;/template&gt; 2）管理员和普通用户权限，管理员可以看到用户管理的页面，这里是在数据库增加了role(int类型，1表示管理员0表示普通用户), 在Aside.vue： 1234 &lt;el-menu-item index=&quot;7&quot; v-if=&quot;user.role===1&quot; @click=&quot;this.$router.push('/user_manage')&quot;&gt; &lt;el-icon&gt;&lt;List /&gt;&lt;/el-icon&gt; &lt;span&gt;用户管理&lt;/span&gt;&lt;/el-menu-item&gt; v-if=&quot;user.role===1&quot; 这样实现的 在User_manage.vue: 123456&lt;el-table-column label=&quot;角色&quot;&gt; &lt;template #default=&quot;scope&quot;&gt; &lt;span v-if=&quot;scope.row.role===1&quot;&gt;管理员&lt;/span&gt; &lt;span v-if=&quot;scope.row.role===0&quot;&gt;普通用户&lt;/span&gt; &lt;/template&gt;&lt;/el-table-column&gt; 实现两者的显示。 3）未登录状况下强制跳转登录（这里是对我负责的登录功能的优化） 在index.js: 123456789101112// 添加一个 beforeEach 路由守卫,这里用于实现未登录情况下强制跳转/loginrouter.beforeEach((to, from, next) =&gt; { // 检查 sessionStorage 中是否已经有 user let user = sessionStorage.getItem('user'); // 如果没有 user 且访问的不是登录界面，那么强制跳转至登录页面 if (!user &amp;&amp; to.path !== '/login'&amp;&amp; to.path !== '/register') { return next({ path: '/login' }); } // 否则就继续进行本次路由 next();}); 6.sql文件的整理上传，详见giteehealth_management.sql 7.README，详见giteeREADME.md 五.总结展望 这次作业前期准备断断续续用了快一个月，后面写项目差不多两周左右。使用多一点框架会在正式开发中快很多，但是想要知道怎么用还是要学不少知识的。我们每个人都写了前端后端，如果你看源码会发现4个人不同的代码风格。总的来说，这次大作业还是学到了很多东西，见证了项目一点点搭建起来，培养团队合作能力，也真的加强了自信”我们可以自己写原创项目”。 展望的话，我们以后可以实现更完整一点的项目，比如文件上传，更丰富的管理员功能，验证码，服务器部署等等。","link":"/2024/06/18/web%E5%BC%80%E5%8F%91/"},{"title":"W4terCTF2024 writeup","text":"纯小白，做出的题很少 图片很糊但就先这样吧队友：https://github.com/kuku172放个友链Lst4r-max.github.io Spam 2024先找垃圾邮件，搜了很多东西后找到spammimic - encoded，然后第一步解码： 159,6f,75,20,6c,69,6b,65,20,65,6d,6f,6a,69,73,2c,20,64,6f,6e,27,74,20,79,6f,75,3f,0a,0a,01f643,01f4b5,01f33f,01f3a4,01f6aa,01f30f,01f40e,01f94b,01f6ab,01f606,2705,01f606,01f6b0,01f4c2,01f32a,263a,01f6e9,01f30f,01f4c2,01f579,01f993,01f405,01f375,01f388,01f600,01f504,01f6ab,01f3a4,01f993,2705,01f4ee,01f3a4,01f385,01f34e,01f643,01f309,01f383,01f34d,01f374,01f463,01f6b9,01f923,01f418,01f3f9,263a,01f463,01f4a7,01f463,01f993,01f33f,2328,01f32a,01f30f,01f643,01f375,2753,2602,01f309,01f606,01f3f9,01f375,01f4a7,01f385,01f449,01f30a,01f6b9,01f6aa,01f374,01f60e,01f383,01f32a,01f643,01f441,01f94b,01f451,01f4a7,01f418,01f3a4,01f94b,01f418,01f6e9,01f923,01f309,01f6e9,23e9,01f60d,2753,01f418,01f621,2600,01f60d,01f643,01f601,01f600,01f601,01f6ab,01f4c2,2705,2603,01f6ab,01f60e,01f52a,01f451,01f600,01f579,01f6ab,01f60d,01f32a,01f4c2,01f44c,01f34d,01f44c,01f993,01f590,01f923,01f60e,01f3ce,01f34d,01f3f9,01f34c,01f34d,01f3a4,2600,01f3f9,01f388,01f6b0,01f4a7,2600,2709,01f3f9,01f34d,01f993,01f385,01f374,2602,23e9,01f6aa,01f40d,263a,01f418,01f607,01f621,01f375,01f30f,01f993,01f375,01f6e9,01f4c2,01f44c,01f3f9,01f5d2,01f5d2,0a,0a,42,74,77,2c,20,74,68,65,20,6b,65,79,20,69,73,20,22,4b,45,59,22 前后是ACSII，中间是emoji的unicode。 123456789101112def hex_to_ascii(hex_string): bytes_object = bytes.fromhex(hex_string) ascii_string = bytes_object.decode(&quot;ASCII&quot;) return ascii_stringhex_string1 = &quot;59,6f,75,20,6c,69,6b,65,20,65,6d,6f,6a,69,73,2c,20,64,6f,6e,27,74,20,79,6f,75,3f,0a,0a&quot;hex_string1 = hex_string1.replace(',', '')print(hex_to_ascii(hex_string1)) hex_string2 = &quot;0a,0a,42,74,77,2c,20,74,68,65,20,6b,65,79,20,69,73,20,22,4b,45,59,22&quot;hex_string2 = hex_string2.replace(',', '')print(hex_to_ascii(hex_string2)) 1234unicode_string =&quot;01f643,01f4b5,01f33f,01f3a4,01f6aa,01f30f,01f40e,01f94b,01f6ab,01f606,2705,01f606,01f6b0,01f4c2,01f32a,263a,01f6e9,01f30f,01f4c2,01f579,01f993,01f405,01f375,01f388,01f600,01f504,01f6ab,01f3a4,01f993,2705,01f4ee,01f3a4,01f385,01f34e,01f643,01f309,01f383,01f34d,01f374,01f463,01f6b9,01f923,01f418,01f3f9,263a,01f463,01f4a7,01f463,01f993,01f33f,2328,01f32a,01f30f,01f643,01f375,2753,2602,01f309,01f606,01f3f9,01f375,01f4a7,01f385,01f449,01f30a,01f6b9,01f6aa,01f374,01f60e,01f383,01f32a,01f643,01f441,01f94b,01f451,01f4a7,01f418,01f3a4,01f94b,01f418,01f6e9,01f923,01f309,01f6e9,23e9,01f60d,2753,01f418,01f621,2600,01f60d,01f643,01f601,01f600,01f601,01f6ab,01f4c2,2705,2603,01f6ab,01f60e,01f52a,01f451,01f600,01f579,01f6ab,01f60d,01f32a,01f4c2,01f44c,01f34d,01f44c,01f993,01f590,01f923,01f60e,01f3ce,01f34d,01f3f9,01f34c,01f34d,01f3a4,2600,01f3f9,01f388,01f6b0,01f4a7,2600,2709,01f3f9,01f34d,01f993,01f385,01f374,2602,23e9,01f6aa,01f40d,263a,01f418,01f607,01f621,01f375,01f30f,01f993,01f375,01f6e9,01f4c2,01f44c,01f3f9,01f5d2,01f5d2&quot;unicode_list = unicode_string.split(',')emoji_string = ''.join(chr(int('0x' + uni, 16)) for uni in unicode_list)print(emoji_string) 12You like emojis, don't you?Btw, the key is &quot;KEY&quot; 1🙃💵🌿🎤🚪🌏🐎🥋🚫😆✅😆🚰📂🌪☺🛩🌏📂🕹🦓🐅🍵🎈😀🔄🚫🎤🦓✅📮🎤🎅🍎🙃🌉🎃🍍🍴👣🚹🤣🐘🏹☺👣💧👣🦓🌿⌨🌪🌏🙃🍵❓☂🌉😆🏹🍵💧🎅👉🌊🚹🚪🍴😎🎃🌪🙃👁🥋👑💧🐘🎤🥋🐘🛩🤣🌉🛩⏩😍❓🐘😡☀😍🙃😁😀😁🚫📂✅☃🚫😎🔪👑😀🕹🚫😍🌪📂👌🍍👌🦓🖐🤣😎🏎🍍🏹🍌🍍🎤☀🏹🎈🚰💧☀✉🏹🍍🦓🎅🍴☂⏩🚪🐍☺🐘😇😡🍵🌏🦓🍵🛩📂👌🏹🗒🗒 找到下面的工具：emoji-aes 发现密钥的问题，试了KEY的unicode, ascii,等等，🔑的unicode，用KEY生成垃圾邮件，都失败了。找到正确的密钥🔑。解密结果是： 10x???? ⊕ dxBUQVJndGJbbGByE3tGUW57VxV0bH9db3FSe2YFUndUexVUYWl/QW1FAW1/bW57EhQSEF0= 这个字符串应该是被异或操作过的结果，找到正确的16进制数与其进行异或就能得到原始信息。下面是暴力破解来找出可能的结果。异或运算的一个特点是自反的，就是用同一个键进行两次异或操作就可以恢复原始信息。 1234567import base64cipher_text = base64.b64decode('dxBUQVJndGJbbGByE3tGUW57VxV0bH9db3FSe2YFUndUexVUYWl/QW1FAW1/bW57EhQSEF0=')for xor_key in range(0x10000): # 试验所有 0x0000 到 0xffff 的可能key plain_text = ''.join(chr(b ^ (xor_key &amp; 0xff)) for b in cipher_text) print(f'0x{xor_key:04x}: {plain_text}') 第一次的代码有点问题，遍历输出只发现了一个很像的数据。分析了下奇数位和偶数位异或的值是不一样的，0x？？？？看得出来是个四位十六进制，这个奇数位看起来基本是对的。改一下代码，然后一样遍历枚举，就找到flag了。 12345678import base64cipher_text = base64.b64decode('dxBUQVJndGJbbGByE3tGUW57VxV0bH9db3FSe2YFUndUexVUYWl/QW1FAW1/bW57EhQSEF0=')xor_key_even = 0xfe20for xor_key_odd in range(0x10000): plain_text = &quot;&quot;.join(chr(cipher_text[i] ^ ((xor_key_odd if i % 2 else xor_key_even) &amp; 0xff)) for i in range(len(cipher_text))) print(f'key_odd: 0x{xor_key_odd:04x}, deciphered message: {plain_text}') GZ GPTnc：乱码解决方案：乱码恢复 手动改乱码比较慢，就使用python的pwn库，并导入codecs模块（基础编解码功能）进行无限交互直至远程服务器终止。 1234567891011from pwn import *import codecsconn = remote('127.0.0.1', 50338)while True: data = conn.recv().decode('utf-8') gbk_data = data.encode('gbk') print(f&quot;接收到的数据：{data}&quot;) conn.interactive() conn.close() 看提示，应该是每次返回的有隐藏数据（想到去年的shadow，感觉这次输出光标也有奇怪的闪动）。确定了下每次输出后都有隐藏信息，这题是考隐写的。把终端输出复制过来看到vscode的提示： 然后去查一下锁定类型：零宽度字符隐写，并找到工具Unicode Steganography with Zero-Width Characters。用笨蛋方法一句句复制粘贴上去解码的，把每次的Hidden Text粘贴上去就得到完整的flag了。 broken.mp4解压后一个视频是完好的，打开看看，很明显的提示了，明显是在微信打开的嘛，去微信上搜搜标题，很好找到这篇文章链接然后去下载公众号上说的那个软件恢复一下就OK了 Sign In四道签到题的最后一个（晚上公选课无聊乱翻榜单看到的） Remember It 0第一次做pwn题，随便试试，签到题的话一般跟着做就行（主要是懒得想其他方法了）看源码，笨蛋方法没问题，就一步步敲的然后cat flag Shuffle Puts签到题，嗯，打开IDA直接看strings 总结小白第一次玩CTF还是挺开心的，感觉算是入了门。（一周前容器实例还不会开netcat还不会用的）。如果这周事情不那么多就好了，这周太忙了有效做题时间不多，很多方向都没学，基本上就是在做Misc了。","link":"/2024/05/03/writeup/"}],"tags":[{"name":"cpp","slug":"cpp","link":"/tags/cpp/"},{"name":"unity","slug":"unity","link":"/tags/unity/"},{"name":"c#","slug":"c","link":"/tags/c/"},{"name":"docker","slug":"docker","link":"/tags/docker/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"springboot","slug":"springboot","link":"/tags/springboot/"},{"name":"web","slug":"web","link":"/tags/web/"},{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"mysql","slug":"mysql","link":"/tags/mysql/"},{"name":"ctf","slug":"ctf","link":"/tags/ctf/"}],"categories":[{"name":"STL","slug":"STL","link":"/categories/STL/"},{"name":"游戏开发","slug":"游戏开发","link":"/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"},{"name":"打卡","slug":"打卡","link":"/categories/%E6%89%93%E5%8D%A1/"},{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"web开发","slug":"web开发","link":"/categories/web%E5%BC%80%E5%8F%91/"},{"name":"CTF","slug":"CTF","link":"/categories/CTF/"}],"pages":[{"title":"about","text":"关于我：人工智能专业大二在读。正在努力学东西。","link":"/about/index.html"}]}