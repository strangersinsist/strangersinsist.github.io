{"posts":[{"title":"Unity2D小游戏","text":"演示视频","link":"/2024/07/19/Unity2D/"},{"title":"CPP-STL","text":"参考教程： cpp-STL - AlgorithmPark基本上是转载，跟着写了一遍理思路。 1. vector 容器头文件 #include&lt;vector&gt; (1)构造12345678910111213#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;vector&lt;int&gt;b;vector&lt;int&gt;a(10);vector&lt;int&gt;a(10,1);//10个整型元素的向量，每个值为1vector&lt;int&gt;a(b);//用向量b给a赋值vector&lt;int&gt;a(b.begin(),b.begin()+3);//将b中0-2个元素赋值给aint c[7]={1,2,3,4,5,6,7};vector&lt;int&gt;a(c,c+7);vector&lt;int&gt;a{1,2,3,4,5,6,7};vector&lt;int&gt;a={1,2,3,4,5,6,7}; (2)基本操作1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465void test01()//基本操作 { vector&lt;int&gt; a, b; int i=0; //b为向量，将b的0-2个元素赋值给向量a a.assign(b.begin(), b.begin() + 3); //a含有4个值为2的元素 a.assign(4, 2); //返回a的最后一个元素 a.back(); //返回a的第一个元素 a.front(); //返回a的第i元素,当且仅当a存在 a[i]; //清空a中的元素 a.clear(); //判断a是否为空，空则返回true，非空则返回false a.empty(); //删除a向量的最后一个元素 a.pop_back(); //删除a中第一个（从第0个算起）到第二个元素，也就是说删除的元素从a.begin()+1算起（包括它）一直到a.begin()+3（不包括它）结束 a.erase(a.begin() + 1, a.begin() + 3); //在a的最后一个向量后插入一个元素，其值为5 a.push_back(5); //在a的第一个元素（从第0个算起）位置(前面)插入数值5, a.insert(a.begin() + 1, 5); //在a的第一个元素（从第0个算起）位置（前面）插入3个数，其值都为5 a.insert(a.begin() + 1, 3, 5); //d为数组，在a的第一个元素（从第0个元素算起）的位置（前面）插入b的第三个元素到第5个元素（不包括b+6） int d[8]; a.insert(a.begin() + 1, d + 3, d + 6); //返回a中元素的个数 a.size(); //返回a在内存中总共可以容纳的元素个数 a.capacity(); //将a的现有元素个数调整至10个，多则删，少则补，其值随机 a.resize(10); //将a的现有元素个数调整至10个，多则删，少则补，其值为2 a.resize(10, 2); //将a的容量扩充至100， a.reserve(100); //b为向量，将a中的元素和b中的元素整体交换 a.swap(b); //b为向量，向量的比较操作还有 != &gt;= &gt; &lt;= &lt; a == b; } assign 赋值 insert 插入 resize 调整 reserve 扩充 (3)反向迭代12345678void test02(){ vector&lt;int&gt;a={1,2,3,4,5,6,7,8,9,10}; for(vector&lt;int&gt;::reverse_iterator iter=a.rbegin();iter!=a.rend();iter++) { cout&lt;&lt;*iter&lt;&lt;endl;//10 9 8 7 6 5 4 3 2 1 }} (4)插入 描述 函数签名 插入位置都在 pos 迭代器之前一个位置，返回的迭代器指向插入的第一个元素 在迭代器 pos 指定的位置之前插入一个新元素 elem，并返回表示新插入元素位置的迭代器 iterator insert(pos, elem) 在迭代器 pos 指定的位置之前插入 n 个元素 elem，并返回表示第一个新插入元素位置的迭代器 iterator insert(pos, n, elem) 在迭代器 pos 指定的位置之前，插入其他容器中位于 [first, last) 区域的所有元素，并返回表示第一个新插入元素位置的迭代器 iterator insert(pos, first, last) 在迭代器 pos 指定的位置之前，插入初始化列表（用大括号 {} 括起来的多个元素），中间有逗号隔开）中的所有的元素，并返回表示第一个新插入元素位置的迭代器 iterator insert(pos, initlist) 123456789101112void test03(){ vector&lt;int&gt;a={1,2,3,4,5,6,7,8,9,10}; vector&lt;int&gt;::iterator it1=a.begin()+4; vector&lt;int&gt;::iterator it2=a.insert(it1,{-1,-2,-3}); cout&lt;&lt;*it2&lt;&lt;endl;//-1,并返回表示第一个新插入元素位置的迭代器 for(auto k:a) { cout&lt;&lt;k&lt;&lt;&quot; &quot;;//1 2 3 4 -1 -2 -3 5 6 7 8 9 10 } cout&lt;&lt;endl;} (5) 函数 说明 pop_back() 删除 vector 容器中最后一个元素，该容器的大小（size）会减 1，但容量 (capacity) 不会发生改变。 erase(pos) 删除 vector 容器中 pos 迭代器指定位置处的元素，并返回指向被删除元素下一个位置的迭代器。该容器的大小 (size) 会减 1，但容量 (capacity) 不会发生改变。 ???swap(beg)、pop_back () 先调用 swap() 函数交换要删除的目标元素和容器最后一个元素的位置，然后使用 pop_back () 删除该目标元素。 erase(beg,end) 删除 vector 容器中位于迭代器 [beg, end) 指定区域内的所有元素，并返回指向被删除区域下一个位置元素的迭代器。该容器的大小 (size) 会减小，但容量 (capacity) 不会发生改变。 remove() 删除容器中所有和指定元素值相等的元素，并返回指向最后一个元素下一个位置的迭代器。值得一提的是，调用该函数不会改变容器的大小和容量。 clear() 删除 vector 容器中所有的元素，使其变成空的 vector 容器。该函数会改变 vector 的大小 (变为 0)，但不是改变其容量。 12345678910111213141516171819void test04(){ vector&lt;int&gt;a = { 1,2,3,4,5,6,6,6,6,7,8,9,10 }; int size = a.size(); ptrdiff_t cnt = count(a.begin(), a.end(), 6);//ptrdiff==long long，用于计算6出现的次数 auto it = remove(a.begin(), a.end(), 6);//移除所有的6，不会改变容器的大小和容量，只是覆盖 cout &lt;&lt; *it &lt;&lt; endl;//7，remove 返回的迭代器 it 指向 7，也就是第一个不为 6 的元素之后的新尾部。 cout &lt;&lt; cnt &lt;&lt; endl;//4 for (auto k : a) { cout &lt;&lt; k &lt;&lt; &quot; &quot;;//1 2 3 4 5 7 8 9 10 7 8 9 10 } cout &lt;&lt; endl; a.resize(size - cnt);//调整向量大小，除去末尾的6 for (auto k : a) { cout &lt;&lt; k &lt;&lt; &quot; &quot;;//1 2 3 4 5 7 8 9 10 }} 2.deque 容器头文件 #include&lt;deque (1)遍历容器12345678910void printdeque(const deque&lt;int&gt;&amp; d){ for(deque&lt;int&gt;::const_iterator it=d.begin();it!=d.end();it++) //注意迭代器也要换成带const的 { cout&lt;&lt;*it&lt;&lt;&quot; &quot;; //加const后容器中数据不可修改 } cout&lt;&lt;endl;} (2)构造容器1234567891011121314void test01() { deque&lt;int&gt;d1; for (int i = 0; i &lt; 10; i++) d1.push_front(i+1); printdeque(d1); //区间赋值 deque&lt;int&gt;d2(d1.begin(), d1.end()); printdeque(d2); deque&lt;int&gt;d3(10, 100); printdeque(d3); deque&lt;int&gt;d4(d3); printdeque(d4); } 程序输出： 123410 9 8 7 6 5 4 3 2 1 10 9 8 7 6 5 4 3 2 1 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 (3)赋值操作123456789101112131415161718192021void test03(){ deque&lt;int&gt;d1; for(int i=0;i&lt;10;i++) { d1.push_back(i+1); } printdeque(d1); //operator=赋值 deuqe&lt;int&gt;d2; d2=d1; printdeque(d2); //assign赋值 deque&lt;int&gt;d3; d3.assgin(d1.begin(),d1.end()); printdeque(d3); deque&lt;int&gt;d4; d4.assign(10,100); printdeque(d4); } 程序输出： 12341 2 3 4 5 6 7 8 9 10 1 2 3 4 5 6 7 8 9 10 1 2 3 4 5 6 7 8 9 10 100 100 100 100 100 100 100 100 100 100 (4)插入和删除1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;iostream&gt;#include &lt;deque&gt;using namespace std;// 打印 deque 的内容void printDeque(const deque&lt;int&gt;&amp; d) { for (int elem : d) { cout &lt;&lt; elem &lt;&lt; &quot; &quot;; } if (d.empty()) { cout &lt;&lt; &quot;(empty)&quot;; } cout &lt;&lt; endl;}void testDequeOperations() { deque&lt;int&gt; d; // 1. 头部插入 d.push_front(10); // 在头部插入 10 d.push_front(20); // 在头部插入 20 d.push_front(30); // 在头部插入 30 printDeque(d); // 输出: 30 20 10 // 2. 尾部插入 d.push_back(40); // 在尾部插入 40 d.push_back(50); // 在尾部插入 50 printDeque(d); // 输出: 30 20 10 40 50 // 3. 任意位置插入 d.insert(d.begin() + 2, 100); // 在第三个位置插入 100 d.insert(d.end() - 1, 2, 200); // 在倒数第二个位置插入两个 200 printDeque(d); // 输出: 30 20 100 10 40 200 200 50 // 4. 头部删除 d.pop_front(); // 删除头部元素 printDeque(d); // 输出: 20 100 10 40 200 200 50 // 5. 尾部删除 d.pop_back(); // 删除尾部元素 printDeque(d); // 输出: 20 100 10 40 200 200 // 6. 任意位置删除 d.erase(d.begin() + 1); // 删除第二个位置上的元素 printDeque(d); // 输出: 20 10 40 200 200 // 删除一个范围内的元素 d.erase(d.begin() + 2, d.end() - 1); // 删除第三个到倒数第二个元素 printDeque(d); // 输出: 20 10 200 // 清空整个 deque d.clear(); printDeque(d); // 输出: (empty)}int main() { testDequeOperations(); return 0;} } (5)数据存取1234567deque d1;d1[2];d1.at(2);//d1的第二个元素d1.front();d1.back();//访问d1的首尾元素 3. stack 容器头文件 #include&lt;stack&gt;后进先出 12345678910111213141516void test01(){ stack&lt;int&gt;s; s.push(10); s.push(20); s.push(30); s.push(40); int n=s.size(); for(int i=0;i&lt;n;i++) { cout&lt;&lt;s.top()&lt;&lt;&quot; &quot;;//40 30 20 10 s.pop(); //访问top后出栈 } cout&lt;&lt;endl;} 4. queue 容器头文件 #include&lt;queue&gt;先进先出 1234567891011121314151617181920212223242526272829303132333435#include&lt;queue&gt;using namespace std;void testqueue(){ queue&lt;int&gt;q; q.push(10); q.push(20); q.push(30); //创建一个temp用于打印元素 queue&lt;int&gt;temp=q; while(!q.empty()) { cout&lt;&lt;temp.front()&lt;&lt;&quot; &quot;;//输出队首元素 q.pop();//弹出队首元素 } cout&lt;&lt;endl; //获取队首尾元素 cout&lt;&lt;q.front()&lt;&lt;q.back()&lt;&lt;endl; cout&lt;&lt;q.empty()&lt;&lt;endl; cout&lt;&lt;q.size()&lt;&lt;endl; //清空队列 while(!q.empty()) { q.pop(); }}int main(){ testqueue(); return 0;} 5. string 容器(1)构造123456789101112void test01{ string s1; cout&lt;&lt;&quot;s1=&quot;&lt;&lt;s1&lt;&lt;endl; const char* str= &quot;hello world!&quot;//C风格的字符串str初始化为C++的string类型对象s2 string s2(str); cout&lt;&lt;&quot;s2=&quot;&lt;&lt;s2&lt;&lt;endl; string s3(s2); cout&lt;&lt;&quot;s3=&quot;&lt;&lt;s3&lt;&lt;endl; string s4(10,'b');//使用n个字符b初始化 cout&lt;&lt;&quot;s4=&quot;&lt;&lt;s4&lt;&lt;endl;} 1234s1= s2=hello world! s3=hello world! s4=bbbbbbbbbb (2)赋值123456789101112131415161718void test01{ string str1; str1=&quot;hello world!&quot;; cout&lt;&lt;&quot;str1=&quot;&lt;&lt;str1&lt;&lt;endl; string str2=str1; cout&lt;&lt;&quot;str2=&quot;&lt;&lt;str2&lt;&lt;endl; string str4; str4.assign(&quot;hello&quot;); cout&lt;&lt;&quot;str4=&quot;&lt;&lt;str4&lt;&lt;endl; string str5; str5.assign(&quot;hello&quot;,3);//将前3个字符赋值给str5 cout&lt;&lt;&quot;str5=&quot;&lt;&lt;str5&lt;&lt;endl; string str6; str6.assign(str5); string str7; str7.assign(10,'w');} (3)拼接1234567891011string s1=&quot;你&quot;;s1+=&quot;好&quot;;string s2=&quot;我也爱C语言&quot;;//s1.append(&quot;hello&quot;);//s1.append(&quot;you&quot;,2);//s1.append(s2); 、s1.append(s2,4,7);//从str2的第三个字符开始，截取4个加在末尾，第二个参数为起始字符的位置(位置从0开始计算)，第三个参数为字符的长度 //中文字符占2个位置，英文字符占1个位置cout&lt;&lt;&quot;s1=&quot;&lt;&lt;s1&lt;&lt;endl;//你好爱C语言 &quot;我&quot;（索引 0，长度 1）占两个字节。 &quot;也&quot;（索引 1，长度 1）占两个字节。 &quot;爱&quot;（索引 2，长度 1）占两个字节。 &quot;C&quot;（索引 3，长度 1）占一个字节。 &quot;语&quot;（索引 4，长度 1）占两个字节。 &quot;言&quot;（索引 5，长度 1）占两个字节。 (4)查找和替换123456string s=&quot;abcdefgdefg&quot;;int pos1=s.find(&quot;de&quot;);int pos2=s.find(&quot;df&quot;);//-1int pos3=s.rfind(&quot;df&quot;);//rfind是最后一次出现的位置，find是第一次出现的位置s.replace(1,3,&quot;1111&quot;);//从1号位起3个替换为1111//a1111efgdefg (5)字符串比较1234567891011121314151617void test01() { string str1 = &quot;hfllo&quot;; string str2 = &quot;hello&quot;; if (str1.compare(str2) == 0) { cout &lt;&lt; &quot;str1等于str2&quot; &lt;&lt; endl; } else if (str1.compare(str2) &gt; 0) { cout &lt;&lt; &quot;str1大于str2&quot; &lt;&lt; endl; } else { cout &lt;&lt; &quot;str1小于str2&quot; &lt;&lt; endl; } }//通过逐字符比较ASCII值，大于为1，小于为-1，等于为0,以第一个不一样的字符为准 1str1大于str2 数字 0-9：48-57 大写字母 A-Z：65-90 小写字母 a-z：97-122 (6)字符提取123456string str = &quot;hello&quot;; for (int i = 0; i &lt; 5; i++) cout &lt;&lt; str[i] &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; for (int i = 0; i &lt; 5; i++) cout &lt;&lt; str.at(i) &lt;&lt; &quot; &quot;; (7)插入和删除12345string s1=&quot;abcdefgh&quot;;s1.insert(2,&quot;xxx&quot;);//abxxxcdefghs1.erase(2,3);//删去从2开始的3个字符s1.insert(2,3,'x');//abcdefghs1.insert(2,3,'x');//abxxxcdefgh (8)子串123string s1=&quot;abd*cdf&quot;;int pos=s1.find('*');string s2=s1.substr(0,pos);//abd (9)其他 string s; // 生成一个空字符串s string s(str); // 拷贝构造函数生成str的复制品 string s(str, stridx); // 将字符串str内”始于位置stridx”的部分当作字符串的初值 string s(str, stridx, strlen); // 将字符串str内”始于stridx且长度顶多strlen”的部分作为字符串的初值 string s(cstr); // 将C字符串（以NULL结束）作为s的初值 string s(chars, chars_len); // 将C字符串前chars_len个字符作为字符串s的初值。 string s(num, ‘c’); // 生成一个字符串，包含num个c字符 string s(“value”); string s = “value”; // 将s初始化为一个字符串字面值副本 string s(begin, end); // 以区间begin/end(不包含end)内的字符作为字符串s的初值 s.~string(); //销毁所有字符，释放内存 string s; s.empty(); // s为空串 返回true s.size(); // 返回s中字符个数 类型应为：string::size_type s[n]; // 从0开始相当于下标访问 s1+s2; // 把s1和s2连接成新串 返回新串 s1=s2; // 把s1替换为s2的副本 v1 == v2; // 比较，相等返回true !=, &lt;, &lt;=, &gt;, &gt;= 惯有操作 任何一个大写字母都小于任意的小写字母 123string s(&quot;abc&quot;);s.size();strlen(s.c_str()); 1234567//把string字符串转化为C风格的字符串 string s = &quot;abcdefg&quot;; char str[1000]; strcpy(str, s.c_str()); str[0] = 'p'; str[5] = 'u'; //pbcdeug} 6. set 容器和 multiset 容器#include&lt;set&gt;set不允许容器中有重复的元素multiset允许容器中有重复的元素其他操作基本一致 (1)遍历容器1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;#include&lt;set&gt;using namespace std;void printset(const set&lt;int&gt;&amp;s){ if(s.empty()) { cout&lt;&lt;&quot;set数组为空&quot;&lt;&lt;endl; return; } for(set&lt;int&gt;::const_iterator it=s.begin();it!=s.end();it++) { cout&lt;&lt;*it&lt;&lt;&quot; &quot;; } cout&lt;&lt;endl;}void printmultiset(const multiset&lt;int&gt;&amp;m){ if(m.empty()) { cout&lt;&lt;&quot;multiset数组为空&quot;&lt;&lt;endl; return; } for(multiset&lt;int&gt;::const_iterator it=m.begin();it!=m.end();it++) { cout&lt;&lt;*it&lt;&lt;&quot; &quot;; } cout&lt;&lt;endl;} (2)插入和删除1234567891011121314151617181920212223242526set&lt;int&gt;s;s.insert(10);s.insert(20);s.insert(30); s.insert(40); s.insert(50); s.insert(60); s.insert(70); s.insert(80); s.insert(90); s.insert(100); s.insert(110); s.insert(120);printset(s);//10 20 30 40 50 60 70 80 90 100 110 120set&lt;int&gt;::iterator it=s.begin();set&lt;int&gt;::iterator it2;it2=s.erase(++++it);//删除30.删除迭代器所指元素，返回下一个元素的迭代器printset(s);//10 20 40 50 60 70 80 90 100 110 120set&lt;int&gt;::iterator it1=s.end();s.erase(it2,----it1);//删除区间[it2,----it1)的所有元素，返回下一个元素的迭代器printset(s);s.erase(110);printset(s);//10 20 120s.clear();//清空set容器printset(s);//set数组为空 (2)查找和统计1234567891011121314151617181920212223set&lt;int&gt;s;s.insert(10); s.insert(20); s.insert(30); s.insert(40); s.insert(30); s.insert(60); s.insert(70); s.insert(80); s.insert(70); s.insert(100); s.insert(110); s.insert(120); printset(s);set&lt;int&gt;::()iterator it1;//查找it1=s.find(70);//若存在，返回该键的元素的迭代器，若不存在，返回set.end()if(it1!=s.end()) cout&lt;&lt;*it&lt;&lt;endl;else cout&lt;&lt;&quot;未找到元素&quot;&lt;&lt;endl;//统计int num=s.count(30);cout&lt;&lt;num&lt;&lt;endl;//对于set而言，统计结果只有0和1 程序输出： 12310 20 30 40 60 70 80 100 110 120 70 1 (4)set 与 multiset123456789101112131415161718192021set&lt;int&gt;s;s.insert(20);s.insert(20);s.insert(30);s.insert(40);s.insert(30);s.insert(60);s.insert(70);s.insert(80);s.insert(70);s.insert(100);s.insert(110);s.insert(120);printset(s);pair&lt;set&lt;int&gt;::iterator,bool&gt;ret =s.insert(10);//insert()方法返回一个pair类型，pair&lt;set&lt;int&gt;::iterator,bool&gt;ret，这个first是迭代器，指向插入元素的位置,second是布尔值，表示是否插入成功if(ret.second) cout&lt;&lt;&quot;第一次插入成功&quot;&lt;&lt;endl;else cout&lt;&lt;&quot;第一次插入失败&quot;&lt;&lt;endl;pair&lt;set&lt;int&gt;::iterator,bool&gt;ret1 =s.insert(10);if(ret1.second) cout&lt;&lt;&quot;第二次插入成功&quot;&lt;&lt;endl;else cout&lt;&lt;&quot;第二次插入失败&quot;&lt;&lt;endl; 输出： 12320 30 40 60 70 80 100 110 120 第一次插入成功 第二次插入失败 7. map 和 multimap 容器头文件 #include&lt;map&gt;map 中所有元素都是 pair, 第一个元素为 key (键值), 起到索引作用, 第二个元素为 value（实值）所有元素都有根据元素键值自动排序 map/multimap属于关联式容器，底层结构是用二叉树实现优点：可以根据key值快速找到value值map和multimap区别:map不允许容器中有重复key值元素multimap允许容器中有重复key值元素 (1)遍历12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;#include&lt;map&gt;using namespace std;void printmap(const map&lt;int,int&gt;&amp;m){ if(m.empty()) { cout&lt;&lt;&quot;map容器为空&quot;&lt;&lt;endl; return; } for(map&lt;int,int&gt;::const_iterator it=m.begin();it!=m.end();it++) { cout&lt;&lt;&quot;学号:&quot;&lt;&lt;(*it).first&lt;&lt;&quot; 分数:&quot;&lt;&lt;(*it).second&lt;&lt;endl; } cout&lt;&lt;endl;}void test01(){ map&lt;int,int&gt;m; m.insert(pair&lt;int,int&gt;(1,60)); m.insert(pair&lt;int,int&gt;(2,95)); m.insert(pair&lt;int,int&gt;(4,73)); m.insert(pair&lt;int,int&gt;(3,81)); printmap(m);//按照key值自动排序 map&lt;int,int&gt;m2(m);//拷贝构造 printmap(m2); map&lt;int,int&gt;m3; m3=m2; printmap(m3);} (2)大小和转换1234map&lt;int,int&gt;ma;ma.size();//size()大小map&lt;int,int&gt;ma1;ma.swap(ma1);//swap()转换 (3)插入和删除123456789101112131415161718map&lt;int,int&gt;m;m.insert(pair&lt;int,int&gt;(1,60));m.insert(pair&lt;int,int&gt;(3,95));m.insert(pair&lt;int,int&gt;(4,73));m.insert(pair&lt;int,int&gt;(5,81));m.insert(make_pair(2,10));m.insert(map&lt;int,int&gt;::value_type(6,30));m[7]=40;//这种插数方法和其他的不同在于可以修改已经插入的key对应的valueprintmap(m);m.erase(m.begin(),++++m.begin());printmap(m);m.erase(4);//按照key删除printmap(m);m.clear();printmap(m); 程序输出： 123456789101112131415161718学号：1 分数：60 学号：2 分数：10 学号：3 分数：95 学号：4 分数：73 学号：5 分数：81 学号：6 分数：30 学号：7 分数：40 学号：3 分数：95 学号：4 分数：73 学号：5 分数：81 学号：6 分数：30 学号：7 分数：40 学号：3 分数：95 学号：5 分数：81 学号：6 分数：30 学号：7 分数：40 (4)查找和统计1234567891011121314151617map&lt;int,int&gt;m;m.insert(pair&lt;int, int&gt;(1,60));m.insert(pair&lt;int, int&gt;(3, 95)); m.insert(pair&lt;int, int&gt;(4, 73)); m.insert(pair&lt;int, int&gt;(5, 81)); m.insert(pair&lt;int, int&gt;(2, 84));map&lt;int,int&gt;::iterator it;it=m.find(4);if(it!=m.end()){ cout&lt;&lt;it-&gt;second&lt;&lt;endl;//73 //与cout &lt;&lt; (*it).second &lt;&lt; endl;等价}else{ cout&lt;&lt;&quot;编号不存在&quot;&lt;&lt;endl;}cout&lt;&lt;m.count(4)&lt;&lt;endl;//1 8. priority_queue头文件 #include&lt;queue&gt; priority_queue 是一个元素有序排列的队列，默认队列头部元素优先级最高。因为是一个队列，只能访问第一个元素，这也意味着优先级最高的元素总是第一个被处理。它能够实现常数时间的（默认）最大元素查找，对数代价的插入与释出 (1)构造12priority_queue&lt;int&gt;pq1;priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt;pq2; priority_queue 有三个模板参数：元素类型（T），底层容器类型（Container，默认为 vector&lt;T&gt;），以及比较方式（Compare，默认为 std::less&lt;T&gt;）。 默认构造的 priority_queue (priority_queue&lt;int&gt;) 是一个最大堆，其中最大的元素在堆顶。 通过使用 std::greater&lt;int&gt; 作为比较对象 (priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt;)，你可以创建一个最小堆，其中最小的元素在堆顶。 (2)元素访问top () 访问栈顶元素 123456789101112#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;int main(){ priority_queue&lt;int,vector&lt;int&gt;,less&lt;int&gt;&gt;pq1; pq1.push(10); pq1.push(40); pq1.push(20); cout&lt;&lt;pq1.top()&lt;&lt;endl;//40 return 0;} (3)容量empty ()size () (4)修改器push 插入元素并排序pop 删除队首元素并排序 123456789101112131415161718#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;int main(){ priority_queue&lt;int&gt;pq1; pq1.push(10); pq1.push(40); pq1.push(20); pq1.push(30); while(!pq1.empty()) { cout&lt;&lt;pq1.top()&lt;&lt;&quot; &quot;; pq1.pop(); }//40 30 20 10 //如果是priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt;pq1;则10 20 30 40 return 0;} 9. STL 常用算法下面基本上都需要 #include&lt;algorithm&gt; 头文件 (1)for_each 和 transform12345678910vector&lt;int&gt;v;for(int i=0;i&lt;10;i++){ v.push_back(i+1);}vector&lt;int&gt;vtarget;vtarget.resize(v.size());transform(v.begin(), v.end(), vtarget.begin(), Transform());for_each(vtarget.begin(), vtarget.end(), myprint());//101 102 103 104 105 106 107 108 109 110 v.begin(), v.end()：表示要转换的输入范围是 v 的起始到末尾。 vtarget.begin()：表示转换后的结果要放到 vtarget 中，从其开始位置存储。 Transform()：这是一个函数对象或仿函数，用于指定要对输入范围的每个元素执行的操作。假定的 Transform 类 Transform 需要是一个函数对象，类似于： 123456struct Transform {int operator()(int val) const { return val + 100; } }; 该类重载了 operator()，使得 Transform 类的对象能够像函数一样被调用。 在 transform 函数中，每次调用 Transform() 时，都会对输入的元素执行 val + 100 的操作。 因此，v 中的每个元素 1, 2, ..., 10 将被转换为 101, 102, ..., 110，并存储在 vtarget 中。 for_each 是 C++ 标准库中的另一个算法，用于对范围内的每个元素执行某个操作。 这行代码的参数： vtarget.begin(), vtarget.end()：表示对 vtarget 的所有元素执行操作。 myprint()：这是另一个函数对象，用于指定对每个元素要执行的操作。假定的 myprint 类 myprint 需要是一个函数对象，类似于： 123456struct myprint { void operator()(int val) const { cout &lt;&lt; val &lt;&lt; &quot; &quot;; }}; 该类重载了 operator()，使得 myprint 类的对象可以像函数一样被调用。 函数 说明 find 查找元素 find_if 按条件查找元素 adjacent_find 查找相邻重复元素 binary_search 二分查找法 count 统计元素个数 count_if 按条件统计元素个数 (2)find find 用于查找指定元素。 如果在指定的范围内找到了目标元素，它会返回指向该元素的迭代器。 如果找不到目标元素，则返回一个**结束迭代器 (end())**，表示目标元素不在该范围内。函数原型1iterator find(iterator beg, iterator end, const T&amp; value); iterator beg: 开始迭代器，表示查找范围的起点（包括 beg）。 iterator end: 结束迭代器，表示查找范围的终点（不包括 end 本身）。 value: 要查找的目标值，函数将在 [beg, end) 范围内寻找该值。1234567891011121314vector&lt;int&gt;v;for(int i=0;i&lt;10;i++){ v.push_back(i+1);}vector&lt;int&gt;::iterator it=find(v.begin(),v.end(),5);if(it==v.end()){ cout&lt;&lt;&quot;未找到&quot;&lt;&lt;endl;}else{ cout&lt;&lt;&quot;找到:&quot;&lt;&lt;*it&lt;&lt;endl;} (3)find_if功能描述:按条件查找元素函数原型: find_if(iterator beg, iterator end, _Pred); 按值查找元素,找到返回指定位置选代器,找不到返回结束选代器位置beg开始迭代器end结束迭代器_Pred 函数或者谓词(返回bool类型的仿函数) 12345678910111213141516171819class mycompare { public: bool operator()(int a) { return a &gt; 5; } }; void test01() { vector&lt;int&gt;v; for (int i = 0; i &lt; 10; i++) v.push_back(i + 1); vector&lt;int&gt;::iterator it = find_if(v.begin(), v.end(), mycompare()); if (it == v.end()) cout &lt;&lt; &quot;未找到&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;找到&quot; &lt;&lt; *it &lt;&lt; endl;//找到6 } (4)binary_search查找指定的元素，查到返回true，否则返回false注意：在无序序列中不可用,因为结果会出错降序也不行，只能用于升序序列 12345vector&lt;int&gt;v={0,1,2,3,4,5,6,7,8}; if (binary_search(v.begin(), v.end(), 6)) cout &lt;&lt; &quot;找到了&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;未找到&quot; &lt;&lt; endl; (5)adjacent_find查找相邻重复元素，返回相邻元素的第一个位置的迭代器 123456vector&lt;int&gt;v={0,2,0,3,1,4,3,3,2}; vector&lt;int&gt;::iterator pos = adjacent_find(v.begin(), v.end()); if (pos == v.end()) cout &lt;&lt; &quot;未找到&quot; &lt;&lt; endl; else cout &lt;&lt; *pos &lt;&lt; endl;//输出3 (6)count统计元素个数 123vector&lt;int&gt;v={0,1,2,3,5,3,3,6,8}; int cou = count(v.begin(), v.end(), 3); cout &lt;&lt; cou &lt;&lt; endl; (7)count_if1234567891011121314class greaterfive { public: bool operator()(int a) { return a &gt; 5; } }; void test01() { vector&lt;int&gt;v={0,1,2,7,5,6,3,6,8}; int cou = count_if(v.begin(), v.end(), greaterfive()); cout &lt;&lt; cou &lt;&lt; endl; //4} (8)sort 排序算法12345678910111213141516void myprint(int val) { cout &lt;&lt; val &lt;&lt; &quot; &quot;; } void test01() { vector&lt;int&gt;v={10,30,50,20,40,90}; for_each(v.begin(), v.end(), myprint); //10 30 50 20 40 90cout &lt;&lt; endl; sort(v.begin(), v.end()); for_each(v.begin(), v.end(), myprint); //10 20 30 40 50 90cout &lt;&lt; endl; sort(v.begin(), v.end(), greater&lt;int&gt;()); //greater&lt;int&gt;() 表示 &quot;大于&quot;，因此 sort 函数会将较大的元素排在前面，形成降序排列。for_each(v.begin(), v.end(), myprint); //90 50 40 30 20 10cout &lt;&lt; endl; } (9)random_shuffle123srand((unsigned int)time(NULL)); //设置随机数种子vector&lt;int&gt;v={0,1,2,3,4,5,6,7,8,9}; random_shuffle(v.begin(), v.end());//随机打乱v的排序 在 C++11 及更高版本中，推荐使用 std::shuffle 替代 random_shuffle 1234567891011#include &lt;algorithm&gt; // for std::shuffle#include &lt;random&gt; // for std::default_random_engineint main() { std::vector&lt;int&gt; v = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; std::random_device rd; // 用于获取随机种子 std::default_random_engine rng(rd()); // 随机数生成器 std::shuffle(v.begin(), v.end(), rng); return 0;} (10)merge可以把两个有序序列合在一起，形成一个新的有序序列 12345678910111213141516171819void myprint(int val) { cout &lt;&lt; val &lt;&lt; &quot; &quot;; } void test01() { vector&lt;int&gt;v1; vector&lt;int&gt;v2; for (int i = 0; i &lt; 10; i++) { v1.push_back(i); v2.push_back(i + 1); } vector&lt;int&gt;vTarget;//目标容器 vTarget.resize(v1.size() + v2.size()); merge(v1.begin(), v1.end(), v2.begin(), v2.end(), vTarget.begin()); for_each(vTarget.begin(), vTarget.end(), myprint); //0 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9 10cout &lt;&lt; endl; } (11)reverse逆序 12345678910111213void myprint(int val){ cout&lt;&lt;val&lt;&lt;endl;}void test(){ vector&lt;int&gt;v={10,30,40,50,20}; for_each(v.begin(),v.end(),myprint);//10 30 40 50 20 cout&lt;&lt;endl; reverse(v.begin(),v.end()); for_each(v.begin(),v.end(),myprint);//20 50 40 30 10 cout&lt;&lt;endl;} (12)copy将容器内指定范围的元素拷贝到另一容器中注意：新容器需要预留空间 12345678910111213void mypriny(int val){ cout&lt;&lt;val&lt;&lt;endl;}void test(){ vector&lt;int&gt;v={10,30,40,50,20}; vector&lt;int&gt;v2; v2.resize(v.size()); copy(v.begin(),v.end(),v2.begin()); for_each(v2.begin(),v2.end(),myprint);//10 30 40 50 20 cout&lt;&lt;endl;} (13)replace 和 replace_ifreplace将容器内指定范围的旧元素修改为新元素replace_if将区间内满足条件替换成指定元素 12345678910111213141516171819202122232425void myprint(int val) { cout &lt;&lt; val &lt;&lt; &quot; &quot;; } //compare是一个仿函数（函数对象）。通过重载 operator()，使得 compare 类的对象可以像函数一样被调用。class compare { public: bool operator()(int a) { return a &gt;= 40; } }; void test01() { vector&lt;int&gt;v={10,30,40,30,20,10,30,40,50,20}; for_each(v.begin(), v.end(), myprint); //10 30 40 30 20 10 30 40 50 20cout &lt;&lt; endl; replace(v.begin(), v.begin() + 4, 30, 300); //[v.begin(), v.begin() + 4)所有值为 30 的元素替换为 300for_each(v.begin(), v.end(), myprint); //10 300 40 300 20 10 30 40 50 20cout &lt;&lt; endl; replace_if(v.begin(), v.end(), compare(), 66); for_each(v.begin(), v.end(), myprint); //10 66 66 66 20 10 30 66 66 20cout &lt;&lt; endl; } (14)swap交换 123456vector&lt;int&gt;v={10,30,40,30,20,10,30,40,50,20}; vector&lt;int&gt;v1; for (int i = 0; i &lt; 10; i++) v1.push_back(i + 1);swap(v, v1); for_each(v.begin(), v.end(), myprint); cout &lt;&lt; endl; (15)accumulate 和 fill#include&lt;numeric&gt; accumulate计算容器元素累计总和fill向容器中添加元素 1234567891011121314151617181920212223void myprint(int val) { cout &lt;&lt; val &lt;&lt; &quot; &quot;; } void test01() { vector&lt;int&gt;v{10,30,40,30,20,10,30,40,50,20}; for_each(v.begin(), v.end(), myprint); cout &lt;&lt; endl; int total=accumulate(v.begin(), v.end(), 0); //第三个参数表示起始累加值，0表示最后结果加0 cout &lt;&lt; total &lt;&lt; endl; } void test02() { vector&lt;int&gt;v; v.resize(10); for_each(v.begin(), v.end(), myprint); cout &lt;&lt; endl; fill(v.begin(), v.end() - 2, 6); for_each(v.begin(), v.end(), myprint); cout &lt;&lt; endl; } 输出： 123410 30 40 30 20 10 30 40 50 20 2800 0 0 0 0 0 0 0 0 0 6 6 6 6 6 6 6 6 0 0 (16)交集，并集，差集set_intersection求两个容器的交集set_union并集set_difference差集 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt; // for set_intersection, set_union, set_differenceusing namespace std;void printVector(const vector&lt;int&gt;&amp; v) { for (int val : v) { cout &lt;&lt; val &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl;}int main() { // 两个有序的 vector 容器 vector&lt;int&gt; v1 = {1, 2, 3, 4, 5, 6}; vector&lt;int&gt; v2 = {4, 5, 6, 7, 8, 9}; vector&lt;int&gt; result; // 用于存储结果 // 求交集 result.resize(min(v1.size(), v2.size())); // 交集的最大可能大小为两个容器的最小值 auto it = set_intersection(v1.begin(), v1.end(), v2.begin(), v2.end(), result.begin()); result.resize(it - result.begin()); // 调整结果大小为实际交集元素的大小 cout &lt;&lt; &quot;Intersection of v1 and v2: &quot;; printVector(result); // 输出交集 // 求并集 result.clear(); result.resize(v1.size() + v2.size()); // 并集的最大可能大小为两个容器的和 it = set_union(v1.begin(), v1.end(), v2.begin(), v2.end(), result.begin()); result.resize(it - result.begin()); // 调整结果大小为实际并集元素的大小 cout &lt;&lt; &quot;Union of v1 and v2: &quot;; printVector(result); // 输出并集 // 求差集 v1 - v2 result.clear(); result.resize(v1.size()); // 差集的最大可能大小为第一个容器的大小 it = set_difference(v1.begin(), v1.end(), v2.begin(), v2.end(), result.begin()); result.resize(it - result.begin()); // 调整结果大小为实际差集元素的大小 cout &lt;&lt; &quot;Difference of v1 and v2 (v1 - v2): &quot;; printVector(result); // 输出差集 // 求差集 v2 - v1 result.clear(); result.resize(v2.size()); // 差集的最大可能大小为第二个容器的大小 it = set_difference(v2.begin(), v2.end(), v1.begin(), v1.end(), result.begin()); result.resize(it - result.begin()); // 调整结果大小为实际差集元素的大小 cout &lt;&lt; &quot;Difference of v2 and v1 (v2 - v1): &quot;; printVector(result); // 输出差集 return 0;} (17)next_premutation全排列 1234567891011121314vector&lt;int&gt;vec; for (int i = 0; i &lt; 3; i++) { vec.emplace_back(i + 1); //emplace_back(i + 1)是一个更有效的插入方式（类似于 push_back），用来在容器末尾直接构造元素。} for (auto k : vec) cout &lt;&lt; k &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; while (next_permutation(vec.begin(), vec.end())) { for (auto k : vec) cout &lt;&lt; k &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; } next_permutation 是 C++ &lt;algorithm&gt; 头文件中的一个函数，用于生成从当前排列组合的下一个字典序排列。 如果当前的排列组合已经是最大的排列组合，则 next_permutation 会返回 false，否则返回 true。 需要注意，next_permutation 只能在有序的容器上工作，因此 vec 必须按升序（或其他顺序）排列才能生成所有排列组合。输出：1234561 2 3 1 3 2 2 1 3 2 3 1 3 1 2 3 2 1 (18)lower_bound 和 upper_boundlower_bound( )和upper_bound( )都是利用二分查找的方法在一个排好序的数组中进行查找的。 在从小到大的排序数组中，lower_bound( begin,end,num)：从数组的begin位置到end-1位置二分查找第一个大于或等于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。 upper_bound( begin,end,num)：从数组的begin位置到end-1位置二分查找第一个大于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。 也可以用于vector容器，返回值是迭代器 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int cmd(int a, int b) { return a &gt; b;}int main() { int num[6] = { 1, 2, 4, 7, 15, 34 }; // 默认的排序是从小到大，因此这里其实是多余的操作 sort(num, num + 6); // 按从小到大排序 // 使用 lower_bound 查找第一个大于或等于 7 的位置 int pos1 = lower_bound(num, num + 6, 7) - num; // lower_bound 返回的迭代器减去 num 的起始地址，得到相应的位置索引。 cout &lt;&lt; pos1 &lt;&lt; &quot; &quot; &lt;&lt; num[pos1] &lt;&lt; endl; // 输出：3 7 // 使用 upper_bound 查找第一个大于 7 的位置 int pos2 = upper_bound(num, num + 6, 7) - num; cout &lt;&lt; pos2 &lt;&lt; &quot; &quot; &lt;&lt; num[pos2] &lt;&lt; endl; // 输出：4 15 // 按从大到小排序 sort(num, num + 6, cmd); // cmd 定义为从大到小排序 // 使用 lower_bound 查找第一个小于或等于 7 的位置 int pos3 = lower_bound(num, num + 6, 7, greater&lt;int&gt;()) - num; cout &lt;&lt; pos3 &lt;&lt; &quot; &quot; &lt;&lt; num[pos3] &lt;&lt; endl; // 输出：2 7 // 使用 upper_bound 查找第一个小于 7 的位置 int pos4 = upper_bound(num, num + 6, 7, greater&lt;int&gt;()) - num; cout &lt;&lt; pos4 &lt;&lt; &quot; &quot; &lt;&lt; num[pos4] &lt;&lt; endl; // 输出：3 4 return 0;}","link":"/2024/10/03/STL/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2023/12/13/hello-world/"},{"title":"docker","text":"Docker Training Course for the Absolute Beginner Course | KodeKloud 1Docker Basic Commands | KodeKloudDelete all containers from the Docker Host. 1docker rm -f $(docker ps -aq) Delete the ubuntu Image. 1docker rmi ubuntu You are required to pull a docker image which will be used to run a container later. Pull the image nginx:1.14-alpine 1docker pull nginx:1.14-alpine Run a container with the nginx:1.14-alpine image and name it webapp 1docker run -d --name webapp nginx:1.14-alpine docker run: Command to create and start a new container. -d: Runs the container in detached mode (in the background). --name webapp: Assigns the name webapp to the container. nginx:1.14-alpine: Specifies the image and tag to use for the container.Cleanup: Delete all images on the host1docker rmi -f $(docker images -aq) In Docker commands, -aq is a combination of options that can be used with certain Docker commands like docker ps and docker images. Here’s what each option means: -a: This stands for “all.” It lists all items, not just the default filtered view. For example: With docker ps -a, it lists all containers (both running and stopped). With docker images -a, it lists all images, including intermediate images used in builds. -q: This stands for “quiet” mode. It only outputs the IDs, rather than the full details. With docker ps -q, it lists only the container IDs. With docker images -q, it lists only the image IDs.When combined as -aq: docker ps -aq: Lists only the IDs of all containers. docker images -aq: Lists only the IDs of all images. 2","link":"/2024/10/28/docker/"},{"title":"docker学习笔记","text":"小白的docker学习全过程 参考文献 黑马程序员Docker快速入门到项目部署，MySQL部署+Nginx部署+docker自定义镜像+DockerCompose项目实战一套搞定_哔哩哔哩_bilibili Ubuntu · Docker – 从入门到实践 (docker-practice.github.io) Docker 教程 | 菜鸟教程 (runoob.com) 介绍 开源的应用容器引擎，基于 GO 语言 可以让开发者打包应用以及依赖报到一个轻量级可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。 概念 镜像 image ，相当于一个 root 文件系统 容器 container ,镜像是静态的定义，容器是镜像运行时的实体，容器可以被创建，启动，停止，删除，暂停等等。 仓库 respository，一个代码控制中心，用来保存镜像,目前 Docker 官方维护了一个公共仓库 Docker Hub。大部分需求都可以通过在 Docker Hub 中直接下载镜像来实现。 Dockerfile ,一个文本文件，包含了构建 Docker 镜像的所有指令。Docker Dockerfile | 菜鸟教程 (runoob.com) Docker Compose, Compose 是用于定义和运行多容器 Docker 应用程序的工具。通过Compose，可以使用 YML 文件来配置应用程序需要的所有服务。然后，使用一个命令，就可以从 YML 文件配置中创建并启动所有服务。Docker Compose | 菜鸟教程 (runoob.com) Swarm 集群管理，Swarm 集群管理 | 菜鸟教程 (runoob.com) 准备1234567891011121314151617181920212223242526272829PS C:\\Users\\zhuyu&gt; wsl --list --verbose NAME STATE VERSION* Ubuntu Running 2PS C:\\Users\\zhuyu&gt; wslWelcome to fish, the friendly interactive shellType help for instructions on how to use fishzyh@QAQ /m/c/U/zhuyu&gt; neofetch .-/+oossssoo+/-. zyh@QAQ `:+ssssssssssssssssss+:` ------- -+ssssssssssssssssssyyssss+- OS: Ubuntu 22.04.3 LTS on Windows 10 x86_64 .ossssssssssssssssssdMMMNysssso. Kernel: 5.15.153.1-microsoft-standard-WSL2 /ssssssssssshdmmNNmmyNMMMMhssssss/ Uptime: 5 mins +ssssssssshmydMMMMMMMNddddyssssssss+ Packages: 521 (dpkg), 6 (snap) /sssssssshNMMMyhhyyyyhmNMMMNhssssssss/ Shell: fish 3.3.1.ssssssssdMMMNhsssssssssshNMMMdssssssss. Terminal: Windows Terminal+sssshhhyNMMNyssssssssssssyNMMMysssssss+ CPU: 11th Gen Intel i5-1135G7 (8) @ 2.419GHzossyNMMMNyMMhsssssssssssssshmmmhssssssso GPU: 613e:00:00.0 Microsoft Corporation Device 008eossyNMMMNyMMhsssssssssssssshmmmhssssssso Memory: 525MiB / 7808MiB+sssshhhyNMMNyssssssssssssyNMMMysssssss+.ssssssssdMMMNhsssssssssshNMMMdssssssss. /sssssssshNMMMyhhyyyyhdNMMMNhssssssss/ +sssssssssdmydMMMMMMMMddddyssssssss+ /ssssssssssshdmNNNNmyNMMMMhssssss/ .ossssssssssssssssssdMMMNysssso. -+sssssssssssssssssyyyssss+- `:+ssssssssssssssssss+:` .-/+oossssoo+/-.zyh@QAQ /m/c/U/zhuyu&gt; 解释检查 WSL 安装状态：wsl --list --verbose进入 WSL：wsl展示系统信息： neofetch 是一个命令行工具，用于显示系统信息和操作系统的 ASCII 艺术图案。 安装我按照这个教程来的：Ubuntu · Docker – 从入门到实践 (docker-practice.github.io) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239Welcome to fish, the friendly interactive shellType help for instructions on how to use fishzyh@QAQ ~&gt; $ sudo apt-get updatefish: Expected a variable name after this $.zyh@QAQ ~&gt; $ sudo apt-get updatefish: Expected a variable name after this $.zyh@QAQ ~&gt; sudo apt-get update[sudo] password for zyh:Hit:1 http://mirrors.matrix.moe/ubuntu jammy InReleaseGet:2 http://mirrors.matrix.moe/ubuntu jammy-updates InRelease [128 kB]Get:3 http://mirrors.matrix.moe/ubuntu jammy-backports InRelease [127 kB]Get:4 http://mirrors.matrix.moe/ubuntu jammy-security InRelease [129 kB]Get:5 http://mirrors.matrix.moe/ubuntu jammy-updates/main amd64 Packages [2058 kB]Get:6 http://mirrors.matrix.moe/ubuntu jammy-updates/main Translation-en [355 kB]Get:7 http://mirrors.matrix.moe/ubuntu jammy-updates/main amd64 c-n-f Metadata [17.8 kB]Get:8 http://mirrors.matrix.moe/ubuntu jammy-updates/restricted amd64 Packages [2495 kB]Get:9 http://mirrors.matrix.moe/ubuntu jammy-updates/restricted Translation-en [429 kB]Get:10 http://mirrors.matrix.moe/ubuntu jammy-updates/universe amd64 Packages [1124 kB]Get:11 http://mirrors.matrix.moe/ubuntu jammy-updates/universe Translation-en [261 kB]Get:12 http://mirrors.matrix.moe/ubuntu jammy-updates/universe amd64 c-n-f Metadata [26.1 kB]Get:13 http://mirrors.matrix.moe/ubuntu jammy-backports/universe amd64 Packages [28.8 kB]Get:14 http://mirrors.matrix.moe/ubuntu jammy-backports/universe amd64 c-n-f Metadata [672 B]Get:15 http://mirrors.matrix.moe/ubuntu jammy-security/main amd64 Packages [1839 kB]Get:16 http://mirrors.matrix.moe/ubuntu jammy-security/main Translation-en [298 kB]Get:17 http://mirrors.matrix.moe/ubuntu jammy-security/main amd64 c-n-f Metadata [13.3 kB]Get:18 http://mirrors.matrix.moe/ubuntu jammy-security/restricted amd64 Packages [2431 kB]Get:19 http://mirrors.matrix.moe/ubuntu jammy-security/restricted Translation-en [418 kB]Get:20 http://mirrors.matrix.moe/ubuntu jammy-security/universe amd64 Packages [903 kB]Get:21 http://mirrors.matrix.moe/ubuntu jammy-security/universe Translation-en [177 kB]Get:22 http://mirrors.matrix.moe/ubuntu jammy-security/universe amd64 c-n-f Metadata [19.3 kB]Fetched 13.3 MB in 5s (2688 kB/s)Reading package lists... Donezyh@QAQ ~&gt; sudo apt-get install \\ apt-transport-https \\ ca-certificates \\ curl \\ gnupg \\ lsb-releaseReading package lists... DoneBuilding dependency tree... DoneReading state information... Donelsb-release is already the newest version (11.1.0ubuntu4).lsb-release set to manually installed.ca-certificates is already the newest version (20230311ubuntu0.22.04.1).ca-certificates set to manually installed.gnupg is already the newest version (2.2.27-3ubuntu2.1).gnupg set to manually installed.The following additional packages will be installed: libcurl4The following NEW packages will be installed: apt-transport-httpsThe following packages will be upgraded: curl libcurl42 upgraded, 1 newly installed, 0 to remove and 144 not upgraded.Need to get 485 kB of archives.After this operation, 172 kB of additional disk space will be used.Do you want to continue? [Y/n] yGet:1 http://mirrors.matrix.moe/ubuntu jammy-updates/universe amd64 apt-transport-https all 2.4.13 [1510 B]Get:2 http://mirrors.matrix.moe/ubuntu jammy-updates/main amd64 curl amd64 7.81.0-1ubuntu1.18 [194 kB]Get:3 http://mirrors.matrix.moe/ubuntu jammy-updates/main amd64 libcurl4 amd64 7.81.0-1ubuntu1.18 [289 kB]Fetched 485 kB in 0s (1154 kB/s)Selecting previously unselected package apt-transport-https.(Reading database ... 28748 files and directories currently installed.)Preparing to unpack .../apt-transport-https_2.4.13_all.deb ...Unpacking apt-transport-https (2.4.13) ...Preparing to unpack .../curl_7.81.0-1ubuntu1.18_amd64.deb ...Unpacking curl (7.81.0-1ubuntu1.18) over (7.81.0-1ubuntu1.14) ...Preparing to unpack .../libcurl4_7.81.0-1ubuntu1.18_amd64.deb ...Unpacking libcurl4:amd64 (7.81.0-1ubuntu1.18) over (7.81.0-1ubuntu1.14) ...Setting up apt-transport-https (2.4.13) ...Setting up libcurl4:amd64 (7.81.0-1ubuntu1.18) ...Setting up curl (7.81.0-1ubuntu1.18) ...Processing triggers for man-db (2.10.2-1) ...Processing triggers for libc-bin (2.35-0ubuntu3.4) ...zyh@QAQ ~&gt; curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpgzyh@QAQ ~&gt; echo \\ &quot;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://mirrors.aliyun.com/docker-ce/linux/ubuntu \\ $(lsb_release -cs) stable&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/nullfish: $(...) is not supported. In fish, please use '(lsb_release)'. $(lsb_release -cs) stable&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null^zyh@QAQ ~&gt; echo \\ &quot;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://mirrors.aliyun.com/docker-ce/linux/ubuntu \\ $(lsb_release -cs) stable&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/nullfish: $(...) is not supported. In fish, please use '(lsb_release)'. $(lsb_release -cs) stable&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null^zyh@QAQ ~&gt; echo \\ &quot;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://mirrors.aliyun.com/docker-ce/linux/ubuntu \\ $(lsb_release -cs) stable&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null echo \\ &quot;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://mirrors.aliyun.com/docker-ce/linux/ubuntu \\ (lsb_release -cs) stable&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/nullfish: $(...) is not supported. In fish, please use '(lsb_release)'. $(lsb_release -cs) stable&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null^zyh@QAQ ~&gt; echo \\ &quot;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://mirrors.aliyun.com/docker-ce/linux/ubuntu \\ $(lsb_release -cs) stable&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null echo \\ &quot;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://mirrors.aliyun.com/docker-ce/linux/ubuntu \\ (lsb_release -cs) stable&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null ^Czyh@QAQ ~&gt; echo \\ &quot;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://mirrors.aliyun.com/docker-ce/linux/ubuntu \\ (lsb_release -cs) stable&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/nullzyh@QAQ ~&gt; sudo apt-get updateHit:1 http://mirrors.matrix.moe/ubuntu jammy InReleaseHit:2 http://mirrors.matrix.moe/ubuntu jammy-updates InReleaseHit:3 http://mirrors.matrix.moe/ubuntu jammy-backports InReleaseHit:4 http://mirrors.matrix.moe/ubuntu jammy-security InReleaseIgn:5 https://mirrors.aliyun.com/docker-ce/linux/ubuntu (lsb_release InReleaseErr:6 https://mirrors.aliyun.com/docker-ce/linux/ubuntu (lsb_release Release 404 Not Found [IP: 36.250.255.105 443]Reading package lists... DoneE: The repository 'https://mirrors.aliyun.com/docker-ce/linux/ubuntu (lsb_release Release' does not have a Release file.N: Updating from such a repository can't be done securely, and is therefore disabled by default.N: See apt-secure(8) manpage for repository creation and user configuration details.zyh@QAQ ~ [100]&gt; lsb_release -csjammyzyh@QAQ ~&gt; deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://mirrors.aliyun.com/docker-ce/linux/ubuntu jammy stableCommand 'deb' not found, did you mean: command 'dub' from snap dub (1.19.0) command 'den' from snap den (1.2.0-0) command 'dub' from deb dub (1.27.0-2) command 'dcb' from deb iproute2 (5.15.0-1ubuntu2) command 'dab' from deb bsdgames (2.17-29) command 'dex' from deb dex (0.9.0-1) command 'debc' from deb devscripts (2.22.1ubuntu1) command 'edb' from deb edb-debugger (1.3.0-1) command 'deb3' from deb quilt (0.66-2.1) command 'debi' from deb devscripts (2.22.1ubuntu1) command 'derb' from deb icu-devtools (70.1-2)See 'snap info &lt;snapname&gt;' for additional versions.zyh@QAQ ~ [127]&gt; echo &quot;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://mirrors.aliyun.com/docker-ce/linux/ubuntu jammy stable&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/nullzyh@QAQ ~&gt; sudo apt-get updateHit:1 http://mirrors.matrix.moe/ubuntu jammy InReleaseHit:2 http://mirrors.matrix.moe/ubuntu jammy-updates InReleaseHit:3 http://mirrors.matrix.moe/ubuntu jammy-backports InReleaseHit:4 http://mirrors.matrix.moe/ubuntu jammy-security InReleaseGet:5 https://mirrors.aliyun.com/docker-ce/linux/ubuntu jammy InRelease [48.8 kB]Get:6 https://mirrors.aliyun.com/docker-ce/linux/ubuntu jammy/stable amd64 Packages [39.3 kB]Fetched 88.2 kB in 1s (122 kB/s)Reading package lists... Donezyh@QAQ ~&gt; sudo apt-get install docker-ce docker-ce-cli containerd.io docker-compose-pluginReading package lists... DoneBuilding dependency tree... DoneReading state information... DoneThe following additional packages will be installed: dbus-user-session docker-buildx-plugin docker-ce-rootless-extras libslirp0 pigz slirp4netnsSuggested packages: aufs-tools cgroupfs-mount | cgroup-liteThe following NEW packages will be installed: containerd.io dbus-user-session docker-buildx-plugin docker-ce docker-ce-cli docker-ce-rootless-extras docker-compose-plugin libslirp0 pigz slirp4netns0 upgraded, 10 newly installed, 0 to remove and 144 not upgraded.Need to get 122 MB of archives.After this operation, 440 MB of additional disk space will be used.Do you want to continue? [Y/n] yGet:1 https://mirrors.aliyun.com/docker-ce/linux/ubuntu jammy/stable amd64 containerd.io amd64 1.7.22-1 [29.5 MB]Get:2 http://mirrors.matrix.moe/ubuntu jammy/universe amd64 pigz amd64 2.6-1 [63.6 kB]Get:3 http://mirrors.matrix.moe/ubuntu jammy-updates/main amd64 dbus-user-session amd64 1.12.20-2ubuntu4.1 [9442 B]Get:4 http://mirrors.matrix.moe/ubuntu jammy/main amd64 libslirp0 amd64 4.6.1-1build1 [61.5 kB]Get:5 http://mirrors.matrix.moe/ubuntu jammy/universe amd64 slirp4netns amd64 1.0.1-2 [28.2 kB]Get:6 https://mirrors.aliyun.com/docker-ce/linux/ubuntu jammy/stable amd64 docker-buildx-plugin amd64 0.16.2-1~ubuntu.22.04~jammy [29.9 MB]Get:7 https://mirrors.aliyun.com/docker-ce/linux/ubuntu jammy/stable amd64 docker-ce-cli amd64 5:27.2.1-1~ubuntu.22.04~jammy [15.0 MB]Get:8 https://mirrors.aliyun.com/docker-ce/linux/ubuntu jammy/stable amd64 docker-ce amd64 5:27.2.1-1~ubuntu.22.04~jammy [25.6 MB]Get:9 https://mirrors.aliyun.com/docker-ce/linux/ubuntu jammy/stable amd64 docker-ce-rootless-extras amd64 5:27.2.1-1~ubuntu.22.04~jammy [9572 kB]Get:10 https://mirrors.aliyun.com/docker-ce/linux/ubuntu jammy/stable amd64 docker-compose-plugin amd64 2.29.2-1~ubuntu.22.04~jammy [12.5 MB]Fetched 122 MB in 1min 7s (1832 kB/s)Selecting previously unselected package pigz.(Reading database ... 28752 files and directories currently installed.)Preparing to unpack .../0-pigz_2.6-1_amd64.deb ...Unpacking pigz (2.6-1) ...Selecting previously unselected package containerd.io.Preparing to unpack .../1-containerd.io_1.7.22-1_amd64.deb ...Unpacking containerd.io (1.7.22-1) ...Selecting previously unselected package dbus-user-session.Preparing to unpack .../2-dbus-user-session_1.12.20-2ubuntu4.1_amd64.deb ...Unpacking dbus-user-session (1.12.20-2ubuntu4.1) ...Selecting previously unselected package docker-buildx-plugin.Preparing to unpack .../3-docker-buildx-plugin_0.16.2-1~ubuntu.22.04~jammy_amd64.deb ...Unpacking docker-buildx-plugin (0.16.2-1~ubuntu.22.04~jammy) ...Selecting previously unselected package docker-ce-cli.Preparing to unpack .../4-docker-ce-cli_5%3a27.2.1-1~ubuntu.22.04~jammy_amd64.deb ...Unpacking docker-ce-cli (5:27.2.1-1~ubuntu.22.04~jammy) ...Selecting previously unselected package docker-ce.Preparing to unpack .../5-docker-ce_5%3a27.2.1-1~ubuntu.22.04~jammy_amd64.deb ...Unpacking docker-ce (5:27.2.1-1~ubuntu.22.04~jammy) ...Selecting previously unselected package docker-ce-rootless-extras.Preparing to unpack .../6-docker-ce-rootless-extras_5%3a27.2.1-1~ubuntu.22.04~jammy_amd64.deb ...Unpacking docker-ce-rootless-extras (5:27.2.1-1~ubuntu.22.04~jammy) ...Selecting previously unselected package docker-compose-plugin.Preparing to unpack .../7-docker-compose-plugin_2.29.2-1~ubuntu.22.04~jammy_amd64.deb ...Unpacking docker-compose-plugin (2.29.2-1~ubuntu.22.04~jammy) ...Selecting previously unselected package libslirp0:amd64.Preparing to unpack .../8-libslirp0_4.6.1-1build1_amd64.deb ...Unpacking libslirp0:amd64 (4.6.1-1build1) ...Selecting previously unselected package slirp4netns.Preparing to unpack .../9-slirp4netns_1.0.1-2_amd64.deb ...Unpacking slirp4netns (1.0.1-2) ...Setting up dbus-user-session (1.12.20-2ubuntu4.1) ...Setting up docker-buildx-plugin (0.16.2-1~ubuntu.22.04~jammy) ...Setting up containerd.io (1.7.22-1) ...Created symlink /etc/systemd/system/multi-user.target.wants/containerd.service → /lib/systemd/system/containerd.service.Setting up docker-compose-plugin (2.29.2-1~ubuntu.22.04~jammy) ...Setting up docker-ce-cli (5:27.2.1-1~ubuntu.22.04~jammy) ...Setting up libslirp0:amd64 (4.6.1-1build1) ...Setting up pigz (2.6-1) ...Setting up docker-ce-rootless-extras (5:27.2.1-1~ubuntu.22.04~jammy) ...Setting up slirp4netns (1.0.1-2) ...Setting up docker-ce (5:27.2.1-1~ubuntu.22.04~jammy) ...Created symlink /etc/systemd/system/multi-user.target.wants/docker.service → /lib/systemd/system/docker.service.Created symlink /etc/systemd/system/sockets.target.wants/docker.socket → /lib/systemd/system/docker.socket.Processing triggers for man-db (2.10.2-1) ...Processing triggers for libc-bin (2.35-0ubuntu3.4) ...zyh@QAQ ~&gt; sudo systemctl enable dockerSynchronizing state of docker.service with SysV service script with /lib/systemd/systemd-sysv-install.Executing: /lib/systemd/systemd-sysv-install enable dockerzyh@QAQ ~&gt; sudo systemctl start dockerzyh@QAQ ~&gt; sudo groupadd dockergroupadd: group 'docker' already existszyh@QAQ ~ [9]&gt; docker run --rm hello-worlddocker: permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock: Head &quot;http://%2Fvar%2Frun%2Fdocker.sock/_ping&quot;: dial unix /var/run/docker.sock: connect: permission denied.See 'docker run --help'.zyh@QAQ ~ [126]&gt; 解决 Unable to find image 'hello-world:latest' locally 的问题。 1234567891011121314151617181920212223242526272829303132333435363738394041Welcome to fish, the friendly interactive shellType help for instructions on how to use fishzyh@QAQ ~&gt; docker run --rm hello-worldUnable to find image 'hello-world:latest' locallydocker: Error response from daemon: Get &quot;https://registry-1.docker.io/v2/&quot;: context deadline exceeded (Client.Timeout exceeded while awaiting headers).See 'docker run --help'.zyh@QAQ ~ [125]&gt; sudo vim /etc/docker/daemon.json[sudo] password for zyh:zyh@QAQ ~&gt; sudo systemctl daemon-reloadzyh@QAQ ~&gt; sudo systemctl restart dockerzyh@QAQ ~&gt; docker run --rm hello-worldUnable to find image 'hello-world:latest' locallylatest: Pulling from library/hello-worldc1ec31eb5944: Pull completeDigest: sha256:91fb4b041da273d5a3273b6d587d62d518300a6ad268b28628f74997b93171b2Status: Downloaded newer image for hello-world:latestHello from Docker!This message shows that your installation appears to be working correctly.To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub. (amd64) 3. The Docker daemon created a new container from that image which runs the executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it to your terminal.To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bashShare images, automate workflows, and more with a free Docker ID: https://hub.docker.com/For more examples and ideas, visit: https://docs.docker.com/get-started/zyh@QAQ ~&gt; 使用 daocloud 镜像加速： 123456{ &quot;registry-mirrors&quot;: [ &quot;https://docker.m.daocloud.io&quot; ]} `` 使用 查看 docker 版本1docker --version 启动 docker 服务1sudo systemctl start docker 检查 docker 服务状态1sudo systemctl status docker 运行第一个容器1docker run hello-world 或者1docker run --rm hello-world 拉取镜像1docker pull nginx ps: nginx 是一个高性能的 HTTP 和反向代理 web 服务器 列出 docker 镜像1docker images 运行容器1docker run -d -p 8080:80 nginx 会将 nginx 容器的端口 80 投射到宿主机的 8080 端口，可以通过 https://localhost:8080 访问 Nginx 服务。 列出所有容器1docker ps 1docker ps -a 启动容器1docker start XX 停止容器1docker stop XX 删除容器1docker rm XX 删除本地镜像1docker rmi XX 查看容器日志1docker logs XX 进入容器内部1docker exec -it XX /bin/sh docker compose运行以下命令以下载 Docker Compose 的当前稳定版本：将可执行权限应用于二进制文件：创建软链：测试是否安装成功： 1234567891011121314zyh@QAQ ~ [3]&gt; set os (uname -s) set arch (uname -m) sudo curl -L &quot;https://github.com/docker/compose/releases/download/v2.2.2/docker-compose-$os-$arch&quot; -o /usr/local/bin/docker-compose % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed 0 0 0 0 0 0 0 0 --:--:-- 0:00:01 --:--:-- 0100 23.5M 100 23.5M 0 0 55309 0 0:07:25 0:07:25 --:--:-- 47077zyh@QAQ ~&gt; sudo chmod +x /usr/local/bin/docker-compose[sudo] password for zyh:zyh@QAQ ~&gt; sudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-composezyh@QAQ ~&gt; docker-compose --versionDocker Compose version v2.2.2 测试：使用一个简单的 docker-compose.yml 文件来运行一个 Nginx 容器。测试步骤： 创建一个测试文件夹，并进入该文件夹： 12mkdir dockercomposetestcd dockercomposetest 创建一个 docker-compose.yml 文件： 1nano docker-compose.yml 在文件中粘贴以下内容： 123456version: '3'services: web: image: nginx:alpine ports: - &quot;8080:80&quot; 这个文件会使用 nginx:alpine 镜像，并将本地的 8080 端口映射到容器的 80 端口。 运行 Docker Compose： 1sudo docker-compose up 如果 Docker Compose 正常工作，看到下面的输出，表明 Nginx 容器启动成功： 12345678910111213141516171819202122232425262728293031323334353637383940zyh@QAQ ~/dockercomposetest&gt; sudo docker-compose up[+] Running 9/9 ⠿ web Pulled 30.8s ⠿ 43c4264eed91 Pull complete 2.4s ⠿ 5b19511a843d Pull complete 2.6s ⠿ 652d69a25e85 Pull complete 2.6s ⠿ 51676974aef5 Pull complete 2.7s ⠿ bb16f69e8876 Pull complete 2.7s ⠿ 6fb07faa0055 Pull complete 2.7s ⠿ c298c5a0cd21 Pull complete 4.8s ⠿ 0c02f601d0ee Pull complete 12.0s[+] Running 2/2 ⠿ Network dockercomposetest_default Created 0.2s ⠿ Container dockercomposetest-web-1 Created 0.2sAttaching to dockercomposetest-web-1dockercomposetest-web-1 | /docker-entrypoint.sh: /docker-entrypoint.d/ is not empty, will attempt to perform configurationdockercomposetest-web-1 | /docker-entrypoint.sh: Looking for shell scripts in /docker-entrypoint.d/dockercomposetest-web-1 | /docker-entrypoint.sh: Launching /docker-entrypoint.d/10-listen-on-ipv6-by-default.shdockercomposetest-web-1 | 10-listen-on-ipv6-by-default.sh: info: Getting the checksum of /etc/nginx/conf.d/default.confdockercomposetest-web-1 | 10-listen-on-ipv6-by-default.sh: info: Enabled listen on IPv6 in /etc/nginx/conf.d/default.confdockercomposetest-web-1 | /docker-entrypoint.sh: Sourcing /docker-entrypoint.d/15-local-resolvers.envshdockercomposetest-web-1 | /docker-entrypoint.sh: Launching /docker-entrypoint.d/20-envsubst-on-templates.shdockercomposetest-web-1 | /docker-entrypoint.sh: Launching /docker-entrypoint.d/30-tune-worker-processes.shdockercomposetest-web-1 | /docker-entrypoint.sh: Configuration complete; ready for start updockercomposetest-web-1 | 2024/09/24 16:43:16 [notice] 1#1: using the &quot;epoll&quot; event methoddockercomposetest-web-1 | 2024/09/24 16:43:16 [notice] 1#1: nginx/1.27.1dockercomposetest-web-1 | 2024/09/24 16:43:16 [notice] 1#1: built by gcc 13.2.1 20240309 (Alpine 13.2.1_git20240309)dockercomposetest-web-1 | 2024/09/24 16:43:16 [notice] 1#1: OS: Linux 5.15.153.1-microsoft-standard-WSL2dockercomposetest-web-1 | 2024/09/24 16:43:16 [notice] 1#1: getrlimit(RLIMIT_NOFILE): 1048576:1048576dockercomposetest-web-1 | 2024/09/24 16:43:16 [notice] 1#1: start worker processesdockercomposetest-web-1 | 2024/09/24 16:43:16 [notice] 1#1: start worker process 30dockercomposetest-web-1 | 2024/09/24 16:43:16 [notice] 1#1: start worker process 31dockercomposetest-web-1 | 2024/09/24 16:43:16 [notice] 1#1: start worker process 32dockercomposetest-web-1 | 2024/09/24 16:43:16 [notice] 1#1: start worker process 33dockercomposetest-web-1 | 2024/09/24 16:43:16 [notice] 1#1: start worker process 34dockercomposetest-web-1 | 2024/09/24 16:43:16 [notice] 1#1: start worker process 35dockercomposetest-web-1 | 2024/09/24 16:43:16 [notice] 1#1: start worker process 36dockercomposetest-web-1 | 2024/09/24 16:43:16 [notice] 1#1: start worker process 37dockercomposetest-web-1 | 172.19.0.1 - - [24/Sep/2024:16:43:39 +0000] &quot;GET / HTTP/1.1&quot; 200 615 &quot;-&quot; &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/129.0.0.0 Safari/537.36 Edg/129.0.0.0&quot; &quot;-&quot; 打开浏览器并访问 http://localhost:8080，看到 Nginx 的欢迎页面，表明 Docker Compose 运行成功。 停止容器，按 Ctrl+C，然后运行以下命令来清理环境： 1sudo docker-compose down 实战这里以我的项目 project: 基于Springboot+Vue的亚健康管理系统 (gitee.com) 为例，将这个 web 项目部署到 docker 中运行。通过Docker容器化的方式，不需要在本地（Windows或WSL）安装Node.js、MySQL、Java等开发依赖，这些依赖项完全可以由Docker来管理。Docker容器会为每个服务提供一个独立的运行环境，本地机器不需要直接安装这些服务。只需要安装Docker和Docker Compose工具，剩下的依赖都在Docker中管理。通过Git和Docker Compose，团队成员可以轻松启动、重建和管理开发环境，简化协作流程。 项目调研关键信息将一个包含 Vue、Spring Boot 和 MySQL 的项目部署到 Docker 中的过程涉及构建多个 Docker 容器来分别运行前端、后端和数据库。需要考虑以下关键信息： Vue 项目的打包配置： Vue 项目是否已经通过 npm run build 或者 yarn build 进行生产环境打包？ 是否有 Dockerfile 或现成的部署脚本？ Spring Boot 应用的构建方式： Spring Boot 项目是否使用 Maven 或 Gradle 进行构建？ 是否已生成了 .jar 文件，或者是否有 Dockerfile 来构建 Spring Boot 容器？ MySQL 配置： MySQL 数据库的版本？ 数据库的初始化脚本（如有的话）？ MySQL 的数据库配置，是否需要挂载外部数据卷保存数据？ 应用的连接配置： Vue 前端如何连接到 Spring Boot 后端？（例如，API 地址在开发时是否通过代理，或者已经设置为生产环境的 URL） Spring Boot 如何连接 MySQL？是否有外部配置（如 application.properties 或 application.yml 中的数据库连接设置）？ 其他配置： 是否有任何环境变量，配置文件或 secrets 需要传递给容器？ 是否需要使用 Docker Compose 来管理多个容器（例如前端、后端、数据库）？ 实际情况 ： vue项目还没打包，没有dockerfile 2.springboot采用maven构建，没有.jar文件，没有dockerfile 其中pom.xml为：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;3.2.5&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;demo&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;17&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!--SpringMvc--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--mybatis--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.0.3&lt;/version&gt; &lt;/dependency&gt; &lt;!--MySQL--&gt; &lt;dependency&gt; &lt;groupId&gt;com.mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-j&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;!--lombok--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter-test&lt;/artifactId&gt; &lt;version&gt;3.0.3&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-spring-boot3-starter&lt;/artifactId&gt; &lt;version&gt;3.5.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;/groupId&gt; &lt;artifactId&gt;hutool-all&lt;/artifactId&gt; &lt;version&gt;5.8.25&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;excludes&gt; &lt;exclude&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/exclude&gt; &lt;/excludes&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/project&gt; 我不知道mysql的版本；MySQL 的数据库配置需要挂载外部数据卷保存数据 vue前端和springboot后端通过跨域配置进行连接 ,vue.config.js内容为: 1234567891011121314151617181920212223242526272829 // 跨域配置module.exports = { devServer: { //记住，别写错了devServer//设置本地默认端口 选填 //port: 9876, proxy: { //设置代理，必须填 '/api': { //设置拦截器 拦截器格式 斜杠+拦截器名字，名字可以自己定 target: 'http://localhost:9091', //代理的目标地址 changeOrigin: true, //是否设置同源，输入是的 pathRewrite: { //路径重写 '^/api': '' //选择忽略拦截器里面的内容 } } } }} 没有环境变量，配置文件或 secrets 需要传递给容器需要使用 Docker Compose 来管理多个容器，即前端、后端、数据库 大致的部署流程 为 Vue 应用创建 Dockerfile：该 Dockerfile 用于将 Vue 应用打包为静态文件并部署到 Nginx 或其他 web 服务器中。 为 Spring Boot 应用创建 Dockerfile：这个 Dockerfile 将包含 Java 环境和 Spring Boot .jar 文件。 使用 Docker Compose 配置文件：编写 docker-compose.yml 文件，用于启动 Vue 前端、Spring Boot 后端和 MySQL 数据库的三个服务。 方案注意：下面有两种方案，我采取的是方案二 方案一：使用Docker Desktop的WSL集成Docker Desktop，启用WSL 2 集成，这样Docker Desktop会将WSL与Windows的Docker环境整合在一起。 打开Docker Desktop，在设置中启用 WSL 2 integration，并选择你使用的WSL发行版（如Ubuntu）。 在Windows PowerShell或WSL中运行Docker：在Windows的PowerShell中：1cd D:\\Desktop\\project docker-compose up --build 在WSL中：1cd /mnt/d/Desktop/project docker-compose up --build 优点：这种方式将WSL与Windows Docker紧密结合，无论你是在Windows还是WSL中操作Docker，都可以使用相同的Docker环境。 方案二：将项目目录映射到WSL中的文件系统如果你想继续使用WSL中的Docker，而不能直接在WSL中访问Windows文件系统，那么可以通过以下方法解决： 挂载Windows的文件系统到WSL： 在WSL中，Windows的文件系统已经挂载在/mnt/目录下。例如，C:\\盘的文件可以在WSL中通过/mnt/c/访问。 在WSL中访问Windows上的项目： 你可以在WSL中通过/mnt/目录访问Windows的文件。例如，如果你的项目在D:\\Desktop\\project下，你可以在WSL中访问它：1cd /mnt/d/Desktop/project 在WSL中运行Docker命令： 进入项目目录后，你可以在WSL的fish shell中运行Docker命令：1docker-compose up --build 优点： 这种方式允许你使用WSL中的Docker，但仍然能够访问Windows文件系统，避免了项目文件复制的麻烦。 方案三：将项目文件复制到WSL的文件系统中如果你希望项目文件完全在WSL的Linux文件系统中，你可以将项目文件从Windows复制到WSL中，之后再通过WSL的Docker进行操作。 复制项目到WSL：在PowerShell中运行以下命令，将项目复制到WSL的文件系统中（例如，复制到/home/your-user/projects目录）： 1cp -r D:\\Desktop\\project\\health_manage_springboot \\\\wsl$\\Ubuntu\\home\\your-user\\projects\\ 在WSL中进入项目目录：打开WSL的终端，进入项目目录：1cd ~/projects/health_manage_springboot 运行Docker命令：在项目目录下，运行docker-compose up --build命令：1docker-compose up --build 优点：这种方式将项目文件复制到WSL的Linux文件系统中，确保在WSL环境下操作更加流畅，避免文件系统访问的问题。 操作通过创建 Dockerfile、配置 Docker Compose 文件，将前端、后端和数据库拆解为不同的容器。 1. 打包 Vue 项目在部署到 Docker 之前，Vue 项目需要打包成静态文件。 步骤： 确保你已经安装了 Node. js。 在项目根目录下，执行以下命令打包 Vue 项目：12npm installnpm run build 这将生成一个 dist 目录，里面是打包好的静态资源文件。 2. 创建 Vue 的 Dockerfile在 Vue 项目的根目录中，创建一个 Dockerfile，用于构建一个运行 Vue 静态文件的 Nginx 容器。 Dockerfile (Vue)1234567891011121314151617181920212223242526272829303132# 选择node环境作为构建阶段FROM node:16 AS build-stage# 设置工作目录WORKDIR /app# 将package.json和package-lock.json复制到容器中COPY package*.json ./# 安装依赖RUN npm install# 将项目代码复制到容器中COPY . .# 打包项目RUN npm run build# Nginx用于托管打包后的静态文件FROM nginx:alpine AS production-stage# 将Nginx配置文件替换为自定义配置文件COPY nginx.conf /etc/nginx/nginx.conf# 将打包后的静态文件复制到Nginx的html目录COPY --from=build-stage /app/dist /usr/share/nginx/html# 暴露80端口EXPOSE 80# 启动NginxCMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;] Nginx 配置文件 (nginx. conf)你需要创建一个 nginx.conf 文件，指定如何处理前端资源： 1234567891011121314151617181920212223242526272829303132333435# nginx.confworker_processes auto;events { worker_connections 1024;}http { include /etc/nginx/mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; # 配置server块，处理前端请求和API代理 server { listen 80; server_name localhost; location / { root /usr/share/nginx/html; index index.html index.htm; try_files $uri $uri/ /index.html; } # 代理API请求到后端Spring Boot服务 location /api/ { proxy_pass http://backend:9091/; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; } }} 3. 打包 Spring Boot 项目为了将 Spring Boot 项目部署到 Docker 中，我们需要先生成一个可执行的 JAR 文件。 使用系统环境中的Maven： 在项目根目录下，使用 Maven 打包 Spring Boot 项目：1mvn clean package 这将在 target 目录中生成一个 JAR 文件。 IDEA的Maven工具：这里由于我开发时使用的 maven 是 idea 自带的，在终端运行时会报错，故使用 IDE 自带的 Maven 项目进行打包。 打开IntelliJ IDEA，进入Spring Boot项目。 点击右侧的“Maven”工具窗口（如果看不到，可以通过View -&gt; Tool Windows -&gt; Maven来打开）。 展开项目中的Maven模块，找到Lifecycle。 在Lifecycle下，找到clean和package两个任务。 先双击clean，然后再双击package。 这样，IntelliJ IDEA会使用自带的Maven来清理项目并打包为JAR文件。打包完成后，生成的JAR文件会在target目录下。 4. 创建 Spring Boot 的 Dockerfile在 Spring Boot 项目的根目录中，创建一个 Dockerfile，用于构建 Spring Boot 容器。 Dockerfile (Spring Boot)1234567891011121314# 使用openjdk作为基础镜像FROM openjdk:17-jdk-alpine# 设置工作目录WORKDIR /app# 复制打包好的JAR文件到容器中COPY target/demo-0.0.1-SNAPSHOT.jar app.jar# 暴露9091端口EXPOSE 9091# 启动Spring Boot应用ENTRYPOINT [&quot;java&quot;, &quot;-jar&quot;, &quot;app.jar&quot;] 5. MySQL 容器配置为了将 MySQL 运行在 Docker 中，我们可以直接使用官方的 MySQL 镜像，并通过 Docker Compose 配置其数据库、用户和挂载外部数据卷来保存数据。在 6 中可以完成这个需求。 6. 创建 Docker Compose 文件Docker Compose 文件用于管理这三个服务（Vue 前端、Spring Boot 后端、MySQL 数据库）。 docker-compose. yml12345678910111213141516171819202122232425262728293031323334353637383940414243version: '3'services: # Vue前端 frontend: build: context: ./vue-project # 指定Vue项目的根目录 dockerfile: Dockerfile dns: - 8.8.8.8 - 8.8.4.4 #这里指定使用Google DNS服务器（8.8.8.8和8.8.4.4），因为我在npm install时出现ETIMEOUT，故设置Google的公共DNS服务器解决该问题。也可以通过增加网络超时时间或者本地安装依赖导入node_modules解决 ports: - &quot;8080:80&quot; # 将容器的80端口映射到主机的8080端口 depends_on: - backend # 确保后端先启动 # Spring Boot后端 backend: build: context: ./springboot-project # 指定Spring Boot项目的根目录 dockerfile: Dockerfile ports: - &quot;9091:9091&quot; # 映射后端服务端口 environment: SPRING_DATASOURCE_URL: jdbc:mysql://db:3306/health?useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=UTC SPRING_DATASOURCE_USERNAME: root SPRING_DATASOURCE_PASSWORD: 123456 depends_on: - db # 确保数据库先启动 # MySQL数据库 db: image: mysql:8.0 # MySQL镜像 environment: MYSQL_ROOT_PASSWORD: 123456 # 设置root密码 MYSQL_DATABASE: health # 初始化数据库 volumes: - db_data:/var/lib/mysql # 挂载卷，用于持久化存储 - /mnt/d/Desktop/project/health_management.sql:/docker-entrypoint-initdb.d/health_management.sql # 挂载SQL文件 ports: - &quot;3306:3306&quot; # 映射MySQL端口volumes: db_data: # 数据卷用于存储MySQL数据 7. 使用 Docker Compose 启动服务 在 WSL 中导航到项目的根目录1cd /mnt/d/Desktop/project 运行 docker compose 命令1docker-compose up --build 这个命令会： 构建 Vue 前端、Spring Boot 后端和 MySQL 的容器镜像。 使用 Nginx 托管 Vue 前端的静态文件。 将前端请求代理到后端 Spring Boot 应用。 启动 MySQL 并将数据保存在本地挂载卷中。 8. 检查服务是否正常运行 访问 http://localhost:8080 来查看 Vue 前端是否正常工作。 后端 Spring Boot 服务应该在 http://localhost:9091 正常运行。 通过 docker logs &lt;container_name&gt; 查看各个容器的日志，确保一切正常。 如果导入 sql 文件出现问题，检查SQL文件是否已经成功导入：进入 mysql 容器：1docker exec -it &lt;container_id&gt; /bin/bash (用 docker ps -a 获取 container_id)登录 mysql:1mysql -u root t-p 检查数据库中是否有你导入的表和数据：12USE health; SHOW TABLES; 如果 SQL 文件没有挂载成功的话可以采取手动导入 SQL 文件:注意这里的 sql 表格如果你是从 gitee 上直接 clone 的需要删除 CREATE DATABASE health; 这条语句，因为数据库 health 已经存在。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455zyh@QAQ /m/d/D/project (master)&gt; docker exec -it 649ab335c63b /bin/bashbash-5.1# mysql -u root -pEnter password:Welcome to the MySQL monitor. Commands end with ; or \\g.Your MySQL connection id is 13Server version: 8.0.39 MySQL Community Server - GPLCopyright (c) 2000, 2024, Oracle and/or its affiliates.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.mysql&gt; USE health;Reading table information for completion of table and column namesYou can turn off this feature to get a quicker startup with -ADatabase changedmysql&gt; SHOW TABLES;+------------------+| Tables_in_health |+------------------+| body || user |+------------------+2 rows in set (0.00 sec)mysql&gt; SELECT * FROM user;+----+----------+----------+-------------+------+----------------------+--------+| id | username | password | number | role | email | avatar |+----+----------+----------+-------------+------+----------------------+--------+| 1 | gss | 123456 | 13343243242 | 1 | super@aliyun.com | || 2 | zhangsan | 123456 | NULL | 1 | zhangsan@gmail.com | || 3 | lisi | 123456 | NULL | 1 | lisi@gmail.com | || 4 | wangwu | 123456 | NULL | 0 | wangwu@gmail.com | || 5 | zhaoer | 123456 | NULL | 0 | zhaoer@gmail.com | || 6 | songliu | 123456 | 4322432434 | 0 | songliu@gmail.com | || 13 | Alice | 123456 | 234532111 | 0 | alice@example.com | || 14 | Bob | 123456 | 13564736363 | 0 | bob@example.com | || 15 | Charlie | 123456 | 25323626 | 0 | charlie@example.com | || 16 | David1 | 123456 | 145256264 | 0 | david@example.com | || 17 | Emma | 123456 | 152334445 | 0 | emma@example.com | || 18 | Frank | 123456 | 1566543646 | 0 | frank@example.com | || 19 | Grace | 123456 | 1435253535 | 0 | grace@example.com | || 20 | Henry | 123456 | 15325363463 | 0 | henry@example.com | || 21 | Isabella | 123456 | 15353435 | 0 | isabella@example.com | || 22 | Jacob | 123456 | 114523424 | 0 | jacob@example.com | || 31 | test | 123456 | NULL | 0 | | |+----+----------+----------+-------------+------+----------------------+--------+17 rows in set (0.00 sec)mysql&gt; 上述信息表示一切功能正常。 补充 ： 停止正在运行的容器：1docker-compose down 停止并删除所有服务容器、网络和卷（不删除数据卷）再次启动：1docker-compose up --build 停止容器而不删除1docker-compose stop 再次启动：1docker-compose start 查看当前运行的容器1docker ps 包含历史：1docker ps -a","link":"/2024/09/25/docker%E5%AD%A6%E4%B9%A0/"},{"title":"Oj版本一开发过程","text":"https://github.com/strangersinsist/onlineJudge半成品，后续填坑（一定） 1 测评 代码沙箱（自主实现/部署开源项目） 判题 api judge0 api 选用，最初使用 python 测试运行 用 ai 做代码沙箱，理论上可以但是对于复杂的题目来说可能准确性不高，失去作为 OJ 的意义 移花接木，可以通过操作模拟浏览器的方式，用别人的 OJ 帮助判题，在别人的项目中提交代码并获取结果。比如 vjudge 2 问题遇到的报错 ： 1{code: '111', input: '222'} Analysis_A.vue:88 POST http://localhost:8080/api/runCode 404 (Not Found) request.js:55 errAxiosError: Request failed with status code 404 终端 1Received code: 111 Received input: 222 但是前端 1Payload to be sent: {code: '111', input: '222'}code: &quot;111&quot;input: &quot;222&quot;[[Prototype]]: Object Analysis_A.vue: 90 Response from backend: undefined 处理 :返回一个 JSON 格式的响应 遇到了问题，前端的 response.data 仍然是 undefined，尽管后端已经正确返回了数据。问题很可能是出现在 Axios 自动解析响应体的过程中，也可能是后端的返回内容格式化不正确。 123456789101112131415@CrossOrigin(origins = &quot;http://localhost:8080&quot;) @RestController public class CodeExecutionController { @PostMapping(&quot;/api/runCode&quot;) public ResponseEntity&lt;CodeExecutionResponse&gt; runCode(@RequestBody CodeExecutionRequest request) { String code = request.getCode(); String input = request.getInput(); String output = &quot;Code:\\n&quot; + code + &quot;\\n\\nInput:\\n&quot; + input + &quot;\\n\\nRepeated:\\n&quot; + code + &quot;\\n\\n&quot; + input; return ResponseEntity.ok().contentType(MediaType.APPLICATION_JSON).body(new CodeExecutionResponse(output)); } } 123456789101112131415161718192021222324252627runCode() { console.log(&quot;Running code with input:&quot;, this.testCase); const payload = { code: this.codeInput, input: this.testCase }; console.log(&quot;Payload to be sent:&quot;, payload); request.post(&quot;http://localhost:9091/api/runCode&quot;, payload, { responseType: 'json' }) .then(response =&gt; { console.log(&quot;Full response from backend:&quot;, response); // 打印完整的响应 console.log(&quot;Response data:&quot;, response.data); // 打印response.data if (response.data &amp;&amp; response.data.output) { this.testOutput = response.data.output; console.log(&quot;Output:&quot;, this.testOutput); } else { console.error(&quot;Output is missing in the response&quot;, response.data); } }) .catch(error =&gt; { console.error(&quot;Error running code:&quot;, error); }); }, 解决：检查完整的 response 对象结构从前面的日志看响应中存在数据，进一步打印 response 的完整结构，看看 response.data 是否被放在了其他位置。修改代码，检查 response 对象的所有属性，而不仅仅是 response.data： 3 调用 api在 pom. xml 中增加AsyncHttpClient 和 JSON 解析库依赖： 12345678910111213&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.asynchttpclient&lt;/groupId&gt; &lt;artifactId&gt;async-http-client&lt;/artifactId&gt; &lt;version&gt;2.12.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.13.3&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; CodeExecutionController: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123package com.example.demo.controller; import com.fasterxml.jackson.databind.JsonNode; import com.fasterxml.jackson.databind.ObjectMapper; import org.asynchttpclient.*; import org.springframework.http.MediaType; import org.springframework.http.ResponseEntity; import org.springframework.web.bind.annotation.*; import java.io.IOException; import java.util.Base64; import java.util.concurrent.CompletableFuture; class CodeExecutionRequest { private String code; private String input; public String getCode() { return code; } public void setCode(String code) { this.code = code; } public String getInput() { return input; } public void setInput(String input) { this.input = input; } } class CodeExecutionResponse { private String output; public CodeExecutionResponse(String output) { this.output = output; } public String getOutput() { return output; } public void setOutput(String output) { this.output = output; } } @CrossOrigin(origins = &quot;http://localhost:8080&quot;) @RestController public class CodeExecutionController { private static final String API_HOST = &quot;judge0-ce.p.rapidapi.com&quot;; private static final String API_KEY = &quot;a3adbed817msh3baa8ad5c76fa09p137a87jsn636cf96b2a42&quot;; @PostMapping(&quot;/api/runCode&quot;) public CompletableFuture&lt;ResponseEntity&lt;CodeExecutionResponse&gt;&gt; runCode(@RequestBody CodeExecutionRequest request) { String code = request.getCode(); String input = request.getInput(); // 将代码和输入进行 Base64 编码 String encodedCode = Base64.getEncoder().encodeToString(code.getBytes()); String encodedInput = Base64.getEncoder().encodeToString(input.getBytes()); String payload = String.format( &quot;{\\&quot;language_id\\&quot;: 52, \\&quot;source_code\\&quot;: \\&quot;%s\\&quot;, \\&quot;stdin\\&quot;: \\&quot;%s\\&quot;}&quot;, encodedCode, encodedInput ); // 创建 AsyncHttpClient 实例 AsyncHttpClient client = Dsl.asyncHttpClient(); Request apiRequest = Dsl.post(&quot;https://&quot; + API_HOST + &quot;/submissions?base64_encoded=true&amp;wait=true&amp;fields=*&quot;) .setHeader(&quot;x-rapidapi-key&quot;, API_KEY) .setHeader(&quot;x-rapidapi-host&quot;, API_HOST) .setHeader(&quot;Content-Type&quot;, &quot;application/json&quot;) .setBody(payload) .build(); // 处理 API 的响应 return client.executeRequest(apiRequest).toCompletableFuture().thenApply(response -&gt; { try { // 解析 JSON 响应 ObjectMapper mapper = new ObjectMapper(); JsonNode jsonNode = mapper.readTree(response.getResponseBody()); // 解码 stdout 的 Base64 编码 String stdout = &quot;&quot;; if (jsonNode.has(&quot;stdout&quot;) &amp;&amp; !jsonNode.get(&quot;stdout&quot;).isNull()) { String stdoutBase64 = jsonNode.get(&quot;stdout&quot;).asText(); stdout = new String(Base64.getDecoder().decode(stdoutBase64)); } else { stdout = &quot;No output received.&quot;; } // 关闭客户端 try { client.close(); } catch (IOException e) { e.printStackTrace(); } // 返回响应给前端 return ResponseEntity.ok() .contentType(MediaType.APPLICATION_JSON) .body(new CodeExecutionResponse(stdout)); } catch (Exception e) { e.printStackTrace(); try { client.close(); } catch (IOException ioException) { ioException.printStackTrace(); } return ResponseEntity.status(500).body(new CodeExecutionResponse(&quot;Error processing the request.&quot;)); } }); } } 4 提交如何测评？手动给出一些输入样例+自动生成输入样例（用程序（上传题目时出题人要给出数据生成代码）或者 AI）判题：将输入样例同时传入标准答案和用户答案，判断两者是否相同。huanghongxun/Judger: Judge system for Sicily Online Judge, VMatrix Course/OJ, GDOI (github.com) 5 问题在做上传题目的表格时，让 id 自动递增，刚开始没有保存这个表格 123456789101112131415import com.baomidou.mybatisplus.annotation.IdType;import com.baomidou.mybatisplus.annotation.TableId;import com.baomidou.mybatisplus.annotation.TableName;import lombok.Data;@TableName(&quot;ojquestion&quot;)@Datapublic class OJ { @TableId(type = IdType.AUTO) // 设置为 AUTO 类型，自增主键 private Integer id; // 使用 Integer 避免默认值问题 private String question; private String answer; private String title;} application.properties： 1mybatis-plus.global-config.db-config.id-type=AUTO 6 两者答案对比对提交增加一个方法，点击提交后将输入的code及输入数据返回后端，然后在后端调用api，分别将（输入的code及输入数据）和（后端数据库中的ojquestion表格对应的正确代码answer及前端的输入数据）提交给api运行，如果两者运行结果一致则在前端左侧的”提交“栏显示”答案正确“否则显示”答案错误“ 用户操作： 用户在页面上输入代码和测试数据。点击“提交”按钮。前端逻辑：发送请求到 /api/submitCode/{id} 接口。后端逻辑：获取用户代码和输入数据。查询数据库中的正确答案代码。分别运行两段代码，比较运行结果。返回“答案正确”或“答案错误”给前端。前端显示结果：使用弹窗显示结果信息。 CodeExecution.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203package com.example.demo.controller; import com.example.demo.entity.OJ; import com.example.demo.mapper.OjMapper; import jakarta.annotation.Resource; import com.fasterxml.jackson.databind.JsonNode; import com.fasterxml.jackson.databind.ObjectMapper; import org.asynchttpclient.*; import org.springframework.http.MediaType; import org.springframework.http.ResponseEntity; import org.springframework.web.bind.annotation.*; import java.io.IOException; import java.util.Base64; import java.util.HashMap; import java.util.Map; import java.util.concurrent.CompletableFuture; class CodeExecutionRequest { private String code; private String input; public String getCode() { return code; } public void setCode(String code) { this.code = code; } public String getInput() { return input; } public void setInput(String input) { this.input = input; } } class CodeExecutionResponse { private String output; public CodeExecutionResponse(String output) { this.output = output; } public String getOutput() { return output; } public void setOutput(String output) { this.output = output; } } @CrossOrigin(origins = &quot;http://localhost:8080&quot;) @RestController public class CodeExecutionController { private static final String API_HOST = &quot;judge0-ce.p.rapidapi.com&quot;; private static final String API_KEY = &quot;ecb28c3467mshf8bd712d1eaeae2p100845jsnb2a33783ad93&quot;; @PostMapping(&quot;/api/runCode&quot;) public CompletableFuture&lt;ResponseEntity&lt;CodeExecutionResponse&gt;&gt; runCode(@RequestBody CodeExecutionRequest request) { String code = request.getCode(); String input = request.getInput(); String encodedCode = Base64.getEncoder().encodeToString(code.getBytes()); String encodedInput = Base64.getEncoder().encodeToString(input.getBytes()); String payload = String.format( &quot;{\\&quot;language_id\\&quot;: 52, \\&quot;source_code\\&quot;: \\&quot;%s\\&quot;, \\&quot;stdin\\&quot;: \\&quot;%s\\&quot;}&quot;, encodedCode, encodedInput ); AsyncHttpClient client = Dsl.asyncHttpClient(); Request apiRequest = Dsl.post(&quot;https://&quot; + API_HOST + &quot;/submissions?base64_encoded=true&amp;wait=true&amp;fields=*&quot;) .setHeader(&quot;x-rapidapi-key&quot;, API_KEY) .setHeader(&quot;x-rapidapi-host&quot;, API_HOST) .setHeader(&quot;Content-Type&quot;, &quot;application/json&quot;) .setBody(payload) .build(); // 处理 API 的响应 return client.executeRequest(apiRequest).toCompletableFuture().thenApply(response -&gt; { try { // 解析 JSON 响应 ObjectMapper mapper = new ObjectMapper(); JsonNode jsonNode = mapper.readTree(response.getResponseBody()); // 解码 stdout 的 Base64 编码 String stdout = &quot;&quot;; if (jsonNode.has(&quot;stdout&quot;) &amp;&amp; !jsonNode.get(&quot;stdout&quot;).isNull()) { String stdoutBase64 = jsonNode.get(&quot;stdout&quot;).asText(); stdout = new String(Base64.getDecoder().decode(stdoutBase64)); } else { stdout = &quot;No output received.&quot;; } // 关闭客户端 try { client.close(); } catch (IOException e) { e.printStackTrace(); } // 返回响应给前端 return ResponseEntity.ok() .contentType(MediaType.APPLICATION_JSON) .body(new CodeExecutionResponse(stdout)); } catch (Exception e) { e.printStackTrace(); try { client.close(); } catch (IOException ioException) { ioException.printStackTrace(); } return ResponseEntity.status(500).body(new CodeExecutionResponse(&quot;Error processing the request.&quot;)); } }); } // 注入 Mapper @Resource private OjMapper ojMapper; @PostMapping(&quot;/api/submitCode/{id}&quot;) public CompletableFuture&lt;ResponseEntity&lt;Map&lt;String, String&gt;&gt;&gt; submitCode( @PathVariable Integer id, @RequestBody CodeExecutionRequest request) { // 获取输入的代码和输入数据 String userCode = request.getCode(); String inputData = request.getInput(); // 查询数据库中的正确答案代码 OJ ojQuestion = ojMapper.selectById(id); String correctAnswer = ojQuestion.getAnswer(); // 异步运行用户代码 CompletableFuture&lt;String&gt; userCodeExecution = executeCode(userCode, inputData); // 异步运行数据库中正确答案的代码 CompletableFuture&lt;String&gt; correctAnswerExecution = executeCode(correctAnswer, inputData); return userCodeExecution.thenCombine(correctAnswerExecution, (userOutput, correctOutput) -&gt; { Map&lt;String, String&gt; result = new HashMap&lt;&gt;(); if (userOutput.equals(correctOutput)) { result.put(&quot;status&quot;, &quot;correct&quot;); result.put(&quot;message&quot;, &quot;答案正确&quot;); } else { result.put(&quot;status&quot;, &quot;incorrect&quot;); result.put(&quot;message&quot;, &quot;答案错误&quot;); } return ResponseEntity.ok().contentType(MediaType.APPLICATION_JSON).body(result); }).exceptionally(ex -&gt; { ex.printStackTrace(); Map&lt;String, String&gt; errorResponse = new HashMap&lt;&gt;(); errorResponse.put(&quot;message&quot;, &quot;代码运行出错&quot;); return ResponseEntity.status(500).body(errorResponse); }); } // 执行逻辑封装成方法 private CompletableFuture&lt;String&gt; executeCode(String code, String input) { String encodedCode = Base64.getEncoder().encodeToString(code.getBytes()); String encodedInput = Base64.getEncoder().encodeToString(input.getBytes()); String payload = String.format( &quot;{\\&quot;language_id\\&quot;: 52, \\&quot;source_code\\&quot;: \\&quot;%s\\&quot;, \\&quot;stdin\\&quot;: \\&quot;%s\\&quot;}&quot;, encodedCode, encodedInput ); AsyncHttpClient client = Dsl.asyncHttpClient(); Request apiRequest = Dsl.post(&quot;https://&quot; + API_HOST + &quot;/submissions?base64_encoded=true&amp;wait=true&amp;fields=*&quot;) .setHeader(&quot;x-rapidapi-key&quot;, API_KEY) .setHeader(&quot;x-rapidapi-host&quot;, API_HOST) .setHeader(&quot;Content-Type&quot;, &quot;application/json&quot;) .setBody(payload) .build(); return client.executeRequest(apiRequest).toCompletableFuture().thenApply(response -&gt; { try { JsonNode jsonNode = new ObjectMapper().readTree(response.getResponseBody()); String stdoutBase64 = jsonNode.has(&quot;stdout&quot;) &amp;&amp; !jsonNode.get(&quot;stdout&quot;).isNull() ? jsonNode.get(&quot;stdout&quot;).asText() : &quot;&quot;; return new String(Base64.getDecoder().decode(stdoutBase64)); } catch (IOException e) { e.printStackTrace(); return &quot;运行失败&quot;; } finally { try { client.close(); } catch (IOException e) { e.printStackTrace(); } } }); } } Analysis_A.vue 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211&lt;template&gt; &lt;div class=&quot;main-container&quot;&gt; &lt;div class=&quot;left-section&quot;&gt; &lt;el-tabs&gt; &lt;el-tab-pane label=&quot;描述&quot;&gt; &lt;div v-html=&quot;renderMarkdown(ojData.question)&quot; class=&quot;markdown-content&quot;&gt;&lt;/div&gt; &lt;/el-tab-pane&gt; &lt;el-tab-pane label=&quot;提交&quot;&gt;提交内容&lt;/el-tab-pane&gt; &lt;el-tab-pane label=&quot;排名&quot;&gt;排名内容&lt;/el-tab-pane&gt; &lt;/el-tabs&gt; &lt;/div&gt; &lt;div class=&quot;right-section&quot;&gt; &lt;div class=&quot;code-area&quot;&gt; &lt;el-input type=&quot;textarea&quot; v-model=&quot;codeInput&quot; rows=&quot;10&quot; placeholder=&quot;Enter your code here&quot;&gt;&lt;/el-input&gt; &lt;/div&gt; &lt;div class=&quot;test-output-section&quot;&gt; &lt;div class=&quot;test-case-input&quot;&gt; &lt;el-input type=&quot;textarea&quot; v-model=&quot;testCase&quot; rows=&quot;5&quot; placeholder=&quot;在此处填写输入数据，也可留空 可以按 Ctrl+A 选中全部来一键删除&quot;&gt;&lt;/el-input&gt; &lt;/div&gt; &lt;div class=&quot;test-output&quot;&gt; &lt;el-input type=&quot;textarea&quot; v-model=&quot;testOutput&quot; rows=&quot;5&quot; placeholder=&quot;等待测试运行&quot; disabled&gt;&lt;/el-input&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;button-section&quot;&gt; &lt;el-button class=&quot;run-button&quot; @click=&quot;runCode&quot;&gt;测试运行&lt;/el-button&gt; &lt;el-button class=&quot;submit-button&quot; @click=&quot;submitCode&quot;&gt;提交&lt;/el-button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; &lt;script&gt; import { marked } from &quot;marked&quot;; import request from &quot;@/utils/request&quot;; export default { name: &quot;Analysis_A&quot;, data() { return { ojData: { id: '', title: '', question: '' }, codeInput: '', testCase: '', testOutput: '' }; }, created() { const id = this.$route.query.id; if (id) { this.fetchOjData(id); } }, methods: { fetchOjData(id) { request.get(`/api/oj/${id}`).then(res =&gt; { this.ojData = res.data; }).catch(error =&gt; { console.error(&quot;Error fetching OJ data:&quot;, error); }); }, renderMarkdown(content) { return marked(content); }, runCode() { console.log(&quot;Running code with input:&quot;, this.testCase); const payload = { code: this.codeInput, input: this.testCase }; console.log(&quot;Payload to be sent:&quot;, payload); // 打印 payload request.post(&quot;http://localhost:9091/api/runCode&quot;, payload, { responseType: 'json' }) .then(response =&gt; { console.log(&quot;Full response object from backend:&quot;, response); if (response.data) { console.log(&quot;Response data:&quot;, response.data); if (response.data.output) { this.testOutput = response.data.output; console.log(&quot;Output:&quot;, this.testOutput); } else { console.error(&quot;Output is missing in the response:&quot;, response.data); } } else if (response.output) { // 如果数据直接在 response 中，而不是在 response.data 中 this.testOutput = response.output; console.log(&quot;Output directly in response:&quot;, this.testOutput); } else { console.error(&quot;No valid data in the response&quot;); } }) .catch(error =&gt; { console.error(&quot;Error running code:&quot;, error); }); }, submitCode() { const id = this.$route.query.id; const payload = { code: this.codeInput, input: this.testCase }; request.post(`http://localhost:9091/api/submitCode/${id}`, payload, { timeout: 15000 }) .then(response =&gt; { console.log('Full response:', response); if (response.message &amp;&amp; response.status) { console.log('Direct response message:', response.message); console.log('Direct response status:', response.status); this.showSubmitResult(response.message); } else if (response.data) { // 打印 response.data 检查其是否存在 console.log('Result data:', response.data); const result = response.data; if (result.status === &quot;correct&quot;) { this.showSubmitResult(result.message); } else { this.showSubmitResult(result.message); } } else { this.showSubmitResult(&quot;无法解析服务器响应&quot;); } }) .catch(error =&gt; { console.error(&quot;提交代码时出错:&quot;, error); this.showSubmitResult(&quot;提交失败，请重试&quot;); }); }, showSubmitResult(message) { this.$alert(message, &quot;提交结果&quot;, { confirmButtonText: &quot;确定&quot; }); } } } &lt;/script&gt; &lt;style scoped&gt; .main-container { display: flex; height: 800px; } .left-section { flex: 1; padding: 10px; width: 1500px; } .right-section { flex: 2; display: flex; flex-direction: column; padding: 10px; width: 30%; } .code-area { height: 2000px; margin-bottom: 10px; } .test-output-section { display: flex; justify-content: space-between; flex: 1; } .test-case-input, .test-output { width: 48%; height: 200px; } .button-section { display: flex; justify-content: flex-end; margin-top: 10px; } .markdown-content { padding: 10px; background-color: #f9f9f9; border-radius: 5px; } .run-button { background-color: white; color: black; border: 1px solid #dcdfe6; } .run-button:hover { background-color: #f2f2f2; } .submit-button { background-color: #009999; color: white; border: none; } .submit-button:hover { background-color: #007777; } &lt;/style&gt; 主要改动：后端增加了/api/submitCode，接口来处理用户的提交逻辑 后端应该返回一个有效的 JSON 响应 使用了 HashMap 来创建一个可变的映射（Map&lt;String, String&gt;）。 使用 put 方法动态添加键值对，分别为 &quot;status&quot; 和 &quot;message&quot;。1234567891011121314151617181920212223242526272829303132333435363738@PostMapping(&quot;/api/submitCode/{id}&quot;)public CompletableFuture&lt;ResponseEntity&lt;Map&lt;String, String&gt;&gt;&gt; submitCode( @PathVariable Integer id, @RequestBody CodeExecutionRequest request) { OJ ojQuestion = ojMapper.selectById(id); if (ojQuestion == null) { Map&lt;String, String&gt; errorResponse = new HashMap&lt;&gt;(); errorResponse.put(&quot;message&quot;, &quot;题目不存在&quot;); return CompletableFuture.completedFuture( ResponseEntity.status(404).body(errorResponse)); } String correctAnswer = ojQuestion.getAnswer(); String userCode = request.getCode(); String inputData = request.getInput(); CompletableFuture&lt;String&gt; userCodeExecution = executeCode(userCode, inputData); CompletableFuture&lt;String&gt; correctAnswerExecution = executeCode(correctAnswer, inputData); return userCodeExecution.thenCombine(correctAnswerExecution, (userOutput, correctOutput) -&gt; { Map&lt;String, String&gt; result = new HashMap&lt;&gt;(); // 使用 HashMap 以便动态添加数据 if (userOutput.equals(correctOutput)) { result.put(&quot;status&quot;, &quot;correct&quot;); result.put(&quot;message&quot;, &quot;答案正确&quot;); } else { result.put(&quot;status&quot;, &quot;incorrect&quot;); result.put(&quot;message&quot;, &quot;答案错误&quot;); } return ResponseEntity.ok().contentType(MediaType.APPLICATION_JSON).body(result); }).exceptionally(ex -&gt; { ex.printStackTrace(); Map&lt;String, String&gt; errorResponse = new HashMap&lt;&gt;(); errorResponse.put(&quot;message&quot;, &quot;代码运行出错&quot;); return ResponseEntity.status(500).body(errorResponse); });} 使用Json的形式返回前端，但是现在前端提交正确代码时{code: 200, message: “success”, data: {id: 1,…}} code : 200 data : {id: 1,…} message : “success”，前端弹窗却显示答案错误 解决方法：可能 Axios 响应对象中并没有 response.status，通过 response.data 来获取实际返回的结果，而不是 response.status分别打印 1console.log('Full response:', response); 1console.log('Result data:', result); 与问题 1 属于同一原因导致的, 12345678910111213141516171819202122232425262728293031323334submitCode() { const id = this.$route.query.id; const payload = { code: this.codeInput, input: this.testCase }; request.post(`http://localhost:9091/api/submitCode/${id}`, payload, { timeout: 15000 }) .then(response =&gt; { console.log('Full response:', response); // 打印完整响应对象 // 检查 response 是否直接包含 message 和 status if (response.message &amp;&amp; response.status) { console.log('Direct response message:', response.message); console.log('Direct response status:', response.status); this.showSubmitResult(response.message); } else if (response.data) { // 打印 response.data 检查其是否存在 console.log('Result data:', response.data); const result = response.data; if (result.status === &quot;correct&quot;) { this.showSubmitResult(result.message); } else { this.showSubmitResult(result.message); } } else { this.showSubmitResult(&quot;无法解析服务器响应&quot;); } }) .catch(error =&gt; { console.error(&quot;提交代码时出错:&quot;, error); this.showSubmitResult(&quot;提交失败，请重试&quot;); });} 其实这里可以换一种方式实现，比如将数据库正确答案传至 api 后的结果作为正确输出，和用户输入的代码及测试用例一起再次传到 api，这样可以直接把 api 返回的 json 传至前端，也不用加判断正误的逻辑，不用手动实现传输 json。","link":"/2024/10/28/oj%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B/"},{"title":"基于Springboot+Vue的WebApp开发实验报告","text":"Java与面向对象设计的大作业，实验报告docx用pandoc转成了md。 【实验目的】 掌握Java与面向对象基本原理和概念。 掌握Java与面向对象编程思想和主流技术或框架。 掌握基于Java开发完整软件Demo，并能演示。 【实验装备】 个人笔记本，idea，JDK环境，mysql，navicat, vue，git等。 【实验内容】 基于所选择的主题方向，调研、分析和设计3-5个核心场景（模块）作为研究对象，根据掌握的Java和相关知识，实现相对完整的WebApp应用。以Java为基础，可以自由选择搭配其它技术和框架，输出详细的设计文档、项目源代码和可运行的Demo视频。 【实验要求】 按实验内容输出详细设计、实现、运行关键截图，要求行文整洁、紧凑、顺畅。 代码以团队gitee形式提交，视频以百度网盘形式提交，可限时公开访问。 团队Gitee: JavaGroup (gitee.com) 本项目代码: JavaGroup/project(gitee.com) 视频百度网盘：链接提取码：2s45 实验报告需要交代团队成员分工，以及自己承担的任务（要求任务量合理，鼓励交叉参与）；个人报告要求完整，团队成果部分精炼描述，侧重个人为主部分加以详细描述。 【实验分析】 输出实验分析总结和心得体会。 【参考资料】 参考教程：带你从0搭建一个Springboot+vue前后端分离项目，真的很简单！_哔哩哔哩_bilibili 参考资料： 1. 一个 Vue 3 UI 框架 | Element Plus(element-plus.org) 2. Vue.js 教程 | Vue.js 中文文档(cn.vuejs.org) 3. SpringBoot+Vue个人健康管理系统Java毕业设计_哔哩哔哩_bilibili(主要参考要实现什么功能) 这个源代码上传至：JavaGroup/health_management(gitee.com) 【目录】 一.背景分析 经过了解和学习，为实现健康管理系统，我们采取了一种现代化的前后端分离架构，以下是我们选用的关键技术和工具： 1.前端技术 Vue.js：作为一个渐进式JavaScript框架，Vue.js被用于创建高效、灵活的用户界面。它的组件化架构让我们能够重用代码并加快开发速度。 Element-Plus：基于Vue3的桌面端组件库，提供了一套丰富的UI组件，帮助我们在保持界面美观的同时，减少了开发和设计的工作量。 2.后端技术 SpringBoot：简化了基于Spring的应用开发过程，使得我们能够快速搭建和部署微服务。SpringBoot自动配置的特性大幅度减轻了配置工作，让我们能够专注于业务逻辑的实现。 MyBatis：它是一个支持定制SQL、存储过程以及高级映射的持久层框架。MyBatis消除了几乎所有的JDBC代码，并手动设置参数以及获取结果集。通过简单的XML或注解，我们能够将接口映射成数据库中的记录。 Lombok：一个Java库，通过使用注解，能够自动化生成模板代码，如getters、setters、constructors等。Lombok极大地简化了我们的Java代码，使得它更加简洁易读。 3.数据库管理 MySQL：我们选择MySQL作为后端数据库，借助其强大和广泛支持的特性来存储应用数据。 Navicat：作为一款强大的数据库管理工具，Navicat让数据库的管理变得轻松便捷。它不仅支持MySQL，还支持大量其它数据库，提供直观的GUI方便进行数据管理、开发和维护。 二.需求分析 我们计划实现3-5个主核心功能，参考健康管理系统|拾果健康(sghealth.cn)及网上找到一些健康管理系统找到大概想实现的功能。在写好vue+springboot基本框架，搭建好跨域配置，写好依赖，写好基本的响应码，数据库配置，引入数据库表格写好mapper,controller,entity等等后，决定按功能分工，各自实现负责的功能的前端+后端。虽然前后端分离，但是功能一个人同时写，不断加功能完善项目，同时锻炼写前端和后端的能力。 三.系统设计 下面是我们当时设计的方案： 系统：管理员、用户 登录界面参考： 首页 健康信息上传 商品推荐 运动知识 评估与建议 随后进行抽签，选择各自要实现的功能。抽签决定好后先写好头部和侧边栏，新建不同的.vue和路由，之后每个人写自己的.vue并根据需要补充后端.java即可。 四.系统实现 团队成果： 采用前端部分使用Vue.js和Element-Plus来构建用户界面，后端使用SpringBoot和MyBatis进行业务逻辑的处理和数据持久化，同时使用Navicat来管理MySQL数据库，并借助Lombok简化Java代码的开发。 个人报告： 我的任务：准备阶段学习git，gitee的使用和navicat，idea的配置并创建gitee团队；正式写项目时负责4个小功能，分别是登录、注册、设置、健康问答。并简单改动一下其他部分的细节。最后整理项目时导出sql文件，写项目README。 我的gitee：Zhuyuehan (strangersinsist) -Gitee 1).准备阶段： 参照JavaGroup/health_management(gitee.com)学会怎么运行前端后端数据库,git的一些操作。 2).正式项目： 1.登录前端Login.vue，并在health_manage_vue\\src\\router\\index.js设置路由，点击按钮触发js,通过post与后端进行交互。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;script&gt;import request from &quot;@/utils/request&quot;;export default { name: &quot;Login&quot;, components: {User,Lock}, data(){ return { form:{}, rules:{ username:[ {required:true,message:&quot;请输入用户名&quot;,trigger:'blur'}, ], password:[ {required:true,message:&quot;请输入密码&quot;,trigger:'blur'}, ], } } }, methods:{ login(){ request.post(&quot;/api/user/login&quot;,this.form).then(res =&gt;{ console.log(res); if(res.code == '200'){ this.$message({ type: &quot;success&quot;, message:&quot;登录成功&quot; }) //改一下试图存缓存 sessionStorage.setItem(&quot;user&quot;, JSON.stringify(res.data)); this.$router.push(&quot;/&quot;) }else{ this.$message({ type:&quot;error&quot;, message:&quot;用户名或密码错误&quot; }) } }) } }}import { User,Lock,} from '@element-plus/icons-vue'&lt;/script&gt;&lt;template&gt; &lt;div class=&quot;login-container&quot;&gt; &lt;div class=&quot;login-card&quot;&gt; &lt;h1 class=&quot;login-title&quot;&gt;欢迎登录&lt;/h1&gt; &lt;el-form :model=&quot;form&quot; :rules=&quot;rules&quot; class=&quot;login-form&quot; ref=&quot;loginForm&quot; size=&quot;large&quot;&gt; &lt;el-form-item prop=&quot;username&quot; class=&quot;form-item&quot;&gt; &lt;el-icon class=&quot;icon&quot;&gt;&lt;User /&gt;&lt;/el-icon&gt; &lt;el-input v-model=&quot;form.username&quot; placeholder=&quot;用户名：&quot; class=&quot;input-field&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item prop=&quot;password&quot; class=&quot;form-item&quot;&gt; &lt;el-icon class=&quot;icon&quot;&gt;&lt;Lock /&gt;&lt;/el-icon&gt; &lt;el-input type=&quot;password&quot; v-model=&quot;form.password&quot; placeholder=&quot;密码：&quot; class=&quot;input-field&quot; show-password&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;div class=&quot;form-actions&quot;&gt; &lt;el-button class=&quot;action-button&quot; @click=&quot;login&quot;&gt;登录&lt;/el-button&gt; &lt;el-button class=&quot;action-button&quot; @click=&quot;this.$router.push('/register')&quot;&gt;注册&lt;/el-button&gt; &lt;/div&gt; &lt;/el-form&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;//这部分为了优化界面写的比较多，省略，详细看gitee代码&lt;/style&gt; 后端和队友共用的Result.java，User.java，UserMapper.java和UserController.java，用于获取数据库信息及返回数据给前端，我在队友写的代码基础上增加了需要的部分UserController.java: 12345678910111213141516171819202122232425262728package com.example.demo.controller;import …@RestController@RequestMapping(&quot;/user&quot;)public class UserController { @Resource UserMapper userMapper; @PostMapping(&quot;/login&quot;) public Result&lt;?&gt; login(@RequestBody User user){ User res = userMapper.selectOne(Wrappers.&lt;User&gt;lambdaQuery().eq(User::getUsername,user.getUsername()).eq(User::getPassword,user.getPassword())); if(res ==null){ return Result.fail(&quot;用户名或密码错误&quot;); } return Result.success(res); } @PostMapping(&quot;/register&quot;) public Result&lt;?&gt; register(@RequestBody User user){ User res = userMapper.selectOne(Wrappers.&lt;User&gt;lambdaQuery().eq(User::getUsername,user.getUsername())); if(res !=null){ return Result.fail(&quot;用户名重复&quot;); } if(user.getPassword()==null){ user.setPassword(&quot;123456&quot;); } userMapper.insert(user); return Result.success(user); } 最初是这样： 经过美化： 2.注册 与登录基本类似，前端Register.vue，并在index.js设置路由。详细代码可以看gitee。(这个后面和登录用了同样的方式美化了一下) 3.设置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;script&gt;import request from &quot;@/utils/request&quot;;export default { name: &quot;Setting&quot;, components: { }, data(){ return{ form:{}, input:&quot;&quot; } }, created(){ let str=sessionStorage.getItem(&quot;user&quot;)||&quot;{}&quot; this.form=JSON.parse(str) }, methods:{ handleClose(){ this.$router.push('/home'); }, update(){ request.put(&quot;api/user&quot;,this.form).then(res =&gt;{ console.log(res); if(res.code == '200'){ this.$message({ type: &quot;success&quot;, message:&quot;更新成功&quot; }) sessionStorage.setItem(&quot;user&quot;,JSON.stringify(this.form)) this.$router.push('/home'); }else{ this.$message({ type:&quot;error&quot;, message:&quot;更新失败&quot; }) } }) } }}&lt;/script&gt;&lt;template&gt; &lt;div&gt; &lt;el-dialog v-model=&quot;form&quot; title=&quot;个人信息编辑&quot; width=&quot;500&quot; @close=&quot;handleClose&quot;&gt; &lt;el-form :model=&quot;form&quot;&gt; &lt;el-form-item label=&quot;用户名&quot; :label-width=&quot;formLabelWidth&quot;&gt; &lt;el-input v-model=&quot;form.username&quot; disabled&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;密码&quot; :label-width=&quot;formLabelWidth&quot;&gt; &lt;el-input v-model=&quot;form.password&quot; show-password&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;手机号&quot; :label-width=&quot;formLabelWidth&quot;&gt; &lt;el-input v-model=&quot;form.number&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;邮箱&quot; :label-width=&quot;formLabelWidth&quot;&gt; &lt;el-input v-model=&quot;form.email&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;div class=&quot;dialog-footer&quot;&gt; &lt;el-button @click=&quot;this.$router.push('/home')&quot;&gt;取消&lt;/el-button&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;update&quot;&gt; 确认 &lt;/el-button&gt; &lt;/div&gt; &lt;/el-dialog&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;&lt;/style&gt; 这个是header.vue部分的设置，写这部分是新增了vue和路由实现的。这部分不难，是在element plus中找了表单，再写好script部分，获取的user信息就好了。后来优化这部分时补充handleClose方法点击叉号跳转/home页面，使操作更加流畅。 4.健康问答 前端实现：HomeView.vue: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&lt;template&gt;&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;chatbox&quot;&gt; &lt;h2 class=&quot;title&quot;&gt;健康问答&lt;/h2&gt; &lt;div class=&quot;messages&quot; ref=&quot;messageBox&quot;&gt; &lt;div v-for=&quot;(message, index) in messages&quot; :key=&quot;index&quot; :class=&quot;{'message-container': true, 'user-message': message.sender === 'User', 'bot-message': message.sender !== 'User'}&quot; &gt; &lt;el-avatar class=&quot;message-avatar&quot; style=&quot;background-color: cornflowerblue;color: black&quot;&gt;{{message.sender === 'User' ? 'User' : 'Bot'}}&lt;/el-avatar&gt; &lt;div class=&quot;message-content&quot;&gt;{{message.text}}&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;input-section&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;userinput&quot; v-model=&quot;userInput&quot; @keyup.enter=&quot;sendMessage&quot; placeholder=&quot;输入：&quot; /&gt; &lt;button class=&quot;send&quot; @click=&quot;sendMessage&quot; &gt; 发送 &lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import axios from 'axios'export default { name: 'HomeView', components: { }, data(){ return{ userInput: '', messages: [], } }, methods:{ async callAPIMethod(input) { try { const response = await axios.post('http://localhost:9091/reply', { message: input }); return response.data; } catch (error) { console.error(error); } }, async sendMessage() { this.messages.push({ sender: 'User', text: this.userInput, }); console.log(&quot;Ready to send message: &quot; + this.userInput); const response = await this.callAPIMethod(this.userInput); console.log(&quot;Received message: &quot; + response); if(response) { this.messages.push({ sender: 'Bot', text: response, }); } this.$refs.messageBox.scrollTop = this.$refs.messageBox.scrollHeight; this.userInput = ''; }, },}&lt;/script&gt;&lt;style scoped&gt;//这部分太长了省略，详细看gitee代码&lt;/style&gt; 后端实现：MessageController.java 1234567891011121314151617181920212223242526272829package com.example.demo.controller;import …class Message { private String message; // getter // setter}@CrossOrigin(origins = &quot;http://localhost:8080&quot;)@RestControllerpublic class MessageController { @PostMapping(&quot;/reply&quot;) public String reply(@RequestBody Message message) { Random rand = new Random(); String[] responses = {&quot;保持健康~&quot;, &quot;锻炼身体！&quot;, &quot;饮食规律~&quot;}; if (&quot;你好&quot;.equals(message.getMessage())) { return &quot;你好&quot;; } else if (&quot;什么是亚健康管理系统&quot;.equals(message.getMessage())) { return &quot;这个亚健康管理系统是人工智能学院java小组开发的。包括主页，运动知识，健康购物，评估与建议，健康信息上传的功能&quot;; } //省略一些else if else { return responses[rand.nextInt(responses.length)]; } }} 这部分本来我想连一个大语言模型的api，但是后来找不到适合的免费api，并且觉得如果是健康管理系统的话可能直接连一个大模型不太合适，要手动个性化设置一下，遂写了一些回复语代替，比较简洁，仅供演示。如果问”你好”和”什么是亚健康管理系统&quot;等会回复特定的话，问其他就在&quot;保持健康~&quot;,&quot;锻炼身体！&quot;, &quot;饮食规律~&quot;中随机回复一个。 最初是下面左图所示，右图是后来美化了一下。 5.一些其他的小细节 1）头部username显示 最初： 改动后： 显示具体的用户名 123&lt;template #title&gt; &lt;el-avatar style=&quot;background-color: cornflowerblue;color: black&quot;&gt;{{ user.username }}&lt;/el-avatar&gt; &lt;/template&gt; 2）管理员和普通用户权限，管理员可以看到用户管理的页面，这里是在数据库增加了role(int类型，1表示管理员0表示普通用户), 在Aside.vue： 1234 &lt;el-menu-item index=&quot;7&quot; v-if=&quot;user.role===1&quot; @click=&quot;this.$router.push('/user_manage')&quot;&gt; &lt;el-icon&gt;&lt;List /&gt;&lt;/el-icon&gt; &lt;span&gt;用户管理&lt;/span&gt;&lt;/el-menu-item&gt; v-if=&quot;user.role===1&quot; 这样实现的 在User_manage.vue: 123456&lt;el-table-column label=&quot;角色&quot;&gt; &lt;template #default=&quot;scope&quot;&gt; &lt;span v-if=&quot;scope.row.role===1&quot;&gt;管理员&lt;/span&gt; &lt;span v-if=&quot;scope.row.role===0&quot;&gt;普通用户&lt;/span&gt; &lt;/template&gt;&lt;/el-table-column&gt; 实现两者的显示。 3）未登录状况下强制跳转登录（这里是对我负责的登录功能的优化） 在index.js: 123456789101112// 添加一个 beforeEach 路由守卫,这里用于实现未登录情况下强制跳转/loginrouter.beforeEach((to, from, next) =&gt; { // 检查 sessionStorage 中是否已经有 user let user = sessionStorage.getItem('user'); // 如果没有 user 且访问的不是登录界面，那么强制跳转至登录页面 if (!user &amp;&amp; to.path !== '/login'&amp;&amp; to.path !== '/register') { return next({ path: '/login' }); } // 否则就继续进行本次路由 next();}); 6.sql文件的整理上传，详见giteehealth_management.sql 7.README，详见giteeREADME.md 五.总结展望 这次作业前期准备断断续续用了快一个月，后面写项目差不多两周左右。使用多一点框架会在正式开发中快很多，但是想要知道怎么用还是要学不少知识的。我们每个人都写了前端后端，如果你看源码会发现4个人不同的代码风格。总的来说，这次大作业还是学到了很多东西，见证了项目一点点搭建起来，培养团队合作能力，也真的加强了自信”我们可以自己写原创项目”。 展望的话，我们以后可以实现更完整一点的项目，比如文件上传，更丰富的管理员功能，验证码，服务器部署等等。","link":"/2024/06/18/web%E5%BC%80%E5%8F%91/"},{"title":"W4terCTF2024 writeup","text":"纯小白，做出的题很少 图片很糊但就先这样吧队友：https://github.com/kuku172放个友链Lst4r-max.github.io Spam 2024先找垃圾邮件，搜了很多东西后找到spammimic - encoded，然后第一步解码： 159,6f,75,20,6c,69,6b,65,20,65,6d,6f,6a,69,73,2c,20,64,6f,6e,27,74,20,79,6f,75,3f,0a,0a,01f643,01f4b5,01f33f,01f3a4,01f6aa,01f30f,01f40e,01f94b,01f6ab,01f606,2705,01f606,01f6b0,01f4c2,01f32a,263a,01f6e9,01f30f,01f4c2,01f579,01f993,01f405,01f375,01f388,01f600,01f504,01f6ab,01f3a4,01f993,2705,01f4ee,01f3a4,01f385,01f34e,01f643,01f309,01f383,01f34d,01f374,01f463,01f6b9,01f923,01f418,01f3f9,263a,01f463,01f4a7,01f463,01f993,01f33f,2328,01f32a,01f30f,01f643,01f375,2753,2602,01f309,01f606,01f3f9,01f375,01f4a7,01f385,01f449,01f30a,01f6b9,01f6aa,01f374,01f60e,01f383,01f32a,01f643,01f441,01f94b,01f451,01f4a7,01f418,01f3a4,01f94b,01f418,01f6e9,01f923,01f309,01f6e9,23e9,01f60d,2753,01f418,01f621,2600,01f60d,01f643,01f601,01f600,01f601,01f6ab,01f4c2,2705,2603,01f6ab,01f60e,01f52a,01f451,01f600,01f579,01f6ab,01f60d,01f32a,01f4c2,01f44c,01f34d,01f44c,01f993,01f590,01f923,01f60e,01f3ce,01f34d,01f3f9,01f34c,01f34d,01f3a4,2600,01f3f9,01f388,01f6b0,01f4a7,2600,2709,01f3f9,01f34d,01f993,01f385,01f374,2602,23e9,01f6aa,01f40d,263a,01f418,01f607,01f621,01f375,01f30f,01f993,01f375,01f6e9,01f4c2,01f44c,01f3f9,01f5d2,01f5d2,0a,0a,42,74,77,2c,20,74,68,65,20,6b,65,79,20,69,73,20,22,4b,45,59,22 前后是ACSII，中间是emoji的unicode。 123456789101112def hex_to_ascii(hex_string): bytes_object = bytes.fromhex(hex_string) ascii_string = bytes_object.decode(&quot;ASCII&quot;) return ascii_stringhex_string1 = &quot;59,6f,75,20,6c,69,6b,65,20,65,6d,6f,6a,69,73,2c,20,64,6f,6e,27,74,20,79,6f,75,3f,0a,0a&quot;hex_string1 = hex_string1.replace(',', '')print(hex_to_ascii(hex_string1)) hex_string2 = &quot;0a,0a,42,74,77,2c,20,74,68,65,20,6b,65,79,20,69,73,20,22,4b,45,59,22&quot;hex_string2 = hex_string2.replace(',', '')print(hex_to_ascii(hex_string2)) 1234unicode_string =&quot;01f643,01f4b5,01f33f,01f3a4,01f6aa,01f30f,01f40e,01f94b,01f6ab,01f606,2705,01f606,01f6b0,01f4c2,01f32a,263a,01f6e9,01f30f,01f4c2,01f579,01f993,01f405,01f375,01f388,01f600,01f504,01f6ab,01f3a4,01f993,2705,01f4ee,01f3a4,01f385,01f34e,01f643,01f309,01f383,01f34d,01f374,01f463,01f6b9,01f923,01f418,01f3f9,263a,01f463,01f4a7,01f463,01f993,01f33f,2328,01f32a,01f30f,01f643,01f375,2753,2602,01f309,01f606,01f3f9,01f375,01f4a7,01f385,01f449,01f30a,01f6b9,01f6aa,01f374,01f60e,01f383,01f32a,01f643,01f441,01f94b,01f451,01f4a7,01f418,01f3a4,01f94b,01f418,01f6e9,01f923,01f309,01f6e9,23e9,01f60d,2753,01f418,01f621,2600,01f60d,01f643,01f601,01f600,01f601,01f6ab,01f4c2,2705,2603,01f6ab,01f60e,01f52a,01f451,01f600,01f579,01f6ab,01f60d,01f32a,01f4c2,01f44c,01f34d,01f44c,01f993,01f590,01f923,01f60e,01f3ce,01f34d,01f3f9,01f34c,01f34d,01f3a4,2600,01f3f9,01f388,01f6b0,01f4a7,2600,2709,01f3f9,01f34d,01f993,01f385,01f374,2602,23e9,01f6aa,01f40d,263a,01f418,01f607,01f621,01f375,01f30f,01f993,01f375,01f6e9,01f4c2,01f44c,01f3f9,01f5d2,01f5d2&quot;unicode_list = unicode_string.split(',')emoji_string = ''.join(chr(int('0x' + uni, 16)) for uni in unicode_list)print(emoji_string) 12You like emojis, don't you?Btw, the key is &quot;KEY&quot; 1🙃💵🌿🎤🚪🌏🐎🥋🚫😆✅😆🚰📂🌪☺🛩🌏📂🕹🦓🐅🍵🎈😀🔄🚫🎤🦓✅📮🎤🎅🍎🙃🌉🎃🍍🍴👣🚹🤣🐘🏹☺👣💧👣🦓🌿⌨🌪🌏🙃🍵❓☂🌉😆🏹🍵💧🎅👉🌊🚹🚪🍴😎🎃🌪🙃👁🥋👑💧🐘🎤🥋🐘🛩🤣🌉🛩⏩😍❓🐘😡☀😍🙃😁😀😁🚫📂✅☃🚫😎🔪👑😀🕹🚫😍🌪📂👌🍍👌🦓🖐🤣😎🏎🍍🏹🍌🍍🎤☀🏹🎈🚰💧☀✉🏹🍍🦓🎅🍴☂⏩🚪🐍☺🐘😇😡🍵🌏🦓🍵🛩📂👌🏹🗒🗒 找到下面的工具：emoji-aes 发现密钥的问题，试了KEY的unicode, ascii,等等，🔑的unicode，用KEY生成垃圾邮件，都失败了。找到正确的密钥🔑。解密结果是： 10x???? ⊕ dxBUQVJndGJbbGByE3tGUW57VxV0bH9db3FSe2YFUndUexVUYWl/QW1FAW1/bW57EhQSEF0= 这个字符串应该是被异或操作过的结果，找到正确的16进制数与其进行异或就能得到原始信息。下面是暴力破解来找出可能的结果。异或运算的一个特点是自反的，就是用同一个键进行两次异或操作就可以恢复原始信息。 1234567import base64cipher_text = base64.b64decode('dxBUQVJndGJbbGByE3tGUW57VxV0bH9db3FSe2YFUndUexVUYWl/QW1FAW1/bW57EhQSEF0=')for xor_key in range(0x10000): # 试验所有 0x0000 到 0xffff 的可能key plain_text = ''.join(chr(b ^ (xor_key &amp; 0xff)) for b in cipher_text) print(f'0x{xor_key:04x}: {plain_text}') 第一次的代码有点问题，遍历输出只发现了一个很像的数据。分析了下奇数位和偶数位异或的值是不一样的，0x？？？？看得出来是个四位十六进制，这个奇数位看起来基本是对的。改一下代码，然后一样遍历枚举，就找到flag了。 12345678import base64cipher_text = base64.b64decode('dxBUQVJndGJbbGByE3tGUW57VxV0bH9db3FSe2YFUndUexVUYWl/QW1FAW1/bW57EhQSEF0=')xor_key_even = 0xfe20for xor_key_odd in range(0x10000): plain_text = &quot;&quot;.join(chr(cipher_text[i] ^ ((xor_key_odd if i % 2 else xor_key_even) &amp; 0xff)) for i in range(len(cipher_text))) print(f'key_odd: 0x{xor_key_odd:04x}, deciphered message: {plain_text}') GZ GPTnc：乱码解决方案：乱码恢复 手动改乱码比较慢，就使用python的pwn库，并导入codecs模块（基础编解码功能）进行无限交互直至远程服务器终止。 1234567891011from pwn import *import codecsconn = remote('127.0.0.1', 50338)while True: data = conn.recv().decode('utf-8') gbk_data = data.encode('gbk') print(f&quot;接收到的数据：{data}&quot;) conn.interactive() conn.close() 看提示，应该是每次返回的有隐藏数据（想到去年的shadow，感觉这次输出光标也有奇怪的闪动）。确定了下每次输出后都有隐藏信息，这题是考隐写的。把终端输出复制过来看到vscode的提示： 然后去查一下锁定类型：零宽度字符隐写，并找到工具Unicode Steganography with Zero-Width Characters。用笨蛋方法一句句复制粘贴上去解码的，把每次的Hidden Text粘贴上去就得到完整的flag了。 broken.mp4解压后一个视频是完好的，打开看看，很明显的提示了，明显是在微信打开的嘛，去微信上搜搜标题，很好找到这篇文章链接然后去下载公众号上说的那个软件恢复一下就OK了 Sign In四道签到题的最后一个（晚上公选课无聊乱翻榜单看到的） Remember It 0第一次做pwn题，随便试试，签到题的话一般跟着做就行（主要是懒得想其他方法了）看源码，笨蛋方法没问题，就一步步敲的然后cat flag Shuffle Puts签到题，嗯，打开IDA直接看strings 总结小白第一次玩CTF还是挺开心的，感觉算是入了门。（一周前容器实例还不会开netcat还不会用的）。如果这周事情不那么多就好了，这周太忙了有效做题时间不多，很多方向都没学，基本上就是在做Misc了。","link":"/2024/05/03/writeup/"},{"title":"html+css+js基础","text":"html+css+js基础 html1123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;!--使用 &lt;meta&gt; 元素来描述HTML文档的描述，关键词，作者，字符集等--&gt; &lt;title&gt;菜鸟教程(unboob.com)&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;标题&lt;/h1&gt; &lt;h2&gt;标题&lt;/h2&gt; &lt;p&gt;段落&lt;/p&gt; &lt;a href=&quot;#section2&quot;&gt;跳转到第二部分&lt;/a&gt; &lt;br&gt; &lt;a href=&quot;https://www.runoob.com/html/html-basic.html&quot;&gt;链接&lt;/a&gt; &lt;br&gt; &lt;hr&gt; &lt;p&gt;hr标签在HTML页面中创建水平线&lt;/p&gt; &lt;hr&gt; &lt;!-- 注释 --&gt; &lt;p&gt;浏览器会自动地在段落的前后添加空行&lt;/p&gt; &lt;p&gt;这个是&lt;br&gt;分行&lt;/p&gt; &lt;hr&gt; &lt;b&gt;加粗&lt;/b&gt;&lt;br&gt;&lt;br&gt; &lt;strong&gt;加粗&lt;/strong&gt;&lt;br&gt;&lt;br&gt; &lt;big&gt;放大&lt;/big&gt; &lt;small&gt;缩小&lt;/small&gt; &lt;i&gt;斜体&lt;/i&gt;&lt;br&gt;&lt;br&gt; &lt;em&gt;斜体&lt;/em&gt;&lt;br&gt;&lt;br&gt; &lt;sub&gt;下标&lt;/sub&gt;&lt;sup&gt;上标&lt;/sup&gt; &lt;hr&gt; &lt;img src=&quot;https://www.runoob.com/images/logo.png&quot; width=&quot;258&quot; height=&quot;39&quot; /&gt; &lt;hr&gt; &lt;pre&gt;此例演示如何使用pre标签 对空行和 空格 进行控制 &lt;/pre&gt; &lt;hr&gt; &lt;p&gt;&lt;del&gt;删除&lt;/del&gt;&lt;ins&gt;插入&lt;/ins&gt;&lt;/p&gt; &lt;hr&gt; &lt;!-- 在页面中的某个位置 --&gt; &lt;p&gt;这个地方是跳转的第二部分&lt;a name=&quot;section2&quot;&gt;&lt;/a&gt;&lt;/p&gt; &lt;hr&gt; &lt;a href=&quot;https://www.runoob.com/&quot; target=&quot;_blank&quot;&gt;访问菜鸟教程!&lt;/a&gt; &lt;!--_self 在本页面打开--&gt; &lt;p&gt;如果你将 target 属性设置为 &amp;quot;blank&amp;quot;, 链接将在新窗口打开。&lt;/p&gt; &lt;hr&gt; &lt;a id=&quot;tips&quot;&gt;有用的提示部分&lt;/a&gt; &lt;a href=&quot;#tips&quot;&gt;访问有用的提示部分&lt;/a&gt; &lt;hr&gt; &lt;p&gt;无边框的图片链接: &lt;a href=&quot;http://www.runoob.com/html/html-tutorial.html&quot;&gt; &lt;img border=&quot;0&quot; src=&quot;smiley.gif&quot; alt=&quot;HTML 教程&quot; width=&quot;32&quot; height=&quot;32&quot;&gt;&lt;/a&gt;&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 21234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;style type=&quot;test/css&quot;&gt; body{ background-color: rgb(194, 194, 128); } p{ color: blueviolet; } &lt;/style&gt; &lt;link rel=&quot;shortcut icon&quot; href=&quot;https://csdiy.wiki/images/title.png&quot;&gt; &lt;!--带图片的标签--&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt; &lt;base href=&quot;https://www.runoob.com/images/&quot; target =&quot;_blank&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;img src =&quot;logo.png&quot; border=&quot;0&quot; alt=&quot;alt&quot; width=&quot;500&quot; height=&quot;100&quot;&gt; &lt;br&gt;&lt;br&gt; &lt;a href=&quot;https://www.runoob.com/images/&quot;&gt;菜鸟教程&lt;/a&gt; &lt;h1&gt;标题&lt;/h1&gt; &lt;p&gt;段落&lt;/p&gt; &lt;br&gt; &lt;a href=&quot;http://www.runoob.com/&quot; style=&quot;text-decoration:none;&quot;&gt;访问 runoob.com!&lt;/a&gt; &lt;!--没有下划线的链接--&gt; &lt;hr&gt; &lt;p&gt;内联样式&lt;/p&gt; &lt;p style=&quot;color:rgba(10, 254, 14, 0.221);margin-left:20px;&quot;&gt;段落&lt;/p&gt; &lt;hr&gt; &lt;body style=&quot;background-color: rgb(195, 161, 178);&quot;&gt; &lt;h2 style=&quot;background-color: blueviolet;&quot;&gt;标题&lt;/h2&gt; &lt;p style=&quot;background-color: aquamarine;&quot;&gt;段落&lt;/p&gt; &lt;/body&gt; &lt;hr&gt; &lt;h1 style=&quot;text-align: center;&quot;&gt;居中对齐&lt;/h1&gt; &lt;hr&gt; &lt;/body&gt;&lt;/html&gt; 3123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;测试&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;列标题1&lt;/th&gt; &lt;th&gt;列标题2&lt;/th&gt; &lt;th&gt;列标题3&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;行1,列1&lt;/td&gt; &lt;td&gt;行1,列2&lt;/td&gt; &lt;td&gt;行1,列3&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;行2,列1&lt;/td&gt; &lt;td&gt;行2,列2&lt;/td&gt; &lt;td&gt;行2,列3&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;hr&gt;&lt;p&gt; 每个表格从一个 table 标签开始。 每个表格行从 tr 标签开始。 每个表格的数据从 td 标签开始。 &lt;/p&gt; &lt;h4&gt;一列:&lt;/h4&gt; &lt;table border=&quot;1&quot;&gt; &lt;tr&gt; &lt;td&gt;100&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;h4&gt;一行三列:&lt;/h4&gt; &lt;table border=&quot;1&quot;&gt; &lt;tr&gt; &lt;td&gt;100&lt;/td&gt; &lt;td&gt;200&lt;/td&gt; &lt;td&gt;300&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;h4&gt;两行三列:&lt;/h4&gt; &lt;table border=&quot;1&quot;&gt; &lt;tr&gt; &lt;th&gt;Header 1&lt;/th&gt; &lt;th&gt;Header 2&lt;/th&gt; &lt;th&gt;Header 3&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;100&lt;/td&gt; &lt;td&gt;200&lt;/td&gt; &lt;td&gt;300&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;400&lt;/td&gt; &lt;td&gt;500&lt;/td&gt; &lt;td&gt;600&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt; &lt;hr&gt; &lt;h4&gt;单元格跨两列:&lt;/h4&gt;&lt;table border=&quot;1&quot;&gt;&lt;tr&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th colspan=&quot;2&quot;&gt;Telephone&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt; &lt;td&gt;Bill Gates&lt;/td&gt; &lt;td&gt;555 77 854&lt;/td&gt; &lt;td&gt;555 77 855&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;table&gt;&lt;/table&gt;&lt;/html&gt; 41234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;测试网页&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;h1&lt;/h1&gt;&lt;h2&gt;h2&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;form&gt; 生日: &lt;input type=&quot;text&quot;&gt;&lt;br&gt;年龄: &lt;input type=&quot;text&quot; &gt;&lt;/form&gt;&lt;form&gt;密码: &lt;input type=&quot;password&quot;&gt;&lt;/form&gt;&lt;form&gt;&lt;input type=&quot;radio&quot; &gt;China&lt;br&gt;&lt;input type=&quot;radio&quot; &gt;UK&lt;/form&gt;&lt;form&gt;&lt;input type=&quot;checkbox&quot;&gt;China&lt;br&gt;&lt;input type=&quot;checkbox&quot;&gt;UK&lt;/form&gt;&lt;form &gt;心情: &lt;input type=&quot;text&quot;&gt;&lt;input type=&quot;submit&quot; &gt;&lt;/form&gt;&lt;ol&gt;&lt;li&gt;你好&lt;/li&gt;&lt;li&gt;hello&lt;/li&gt; &lt;/ol&gt;&lt;ul&gt;&lt;li&gt;你好&lt;/li&gt;&lt;li&gt;hello&lt;/li&gt;&lt;/ul&gt; 51234567891011121314151617181920212223242526272829&lt;font color=&quot;&quot; size=&quot;&quot; face=&quot;&quot;&gt;&lt;/font&gt; &lt;!-- 字体 --&gt;&lt;h1&gt;&lt;/h1&gt; &lt;!--标题 --&gt;&lt;p&gt;&lt;/p&gt; &lt;!-- 段落 --&gt;&lt;b&gt;&lt;/b&gt; &lt;!--粗体--&gt;&lt;i&gt;&lt;/i&gt; &lt;!--斜体--&gt;&lt;hr&gt;&lt;!--下划线--&gt;&lt;br&gt;&lt;!--换行--&gt;&lt;img src=&quot;&quot; width=&quot;&quot; height=&quot;&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;!--type属性: circle: 空心圆; square: 实心正方形--&gt;&lt;!--无序列表标签--&gt;&lt;ul type=&quot;square&quot;&gt; &lt;li&gt;a&lt;/li&gt; &lt;li&gt;b&lt;/li&gt;&lt;/ul&gt;&lt;!--有序列表标签--&gt;&lt;!--start:起始索引(默认是1)type属性:1:阿拉伯数字; a:小写英文字母; A:大写英文字母; i:小写罗马数字; I:大写罗马数字--&gt;&lt;ol start=&quot;1&quot; type=&quot;1&quot;&gt; &lt;li&gt;乔丹&lt;/li&gt; &lt;li&gt;詹姆斯&lt;/li&gt;&lt;/ol&gt;&lt;!--超链接标签--&gt;&lt;!--target属性: 链接打开方式--&gt;&lt;a href=&quot;指定需要跳转的目标路径&quot; target=&quot;打开的方式&quot;&gt;需要展现给用户查看的内容&lt;/a&gt;&lt;!--假链接--&gt;&lt;a href=&quot;#&quot;&gt;假链接&lt;/a&gt; 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;table border=&quot;1px&quot; width=&quot;600px&quot; cellspacing=&quot;0px&quot; cellpadding=&quot;10px&quot; bgcolor=&quot;navajowhite&quot; align=&quot;center&quot;&gt;&lt;!--边框、宽度、单元格间距、单元格内边距、背景颜色和对齐方式--&gt;&lt;caption&gt;表格标题&lt;/caption&gt;&lt;tr&gt;&lt;th&gt;姓名&lt;/th&gt;&lt;th&gt;性别&lt;/th&gt;&lt;th&gt;地址&lt;/th&gt;&lt;/tr&gt;&lt;tr align=&quot;center&quot;&gt;&lt;td rowspan=&quot;2&quot;&gt;11&lt;/td&gt;&lt;td&gt;12&lt;/td&gt;&lt;td&gt;13&lt;/td&gt;&lt;/tr&gt;&lt;tr align=&quot;center&quot;&gt;&lt;td&gt;22&lt;/td&gt;&lt;td&gt;23&lt;/td&gt;&lt;/tr&gt;&lt;tr align=&quot;center&quot;&gt;&lt;td&gt;31&lt;/td&gt;&lt;td colspan=&quot;2&quot;&gt;32&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; table 中定义 tr, tr 中定义 td, td 中存放内容 6表单标签&lt;form&gt;&lt;/form&gt;输入类型 &lt;input&gt; 选择菜单 &lt;select&gt; 文本域 &lt;textarea&gt; input&lt;input type=&quot;xxx&quot;/&gt; text（默认） 文本框 password 密码框 radio 单选框：同一组单选框 name 属性相同 checkbox 复选框：同一组多选框 name 属性相同 file 文件选择框 date 日期选择框 hidden 隐藏域：向服务器提交数据，不在页面上展示出来 submit 提交按钮：内置提交表单的功能 button 普通按钮：不内置任何功能，需要在学习 js 之后给它绑定点击事件 reset 重置按钮：内置重置表单的功能 select12345678&lt;select name=&quot;&quot;&gt; &lt;!--如果option没有添加value属性，那么提交数据时就会提交选中的option标签体的内容--&gt; &lt;!--如果option添加了value属性，那么提交数据时就会提交选中的option标签体的value值--&gt; &lt;!--option标签通过selected属性设置默认选中--&gt; &lt;option value=&quot;&quot;&gt;显示的内容1&lt;/option&gt; &lt;option value=&quot;&quot;&gt;显示的内容2&lt;/option&gt;&lt;/select&gt; 显示的内容 1 显示的内容 2 textarea1&lt;textarea row=&quot;20&quot; cols=&quot;30&quot; name=&quot;introduce&quot;&gt;&lt;/textarea&gt; 如果表单项的数据需要提交给服务器，必须具备 name 属性同一组单选、多选框需要具备相同的 name输入框、密码框、文件选择框、日期选择框等等的 value 属性的值，就是你输入的值单选或多选框，默认 value 均为 on，所以我们需要手动给单选框和多选框设置 value readonly 属性：表示只读，数据可以向服务器提交disabled 属性：表示不可用, 数据无法向服务器提交placeholder 属性：表示输入提示checked 属性：单选和多选框也可以设置默认选中 7123456789&lt;a id=&quot;top&quot;&gt;&lt;/a&gt;&lt;a href=&quot;#top&quot;&gt;回到顶部&lt;/a&gt;&lt;a&gt;&lt;img src=&quot;./img/dog.jpg&quot;/&gt;&lt;br/&gt;&lt;/a&gt;&lt;details&gt; &lt;summary&gt;概要信息&lt;/summary&gt; 详情信息&lt;/details&gt; css层叠样式表 1. CSS 语法CSS 规则由选择器和声明块组成。 选择器：用于选择页面上的 HTML 元素。 声明块：包含多个 CSS 声明，每个声明定义元素的某个样式属性。 123选择器 { 属性名: 属性值;} 示例： 1234p { color: red; font-size: 16px;} 选择器：p（选择所有 &lt;p&gt; 元素） 声明块：color: red; 和 font-size: 16px;（将段落的文字颜色设为红色，字体大小设为 16 像素） 2. 将 CSS 添加到 HTML 中1. 内联样式（Inline CSS）直接在 HTML 元素的 style 属性中编写 CSS。适用于单个元素的样式定义。 1&lt;p style=&quot;color: blue; font-size: 20px;&quot;&gt;这是一个内联样式的段落。&lt;/p&gt; 2. 内部样式表（Internal CSS）将 CSS 代码写在 HTML 文档的 &lt;head&gt; 部分的 &lt;style&gt; 标签中。适用于单个页面的样式定义。 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;style&gt; p { color: green; font-size: 18px; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;这是一个内部样式表的段落。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 3. 外部样式表（External CSS）将 CSS 代码写在独立的 .css 文件中，并通过 &lt;link&gt; 标签引用。适用于多个页面共享样式。 123456789&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;styles.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;这是一个外部样式表的段落。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 在 styles.css 文件中： 1234p { color: purple; font-size: 22px;} 3. 选择器CSS 选择器用于选择特定的 HTML 元素，以应用样式。常见的选择器包括： 元素选择器：选择某种 HTML 元素。 1p { color: red; } /* 选择所有 &lt;p&gt; 元素 */ 类选择器：选择带有特定类的元素，类选择器以 . 开头。 1.intro { font-weight: bold; } /* 选择 class=&quot;intro&quot; 的元素 */ ID 选择器：选择具有特定 ID 的元素，ID 选择器以 # 开头。 1#main-title { color: blue; } /* 选择 id=&quot;main-title&quot; 的元素 */ 通用选择器：选择页面上的所有元素。 1* { margin: 0; padding: 0; } /* 清除所有元素的外边距和内边距 */ 后代选择器：选择嵌套在其他元素内的元素。 1div p { color: green; } /* 选择所有在 &lt;div&gt; 内的 &lt;p&gt; 元素 */ 属性选择器 :根据HTML元素的属性来选择元素，选择所有 type 属性为 text 的 &lt;input&gt; 元素。 123input[type=&quot;text&quot;] { background-color: yellow;} 以上是基本选择器，组合选择器只举一例： 后代选择器 : 选择某个元素的所有后代元素。 123div p { color: blue;} 4. CSS 属性一些常见的 CSS 属性如下： 颜色相关 color: 文本颜色。 background-color: 背景颜色。 1234h1 { color: blue; background-color: yellow;} 文本和字体 font-size: 字体大小。 font-family: 字体系列。 font-weight: 字体粗细（如 bold、normal）。 text-align: 文本对齐方式（如 left、right、center）。 12345p { font-size: 16px; font-family: Arial, sans-serif; text-align: center;} 布局相关 margin: 元素外边距。 padding: 元素内边距。 width: 宽度。 height: 高度。 123456div { margin: 20px; padding: 10px; width: 300px; height: 200px;} 边框 border: 边框样式，宽度、颜色和类型可以组合。 123img { border: 2px solid black;} 显示和定位 display: 定义元素的显示方式，如 block、inline、none。 position: 定义元素的定位方式，如 relative、absolute、fixed。 123456789.hidden { display: none;}.absolute-box { position: absolute; top: 50px; left: 100px;} 5. 层叠与优先级CSS 的 C（Cascading）代表“层叠”，它表示当多个样式同时作用于一个元素时，浏览器会按以下优先级规则决定使用哪个样式： 内联样式：直接写在元素内的样式，优先级最高。 ID 选择器：ID 选择器的样式优先级高于类选择器和元素选择器。 类选择器：类选择器的优先级高于元素选择器。 元素选择器：元素选择器的优先级最低。 如果多个样式有相同的优先级，后定义的样式会覆盖先定义的样式。 1234567p { color: red; /* 将会被覆盖 */}p { color: blue; /* 最终生效 */} 6. 响应式设计CSS 可以通过媒体查询来响应不同设备的屏幕大小。这样可以使网站在不同设备上（如手机、平板、桌面）表现良好。 12345@media screen and (max-width: 600px) { body { background-color: lightblue; }} 7. CSS 框模型（Box Model）每个 HTML 元素都被看作一个盒子，CSS 盒模型包含以下几个部分： 内容（content）：元素的内容。 内边距（padding）：内容周围的空白区域。 边框（border）：内边距外的边框。 外边距（margin）：边框外的空白区域。 123456div { width: 200px; padding: 10px; border: 5px solid black; margin: 20px;} 在这个例子中，div 的内容宽度是 200 px，内边距 10 px，边框 5 px，外边距 20 px。 8. 其他div是块级元素，会独占一行；span是行内元素，不会独占一行div中可以嵌套其它的标签，span标签中只能嵌套文本/图片/超链接 jsJavaScript 是一种广泛应用于网页开发的编程语言，通常用于增强用户交互、动态更新内容、表单验证、动画以及其他客户端功能。 1. JavaScript 的用途JavaScript 主要用于以下任务： 动态内容更新：可以根据用户交互修改网页内容，无需刷新整个页面。 表单验证：在用户提交表单之前，验证输入是否合法。 浏览器控制：可以控制浏览器的行为，比如弹出对话框、导航历史等。 事件驱动编程：响应用户的鼠标点击、键盘按键等操作。 动画和图形：通过 DOM 操作和 CSS 动画，JavaScript 可以实现丰富的视觉效果。 2. JavaScript 语法1. 基本语法JavaScript 是一种基于语句的语言，语句以分号 ; 结束（虽然不强制要求，但最好使用）。 变量声明：通过 var、let 或 const 声明变量。 var：有函数作用域，较老的变量声明方式。 let：有块作用域，适用于现代 JavaScript。 const：声明不可变的常量。 123var name = &quot;John&quot;; // 使用 var 声明变量let age = 30; // 使用 let 声明变量const city = &quot;Paris&quot;; // 使用 const 声明常量 2. 数据类型JavaScript 有六种基本的数据类型： 数字（Number）：整数和浮点数。 字符串（String）：用双引号或单引号括起来的文本。 布尔值（Boolean）：true 或 false。 未定义（Undefined）：未定义的变量。 空（Null）：表示空值。 对象（Object）：用于存储键值对或复杂数据结构。 12345let number = 42; // 数字let text = &quot;Hello, World!&quot;; // 字符串let isTrue = true; // 布尔值let notDefined; // 未定义变量let emptyValue = null; // 空值 3. 运算符JavaScript 提供了多种运算符来处理数据。 算术运算符：+（加）、-（减）、*（乘）、/（除）、%（取余）。 赋值运算符：=（赋值）、+=（加并赋值）、-=（减并赋值）等。 比较运算符：==（相等）、===（严格相等）、!=（不相等）、&gt;、&lt; 等。 逻辑运算符：&amp;&amp;（与）、||（或）、!（非）。 1234567let x = 10;let y = 5;console.log(x + y); // 输出 15console.log(x &gt; y); // 输出 trueconsole.log(x == &quot;10&quot;); // 输出 true (== 不检查类型)console.log(x === &quot;10&quot;); // 输出 false (=== 检查类型) 3. 条件语句条件语句用于根据条件执行不同的代码。 if… else 语句：根据条件执行不同的代码块。 1234567let age = 20;if (age &gt;= 18) { console.log(&quot;成人&quot;);} else { console.log(&quot;未成年&quot;);} switch 语句：用于对多个条件进行比较。 123456789101112let color = &quot;blue&quot;;switch (color) { case &quot;red&quot;: console.log(&quot;红色&quot;); break; case &quot;blue&quot;: console.log(&quot;蓝色&quot;); break; default: console.log(&quot;未知颜色&quot;);} 4. 循环JavaScript 提供了几种循环结构，用于重复执行某些代码。 for 循环：用于执行指定次数的循环。 123for (let i = 0; i &lt; 5; i++) { console.log(&quot;循环次数: &quot; + i);} while 循环：只要条件为 true，就会不断执行。 12345let i = 0;while (i &lt; 5) { console.log(&quot;循环次数: &quot; + i); i++;} do… while 循环：至少会执行一次，然后根据条件判断是否继续。 12345let i = 0;do { console.log(&quot;循环次数: &quot; + i); i++;} while (i &lt; 5); 5. 函数函数是用于封装可重复使用代码的块。可以通过定义函数来组织代码，并通过调用函数执行代码。 函数声明： 123456function greet(name) { return &quot;Hello, &quot; + name;}let message = greet(&quot;Alice&quot;);console.log(message); // 输出 &quot;Hello, Alice&quot; 函数表达式：可以将函数赋值给变量。 12345const sayHello = function(name) { return &quot;Hello, &quot; + name;};console.log(sayHello(&quot;Bob&quot;)); // 输出 &quot;Hello, Bob&quot; 箭头函数：ES 6 引入的一种简洁写法。 12const add = (a, b) =&gt; a + b;console.log(add(5, 3)); // 输出 8 箭头函数箭头函数（Arrow Function）是ES6中引入的一种更简洁的书写函数的方法。它使用 =&gt; 语法，通常用于简化匿名函数的书写方式。 简洁语法：箭头函数提供了一种更简洁的书写方式，尤其是针对简单函数。 this 绑定：箭头函数不创建自己的 this，而是**继承封闭上下文中的 this**。 不适合作为构造函数：箭头函数不能被用作构造函数，也没有 new 关键字的行为。 没有 arguments 对象：箭头函数没有 arguments 对象，但可以使用剩余参数语法来处理参数。箭头函数特别适合需要保留上下文 this 的场景，或需要编写简洁代码时的使用。 123456789101112// 传统函数表达式let traditionalFunction = function(a, b) { return a + b;};// 箭头函数let arrowFunction = (a, b) =&gt; { return a + b;};// 如果只有一行返回语句，可以省略花括号和`return`let arrowFunctionShort = (a, b) =&gt; a + b; 参数：如果只有一个参数，参数括号可以省略。 1let singleParam = x =&gt; x * 2; 没有参数时：必须使用空括号。 1let noParam = () =&gt; console.log('No parameters'); 箭头函数在处理 this 时有一个重要特性：它不会创建自己的 this，而是继承自定义它的上下文。这与传统的函数不同，传统函数的 this 取决于函数是如何调用的。 123456789101112131415161718function TraditionalFunction() { this.value = 1; setTimeout(function() { this.value++; console.log(this.value); // undefined，因为this在此指向全局对象（或undefined，取决于是否使用strict模式） }, 1000);}function ArrowFunction() { this.value = 1; setTimeout(() =&gt; { this.value++; console.log(this.value); // 2，因为箭头函数的this是继承自ArrowFunction中的this }, 1000);}new TraditionalFunction(); // 输出 NaN 或 undefinednew ArrowFunction(); // 输出 2 箭头函数与传统函数的另一个不同点是，箭头函数不能作为构造函数（即不能用 new 关键字来调用），而传统函数可以。 12345678let ArrowFunction = () =&gt; {};let TraditionalFunction = function() {};// 传统函数可以用new关键字创建实例let obj1 = new TraditionalFunction(); // 允许// 箭头函数不允许使用newlet obj2 = new ArrowFunction(); // 错误：ArrowFunction is not a constructor 传统函数有一个 arguments 对象，表示传递给函数的所有参数。箭头函数没有自己的 arguments，但可以通过剩余参数语法来获取参数。 1234567891011let traditionalFunction = function() { console.log(arguments);};traditionalFunction(1, 2, 3); // 输出：{0: 1, 1: 2, 2: 3}let arrowFunction = (...args) =&gt; { console.log(args);};arrowFunction(1, 2, 3); // 输出：[1, 2, 3] arguments对象arguments 对象是 JavaScript 中所有非箭头函数内置的一个类数组对象，包含了函数调用时传入的所有参数。它允许你访问传递给函数的参数，而不需要明确在函数声明中定义它们。 arguments 是一个类数组对象，包含了传给函数的所有参数。 它对处理不确定数量的参数非常有用。 arguments 在 ES 6 中已经被 ... 剩余参数语法部分取代，后者更灵活方便。 它不能在箭头函数中使用，在这种情况下，它会从外层上下文继承。arguments 对象虽然经典，但在现代 JavaScript 中，通常更推荐使用 剩余参数 (...rest) 来处理可变数量的参数，因为它提供了更清晰的语法和更强大的功能。 特点： 类数组对象： arguments 是一个类似数组的对象，它有 length 属性，但不是真正的数组，因此没有数组的方法（如 push, forEach 等）。然而，你可以通过索引来访问各个参数。 动态性： 无论函数定义了多少个参数，arguments 对象都会包含函数调用时传入的所有参数（即使传入的参数比函数声明的参数多或少）。 不可用于箭头函数： arguments 对象在箭头函数中不存在。箭头函数不会绑定自己的 arguments 对象，它会从它的封闭上下文中继承 arguments。 1234567function exampleFunction() { console.log(arguments); console.log(arguments[0]); // 访问第一个参数 console.log(arguments.length); // 参数个数}exampleFunction(1, &quot;Hello&quot;, true); 输出： 123[Arguments] { '0': 1, '1': 'Hello', '2': true }13 应用场景： 处理可变参数个数的函数：arguments 对象经常用于函数的参数个数不固定时，特别是在 ES 6 之前没有默认参数和剩余参数的场景下。 123456789function sum() { let total = 0; for (let i = 0; i &lt; arguments.length; i++) { total += arguments[i]; } return total;}console.log(sum(1, 2, 3, 4)); // 输出：10 与剩余参数对比：在 ES 6 引入的剩余参数（Rest Parameters）后，arguments 对象的使用有所减少。剩余参数可以将传入的参数作为一个真正的数组，而不是类数组对象，这更加方便。 **使用 arguments**： 12345678function multiply() { let result = 1; for (let i = 0; i &lt; arguments.length; i++) { result *= arguments[i]; } return result;}console.log(multiply(2, 3, 4)); // 输出：24 使用剩余参数： 1234function multiply(...args) { return args.reduce((product, current) =&gt; product * current, 1);}console.log(multiply(2, 3, 4)); // 输出：24 在这个例子中，...args 是一个真正的数组，可以直接使用数组方法如 reduce，而不需要像 arguments 那样手动迭代。 6. 事件和 DOM 操作在 JavaScript 中，事件 和 DOM 操作 是构建动态网页的核心。事件使网页能够对用户的交互（如点击、键盘输入等）作出响应，而 DOM（Document Object Model） 操作则允许 JavaScript 动态地更改网页的内容和结构。 事件：通过事件处理器监听用户行为（如点击、按键等），并通过 addEventListener() 绑定事件。事件对象可以提供详细的事件信息。 DOM 操作：允许我们动态地获取、修改、创建、删除页面中的 HTML 元素，进而实现动态的网页交互。 一、事件事件 是用户或浏览器执行的动作，例如鼠标点击、按键按下、窗口加载等。通过事件，我们可以使网页具有交互性。 常见事件类型 鼠标事件： click：当用户点击元素时触发。 dblclick：当用户双击元素时触发。 mouseover：当鼠标移到元素上时触发。 mouseout：当鼠标移出元素时触发。 mousedown / mouseup：鼠标按下和释放时触发。 键盘事件： keydown：按下键盘按键时触发。 keyup：释放按键时触发。 表单事件： submit：表单提交时触发。 change：表单元素的值发生变化时触发（如 &lt;input&gt;、&lt;select&gt;）。 窗口事件： load：页面加载完成时触发。 resize：浏览器窗口大小发生变化时触发。 scroll：当页面或元素滚动时触发。 事件处理器（Event Handlers） 事件处理器（或事件监听器）是指在特定事件发生时执行的函数。有三种常见的方式来添加事件处理器： 方法 1：HTML 内联事件处理 将 JavaScript 直接写在 HTML 元素的事件属性中。 1&lt;button onclick=&quot;alert('你点击了按钮!')&quot;&gt;点击我&lt;/button&gt; 方法 2：DOM 的 onEvent 属性 通过 JavaScript 设置元素的 onEvent 属性（例如 onclick）来添加事件处理。 1234let button = document.querySelector(&quot;button&quot;);button.onclick = function() { alert(&quot;按钮被点击了&quot;);}; 方法 3：addEventListener() 方法 这是推荐的方式，允许我们为同一事件添加多个事件处理器，并能更好地控制事件（如移除事件处理器等）。 1234let button = document.querySelector(&quot;button&quot;);button.addEventListener(&quot;click&quot;, function() { alert(&quot;按钮被点击了&quot;);}); 使用 addEventListener() 的好处： 可以为同一个元素添加多个事件监听器。 可以在需要时轻松移除事件处理器。 支持事件冒泡和捕获。 事件对象（Event Object） 当事件被触发时，浏览器会生成一个事件对象，该对象包含了与事件相关的详细信息，例如触发事件的元素、鼠标的坐标、按键状态等。 常用属性： target：事件触发的元素。 type：事件类型，如 click、keydown。 key：当处理键盘事件时，表示按下的键。 clientX / clientY：鼠标事件中，表示鼠标点击时的 X 和 Y 坐标。 123document.addEventListener(&quot;click&quot;, function(event) { console.log(&quot;点击位置 X: &quot; + event.clientX + &quot;，Y: &quot; + event.clientY);}); 事件传播模型 事件传播是指事件从触发源开始如何传播到其他相关元素。JavaScript 中有三种传播阶段： 捕获阶段：事件从文档的根元素向事件目标传播。 目标阶段：事件到达目标元素（触发事件的元素）。 冒泡阶段：事件从目标元素向上冒泡，经过其祖先元素。 事件监听器默认在冒泡阶段执行，但可以通过 addEventListener 的第三个参数将监听器绑定在捕获阶段。 123document.querySelector(&quot;div&quot;).addEventListener(&quot;click&quot;, function(event) { console.log(&quot;DIV 捕获阶段&quot;);}, true); // 第三个参数为 true，表示在捕获阶段执行 二、DOM 操作DOM（Document Object Model） 是网页的编程接口，表示页面的结构。通过 DOM，我们可以动态地修改、创建、删除页面中的元素，改变样式，响应用户交互等。 获取 DOM 元素获取元素: **getElementById()**：通过元素的 ID 获取元素。 1let element = document.getElementById(&quot;myElement&quot;); **getElementsByClassName()**：通过类名获取元素集合。 1let elements = document.getElementsByClassName(&quot;myClass&quot;); **getElementsByTagName()**：通过标签名获取元素集合。 1let elements = document.getElementsByTagName(&quot;p&quot;); **querySelector()**：通过 CSS 选择器获取第一个匹配的元素。 1let element = document.querySelector(&quot;.myClass&quot;); **querySelectorAll()**：通过 CSS 选择器获取所有匹配的元素。 1let elements = document.querySelectorAll(&quot;.myClass&quot;); 修改 DOM 元素 修改内容 **innerHTML**：更改元素的 HTML 内容。 12let div = document.getElementById(&quot;myDiv&quot;);div.innerHTML = &quot;&lt;p&gt;新内容&lt;/p&gt;&quot;; **textContent**：更改元素的纯文本内容（不会解析 HTML）。 12let div = document.getElementById(&quot;myDiv&quot;);div.textContent = &quot;新文本内容&quot;; 修改属性 **setAttribute()**：设置元素的属性。 12let img = document.querySelector(&quot;img&quot;);img.setAttribute(&quot;src&quot;, &quot;newImage.jpg&quot;); **removeAttribute()**：移除元素的属性。 12let img = document.querySelector(&quot;img&quot;);img.removeAttribute(&quot;alt&quot;); 直接修改属性：可以通过点语法直接修改元素的属性。 12let input = document.querySelector(&quot;input&quot;);input.type = &quot;password&quot;; 修改样式 可以通过 style 属性直接修改元素的内联样式： 123let div = document.getElementById(&quot;myDiv&quot;);div.style.color = &quot;blue&quot;;div.style.backgroundColor = &quot;yellow&quot;; 创建和删除元素 创建新元素 **createElement()**：创建一个新的 DOM 元素。12let newElement = document.createElement(&quot;div&quot;);newElement.textContent = &quot;这是一个新元素&quot;; 插入元素 **appendChild()**：将新元素添加为某个元素的子元素。 12let parentElement = document.getElementById(&quot;parent&quot;);parentElement.appendChild(newElement); **insertBefore()**：在指定子元素前插入新元素。 12let firstChild = parentElement.firstChild;parentElement.insertBefore(newElement, firstChild); 删除元素 **removeChild()**：从父元素中删除子元素。 123let parentElement = document.getElementById(&quot;parent&quot;);let child = document.getElementById(&quot;child&quot;);parentElement.removeChild(child); **remove()**：直接删除当前元素。 12let element = document.getElementById(&quot;myElement&quot;);element.remove(); 事件与 DOM 操作结合 通过事件处理和 DOM 操作的结合，我们可以构建动态交互的网页。例如，点击按钮后动态生成一个新的段落： 12345678910&lt;button id=&quot;addParagraph&quot;&gt;添加段落&lt;/button&gt;&lt;div id=&quot;content&quot;&gt;&lt;/div&gt;&lt;script&gt; document.getElementById(&quot;addParagraph&quot;).addEventListener(&quot;click&quot;, function() { let newParagraph = document.createElement(&quot;p&quot;); newParagraph.textContent = &quot;这是一个新段落&quot;; document.getElementById(&quot;content&quot;).appendChild(newParagraph); });&lt;/script&gt; 在这个示例中，点击按钮时，新的段落会动态添加到 div 中。 7. 数组和对象1. 数组：JavaScript 数组用于存储多个值。12let fruits = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;];console.log(fruits[1]); // 输出 &quot;banana&quot; push()：在数组末尾添加元素。 pop()：移除数组末尾的元素。 length：获取数组长度。 2. 对象：对象用于存储键值对，可以表示一个实体及其属性。12345678let person = { name: &quot;John&quot;, age: 30, city: &quot;New York&quot;};console.log(person.name); // 输出 &quot;John&quot;person.age = 31; // 修改对象属性 8. 异步编程JavaScript 提供了一些工具来处理异步操作，如请求数据或处理定时任务。它允许程序在等待较长时间的操作（如文件读取、网络请求）完成时，继续执行其他任务，而不必阻塞程序的执行流。 回调函数：函数可以作为参数传递到另一个函数中，在异步操作完成后执行。123setTimeout(function() { console.log(&quot;1秒后执行&quot;);}, 1000); 1234567891011function fetchData(callback) { setTimeout(() =&gt; { let data = &quot;数据加载完成&quot;; callback(data); // 异步任务完成后调用回调函数 }, 2000);}fetchData((result) =&gt; { console.log(result); // 输出 &quot;数据加载完成&quot;}); 但它存在一个问题，即回调地狱（Callback Hell）：当多个异步任务依赖于彼此时，回调函数会不断嵌套，代码难以维护和阅读。 Promise：用于处理异步操作的对象。 解决回调地狱：Promise 提供了链式调用 . then () 的方式，避免了多层嵌套的回调函数。 增强可读性：通过链式调用，代码逻辑更加线性和直观，易于理解。 错误处理机制：通过 . catch () 统一处理异步操作中的错误。 更灵活的异步控制：通过 Promise.all ()、Promise.race () 等方法，控制多个异步任务的执行方式。 1234567891011121314let promise = new Promise(function(resolve, reject) { let success = true; if (success) { resolve(&quot;操作成功！&quot;); } else { reject(&quot;操作失败！&quot;); }});promise.then(function(result) { console.log(result); // 输出 &quot;操作成功！&quot;}).catch(function(error) { console.log(error);}); Promise 是 JavaScript 中用于处理异步操作的对象，它提供了一种更优雅、简洁的方式来处理异步任务，避免了传统的回调函数（callback）方式容易导致的“回调地狱”（callback hell）问题。Promise 可以通过 .then() 和 .catch() 方法进行链式调用，并提供了错误处理机制。 Promise 是一个代表异步操作最终完成或失败的对象。它有三种状态： 待定（Pending）：异步操作尚未完成，Promise 还没有被解决或拒绝。 已解决（Fulfilled）：异步操作成功完成，Promise 被解决，返回结果。 已拒绝（Rejected）：异步操作失败，Promise 被拒绝，返回错误。 Promise 的基本语法 **resolve**：表示异步操作成功时调用，通常会传递成功的结果。 **reject**：表示异步操作失败时调用，通常会传递失败的原因或错误信息。 下面是一个使用 Promise 的简单示例，模拟一个异步任务（例如，从服务器获取数据）。 1234567891011121314151617181920let myPromise = new Promise(function(resolve, reject) { // 模拟一个耗时的异步操作，使用 setTimeout setTimeout(function() { let success = true; // 模拟成功或失败的条件 if (success) { resolve(&quot;数据获取成功&quot;); } else { reject(&quot;数据获取失败&quot;); } }, 2000);});// 使用 .then() 处理成功的结果，使用 .catch() 处理失败myPromise .then(function(result) { console.log(result); // 输出: &quot;数据获取成功&quot; }) .catch(function(error) { console.log(error); // 输出: &quot;数据获取失败&quot;（如果失败） }); 在这个例子中，myPromise 是一个 Promise 对象，它表示一个异步操作，模拟了 2 秒后异步任务的完成。根据 success 的值决定是否调用 resolve（成功）或 reject（失败）。我们可以使用 .then() 来处理成功的结果，使用 .catch() 来处理失败的情况。 Promise 状态转换Promise 的状态一旦从“待定”变为“已解决”或“已拒绝”，就不能再变更。这意味着： 如果 Promise 被解决（resolve），它的结果值就固定下来了，不会再变化。 如果 Promise 被拒绝（reject），它的错误信息也固定了。 无论 Promise 成功还是失败，它只会改变一次。 链式调用 .then() Promise 的一个强大特性是 .then() 方法可以链式调用。当一个异步操作成功完成并返回结果时，可以通过 .then() 来处理这个结果。如果 .then() 方法返回一个新的 Promise，那么可以继续链式调用后续的 .then()。 12345678910111213141516let promise = new Promise(function(resolve, reject) { setTimeout(() =&gt; resolve(10), 1000); // 1 秒后返回结果 10});promise .then(function(result) { console.log(result); // 输出: 10 return result * 2; // 返回新的值 20 }) .then(function(result) { console.log(result); // 输出: 20 return result * 3; // 返回新的值 60 }) .then(function(result) { console.log(result); // 输出: 60 }); 在这个例子中，每个 .then() 的返回值会传递给下一个 .then()，形成链式结构，依次处理结果。这种链式调用机制让异步操作之间的依赖关系更加清晰。 错误处理：.catch() 和 .finally() .catch() 方法.catch() 用于捕获 Promise 链中的错误。如果 Promise 被拒绝，或者在 .then() 中发生了错误，.catch() 都会捕获到这些错误。 1234567891011let promise = new Promise(function(resolve, reject) { setTimeout(() =&gt; reject(&quot;网络请求失败&quot;), 1000); // 模拟异步操作失败});promise .then(function(result) { console.log(result); // 不会被执行 }) .catch(function(error) { console.log(&quot;发生错误: &quot; + error); // 输出: &quot;发生错误: 网络请求失败&quot; }); .finally() 方法.finally() 无论 Promise 成功或失败，都会执行。它用于编写在 Promise 结束后都需要执行的逻辑，比如关闭加载动画或清理资源。 1234567891011121314let promise = new Promise (function (resolve, reject) { setTimeout (() =&gt; resolve (&quot;操作成功&quot;), 1000);});promise .then (function (result) { console.log (result); // 输出: 操作成功 }) .catch (function (error) { console.log (error); // 不会被执行 }) .finally (function () { console.log (&quot;操作结束&quot;); // 无论成功或失败，都会执行 }); Promise.all () 并行执行多个异步操作 Promise.all () 用于并行执行多个 Promise，等待所有 Promise 都成功后再返回。如果其中一个 Promise 被拒绝，整个 Promise.all () 都会被拒绝。 语法： 123456789Promise.all ([promise 1, promise 2, promise 3]) .then (function (results) { // 所有 Promise 都成功时执行 console.log (results); // 是一个包含每个 Promise 结果的数组 }) .catch (function (error) { // 只要有一个 Promise 被拒绝，执行此处 console.log (error); }); Promise.race ()：竞争模式 Promise.race () 类似于比赛，它会返回第一个解决或拒绝的 Promise，无论是成功还是失败。也就是说，它会返回最快执行的那个 Promise 的结果或错误。 1234567891011let promise 1 = new Promise ((resolve) =&gt; setTimeout (() =&gt; resolve (&quot;结果 1&quot;), 1000));let promise 2 = new Promise ((resolve) =&gt; setTimeout (() =&gt; resolve (&quot;结果 2&quot;), 500));let promise 3 = new Promise ((resolve) =&gt; setTimeout (() =&gt; resolve (&quot;结果 3&quot;), 1500));Promise.race ([promise 1, promise 2, promise 3]) .then (function (result) { console.log (result); // 输出: &quot;结果 2&quot; （因为它最快完成） }) .catch (function (error) { console.log (&quot;某个 Promise 失败&quot;, error); }); Promise.resolve () 和 Promise.reject () Promise.resolve ()Promise.resolve () 方法返回一个已解决的 Promise，可以快速返回一个成功的结果。 12345let promise = Promise.resolve (&quot;快速成功的结果&quot;);promise.then (function (result) { console.log (result); // 输出: 快速成功的结果}); Promise.reject ()Promise.reject () 方法返回一个已拒绝的 Promise，用于快速返回一个失败的结果。 示例： 12345let promise = Promise.reject (&quot;快速失败的原因&quot;);promise.catch (function (error) { console.log (error); // 输出: 快速失败的原因}); async/await：基于 Promise的语法糖，使异步代码更加直观。async 用于声明一个异步函数，而 await 用于等待一个异步操作完成。使用 await 可以让代码看起来像是同步执行的，避免了复杂的 then 链式调用，提升了代码的可读性。 async 函数会返回一个 Promise 对象。 await 只能在 async 函数中使用，它会暂停函数的执行，等待 Promise 完成。123456async function fetchData() { let response = await fetch(&quot;https://api.example.com/data&quot;); let data = await response.json(); console.log(data);}fetchData(); 1234567891011async function fetchData(){try{ let result1=await asyncTask1(); let result2=await asyncTask2(result1); let result3=await asyncTask3(result2); console.log(&quot;所有任务完成&quot;,result3);}catch(error){ console.log(&quot;任务失败&quot;,error);}}fetchData(); 12345678async function myFunction(){ let promise=new Promise((resolve,reject)=&gt;{ setTimeout(()=&gt;resolve(&quot;数据已获取&quot;),2000); }); let result =await promise; console.log(result);}myFunction(); 常见的异步操作 定时器：如 setTimeout 和 setInterval，用于延时和周期性任务。 网络请求：如 fetch 或 XMLHttpRequest，用于异步数据加载。 文件操作：在Node.js中，文件系统操作通常是异步的。","link":"/2024/10/05/%E5%89%8D%E7%AB%AF%E4%B8%89%E4%BB%B6%E5%A5%97/"},{"title":"后端常用注解","text":"目前后端只会java Spring Boot核心注解 @SpringBootApplication: 用于标记主类，表示这是一个 Spring Boot 应用程序。这个注解组合了 @Configuration、@EnableAutoConfiguration 和 @ComponentScan。 依赖注入和控制反转 @Component: 表示一个类是 Spring 的组件，它是任何 Spring 管理组件的通用注解。 @Service: 用于服务层（业务逻辑层）的类。 @Repository: 用于数据访问层（DAO 层）的类。 @Controller: 用于标记控制器类，用于处理 HTTP 请求。 @RestController: 是 @Controller 和 @ResponseBody 的组合，用于创建 RESTful 控制器。 @RequestMapping: 用于映射 HTTP 请求到控制器的处理方法。 @Autowired: 用于自动装配 bean。 @Qualifier: 与 @Autowired 一起使用，用于指定需要注入的 bean 的名称。 @Resource: 另一种用于自动装配的方式，可以通过名称或类型进行注入。 配置类相关 @Configuration: 表示一个类作为配置类，用于定义 bean。 @Bean: 在配置类中，用于标记方法，将方法的返回值定义为一个 bean。 @EnableAutoConfiguration: 告诉 Spring Boot 根据类路径设置、其他 bean 和各种属性设置自动配置应用。 条件注解 @Conditional: 表示只有在特定条件满足时才创建 bean。 @Profile: 用于指定某些 bean 只在特定的 Spring Profile 激活时才创建。 数据访问 @Transactional: 声明一个方法或类需要事务管理。 @EnableTransactionManagement: 启用注解驱动的事务管理。 Web 相关 @GetMapping, @PostMapping, @PutMapping, @DeleteMapping: 分别用于处理 HTTP GET, POST, PUT, DELETE 请求的快捷方式。（请求，提交，更新，删除） @PathVariable: 用于将请求 URL 中的模板变量映射到功能处理方法的参数上。 @RequestParam: 用于将请求参数区数据映射到功能处理方法的参数上。 @RequestBody: 用于读取 Request 请求的 body 部分数据，使用系统默认配置的 HttpMessageConverter 进行解析，然后把相应的数据绑定到要返回的对象上。 @ResponseBody: 表示该方法的返回结果直接写入 HTTP 响应正文（ResponseBody）中。 其他 @EventListener: 用于标记方法，这些方法会在 Spring 上下文中某些事件发生时被调用。 @Scheduled: 用于标记方法，这些方法会按照指定的计划执行。 Lombok 常用注解 @Data: 自动生成 getter、setter、toString、equals 和 hashCode 方法。 @NoArgsConstructor: 自动生成无参构造函数。 @AllArgsConstructor: 自动生成全参构造函数。 @RequiredArgsConstructor: 自动生成包含必须属性（用 final 修饰的属性）的构造函数。 @Getter: 自动生成 getter 方法。 @Setter: 自动生成 setter 方法。 @ToString: 自动生成 toString 方法。 @EqualsAndHashCode: 自动生成 equals 和 hashCode 方法。 @Slf4j: 自动生成日志变量，通常是 log。 @Log: 自动生成日志变量，适用于各种日志框架。 @Builder: 自动生成构建器模式的支持。 @Value: 自动生成不可变类，即所有字段都是 final 的，并提供 getter 方法，但不提供 setter 方法。 @SneakyThrows: 自动处理受检异常（checked exceptions）。 MyBatis-Plus 常用注解 @TableName: 指定实体类对应的数据库表名。 @TableId: 指定实体类中主键的字段。 @TableField: 指定实体类中非主键的字段，可以配置字段名与数据库列名之间的映射关系。 @TableLogic: 用于配置逻辑删除字段。 @Version: 用于配置乐观锁版本号字段。 @Mapper: 表示这是一个 MyBatis 的 Mapper 接口，MyBatis-Plus 会自动生成相应的实现类。 @MapperScan: 用于扫描 Mapper 接口所在的包，这样就不需要在每个 Mapper 接口上使用 @Mapper 注解。 @SqlParser: 用于指定 MyBatis-Plus 的 SQL 解析器。 @KeySequence: 用于指定主键序列（如果数据库支持序列作为主键）。","link":"/2024/10/28/%E5%90%8E%E7%AB%AF%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/"},{"title":"算法","text":"初级算法 - LeetBook - 力扣（LeetCode） 数组 删除排序数组中的重复项给你一个非严格递增排列的数组 nums ，请你原地删除重复出现的元素，使每个元素只出现一次，返回删除后数组的新长度。元素的相对顺序应该保持一致。然后返回 nums 中唯一元素的个数。 考虑 nums 的唯一元素的数量为 k ，你需要做以下事情确保你的题解可以被通过： 更改数组 nums ，使 nums 的前 k 个元素包含唯一元素，并按照它们最初在 nums 中出现的顺序排列。nums 的其余元素与 nums 的大小不重要。返回 k 。 双指针解题 12345678910111213141516171819class Solution{public:int removeDuplicates(vector&lt;int&gt;&amp; nums){ int n=nums.size(); if(n=0){ return 0; } int fast=1,slow=1; while(fast&lt;n){ if(nums[fast]!=nums[fast-1]){ nums[slow]=nums[fast]; ++slow; } ++fast; } return slow;}}; 买卖股票的最佳时机 II给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。 在每一天，你可以决定是否购买和/或出售股票。你在任何时候最多只能持有一股股票。你也可以先购买，然后在同一天出售。 返回你能获得的最大利润。 12345678910111213class Solution{public: int maxProfit(vector&lt;int&gt;&amp;prices){ int n=prices.size(); int tot=0; for(int i=1;i&lt;n;i++){ if(prices[i]&gt;price[i-1]){ tot+=price[i]-price[i-1]; } } return tot; }}; 旋转数组 给定一个整数数组 nums，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。 使用一个新的数组 123456789101112131415161718class Solution{public: void rotate(vector&lt;int&gt;&amp;nums,int k){ int len=nums.size(); k=k%len; vector&lt;int&gt;res(len); //将后k个元素移到前面 for(int i=0;i&lt;k;i++){ res[i]=nums[len-k+i]; } //将前len-k个元素移到后面 for(int i=0;i&lt;len-k;i++){ res[k+i]=nums[i]; } //将结果复制回nums nums=res; }};也可以这样 1234567891011class Solution{public: void rotate(vector&lt;int&gt;&amp;nums,int k){ int n=nums.size(); vector&lt;int&gt;newArr(n); for(int i=0;i&lt;n;i++){ newArr[(i+k)%n]=nums[i]; } nums.assign(newArr.begin(),newArr.end()); }}; 存在重复元素给你一个整数数组 nums 。如果任一值在数组中出现 至少两次 ，返回 true ；如果数组中每个元素互不相同，返回 false 。题解：考虑排序，排序后数组的重复元素一定出现在相邻位置中 12345678910111213class Solution {public: bool containsDuplicate(vector&lt;int&gt;&amp; nums) { sort(nums.begin(),nums.end()); int n=nums.size(); for(int i=0;i&lt;n-1;i++){ if(nums[i]==nums[i+1]){ return true; } } return false;}; 只出现一次的数字 给你一个非空整数数组 nums ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。 第一次的解法（没有考虑线性时间复杂度）这么写是因为收到前面思路的影响 1234567891011121314151617181920212223242526272829303132class Solution {public: int singleNumber(vector&lt;int&gt;&amp; nums) { sort(nums.begin(), nums.end()); int n = nums.size(); // 如果数组只有一个元素，直接返回 if (n == 1) { return nums[0]; } // 检查第一个元素是否是唯一的 if (nums[0] != nums[1]) { return nums[0]; } // 检查最后一个元素是否是唯一的 if (nums[n - 1] != nums[n - 2]) { return nums[n - 1]; } // 从第二个元素到倒数第二个元素进行检查 for (int i = 1; i &lt; n - 1; i++) { if (nums[i] != nums[i - 1] &amp;&amp; nums[i] != nums[i + 1]) { return nums[i]; } } return -1; }}; 如果要考虑线性时间复杂度 O (n): 12345678910111213141516171819class Solution {public: int singleNumber(vector&lt;int&gt;&amp; nums) { int result = 0; for (int num : nums) { result ^= num; } return result; }}; 这个异或解法的时间复杂度是 O(n)，空间复杂度是 O(1)考虑线性时间复杂度和常量空间复杂度：异或运算异或运算有以下性质： a ^ a = 0（任何数与自己异或的结果是0） a ^ 0 = a（任何数与0异或的结果是这个数本身） 异或运算满足交换律和结合律。 因此，如果数组中除了一个数以外其他数都出现两次，那么将所有数进行异或运算，结果就是那个只出现一次的数。 ps: 复习位运算的规律：（相同为０不同为１）1^1=0;1^0=1;0^1=1;0^0=0;6. 两个数组的交集Ⅱ 给你两个整数数组 nums 1 和 nums 2 ，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。法一：哈希表遍历第一个数组，在哈希表中记录第一个数组中每个数字以及出现的次数，然后遍历第二个数组，如果哈希表中存在这个数字，将这个数字添加到答案，并减少哈希表中该数字出现的次数。 123456789101112131415161718192021222324class Solution{public: vector&lt;int&gt;intersect(vector&lt;int&gt;&amp;nums1,vector&lt;int&gt;&amp;nums2){ if(nums1.size()&gt;nums2.size()){ return intersect(nums2,nums1); } unordered_map&lt;int,int&gt;m; for(int num:nums1){ ++m[num]; } vector&lt;int&gt;intersection; for(int num:nums2){ if(m.count(num)){ intersection.push_back(num); --m[num]; if(m[num]==0){ m.erase(num); } } } return intersection; }}","link":"/2024/09/14/%E6%89%93%E5%8D%A1%E8%B4%B4/"}],"tags":[{"name":"unity","slug":"unity","link":"/tags/unity/"},{"name":"c#","slug":"c","link":"/tags/c/"},{"name":"cpp","slug":"cpp","link":"/tags/cpp/"},{"name":"docker","slug":"docker","link":"/tags/docker/"},{"name":"web","slug":"web","link":"/tags/web/"},{"name":"springboot","slug":"springboot","link":"/tags/springboot/"},{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"mysql","slug":"mysql","link":"/tags/mysql/"},{"name":"ctf","slug":"ctf","link":"/tags/ctf/"},{"name":"前端三件套","slug":"前端三件套","link":"/tags/%E5%89%8D%E7%AB%AF%E4%B8%89%E4%BB%B6%E5%A5%97/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"}],"categories":[{"name":"游戏开发","slug":"游戏开发","link":"/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"},{"name":"STL","slug":"STL","link":"/categories/STL/"},{"name":"web开发","slug":"web开发","link":"/categories/web%E5%BC%80%E5%8F%91/"},{"name":"CTF","slug":"CTF","link":"/categories/CTF/"},{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"}],"pages":[{"title":"about","text":"关于我：人工智能专业大二在读。正在努力学东西。","link":"/about/index.html"}]}