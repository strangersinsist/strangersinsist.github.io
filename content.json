{"posts":[{"title":"Unity2D小游戏","text":"演示视频","link":"/2024/07/19/Unity2D/"},{"title":"CPP-STL","text":"参考教程： cpp-STL - AlgorithmPark基本上是转载，跟着写了一遍理思路。 1. vector 容器头文件 #include&lt;vector&gt; (1)构造12345678910111213#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;vector&lt;int&gt;b;vector&lt;int&gt;a(10);vector&lt;int&gt;a(10,1);//10个整型元素的向量，每个值为1vector&lt;int&gt;a(b);//用向量b给a赋值vector&lt;int&gt;a(b.begin(),b.begin()+3);//将b中0-2个元素赋值给aint c[7]={1,2,3,4,5,6,7};vector&lt;int&gt;a(c,c+7);vector&lt;int&gt;a{1,2,3,4,5,6,7};vector&lt;int&gt;a={1,2,3,4,5,6,7}; (2)基本操作1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465void test01()//基本操作 { vector&lt;int&gt; a, b; int i=0; //b为向量，将b的0-2个元素赋值给向量a a.assign(b.begin(), b.begin() + 3); //a含有4个值为2的元素 a.assign(4, 2); //返回a的最后一个元素 a.back(); //返回a的第一个元素 a.front(); //返回a的第i元素,当且仅当a存在 a[i]; //清空a中的元素 a.clear(); //判断a是否为空，空则返回true，非空则返回false a.empty(); //删除a向量的最后一个元素 a.pop_back(); //删除a中第一个（从第0个算起）到第二个元素，也就是说删除的元素从a.begin()+1算起（包括它）一直到a.begin()+3（不包括它）结束 a.erase(a.begin() + 1, a.begin() + 3); //在a的最后一个向量后插入一个元素，其值为5 a.push_back(5); //在a的第一个元素（从第0个算起）位置(前面)插入数值5, a.insert(a.begin() + 1, 5); //在a的第一个元素（从第0个算起）位置（前面）插入3个数，其值都为5 a.insert(a.begin() + 1, 3, 5); //d为数组，在a的第一个元素（从第0个元素算起）的位置（前面）插入b的第三个元素到第5个元素（不包括b+6） int d[8]; a.insert(a.begin() + 1, d + 3, d + 6); //返回a中元素的个数 a.size(); //返回a在内存中总共可以容纳的元素个数 a.capacity(); //将a的现有元素个数调整至10个，多则删，少则补，其值随机 a.resize(10); //将a的现有元素个数调整至10个，多则删，少则补，其值为2 a.resize(10, 2); //将a的容量扩充至100， a.reserve(100); //b为向量，将a中的元素和b中的元素整体交换 a.swap(b); //b为向量，向量的比较操作还有 != &gt;= &gt; &lt;= &lt; a == b; } assign 赋值 insert 插入 resize 调整 reserve 扩充 (3)反向迭代12345678void test02(){ vector&lt;int&gt;a={1,2,3,4,5,6,7,8,9,10}; for(vector&lt;int&gt;::reverse_iterator iter=a.rbegin();iter!=a.rend();iter++) { cout&lt;&lt;*iter&lt;&lt;endl;//10 9 8 7 6 5 4 3 2 1 }} (4)插入 描述 函数签名 插入位置都在 pos 迭代器之前一个位置，返回的迭代器指向插入的第一个元素 在迭代器 pos 指定的位置之前插入一个新元素 elem，并返回表示新插入元素位置的迭代器 iterator insert(pos, elem) 在迭代器 pos 指定的位置之前插入 n 个元素 elem，并返回表示第一个新插入元素位置的迭代器 iterator insert(pos, n, elem) 在迭代器 pos 指定的位置之前，插入其他容器中位于 [first, last) 区域的所有元素，并返回表示第一个新插入元素位置的迭代器 iterator insert(pos, first, last) 在迭代器 pos 指定的位置之前，插入初始化列表（用大括号 {} 括起来的多个元素），中间有逗号隔开）中的所有的元素，并返回表示第一个新插入元素位置的迭代器 iterator insert(pos, initlist) 123456789101112void test03(){ vector&lt;int&gt;a={1,2,3,4,5,6,7,8,9,10}; vector&lt;int&gt;::iterator it1=a.begin()+4; vector&lt;int&gt;::iterator it2=a.insert(it1,{-1,-2,-3}); cout&lt;&lt;*it2&lt;&lt;endl;//-1,并返回表示第一个新插入元素位置的迭代器 for(auto k:a) { cout&lt;&lt;k&lt;&lt;&quot; &quot;;//1 2 3 4 -1 -2 -3 5 6 7 8 9 10 } cout&lt;&lt;endl;} (5) 函数 说明 pop_back() 删除 vector 容器中最后一个元素，该容器的大小（size）会减 1，但容量 (capacity) 不会发生改变。 erase(pos) 删除 vector 容器中 pos 迭代器指定位置处的元素，并返回指向被删除元素下一个位置的迭代器。该容器的大小 (size) 会减 1，但容量 (capacity) 不会发生改变。 ???swap(beg)、pop_back () 先调用 swap() 函数交换要删除的目标元素和容器最后一个元素的位置，然后使用 pop_back () 删除该目标元素。 erase(beg,end) 删除 vector 容器中位于迭代器 [beg, end) 指定区域内的所有元素，并返回指向被删除区域下一个位置元素的迭代器。该容器的大小 (size) 会减小，但容量 (capacity) 不会发生改变。 remove() 删除容器中所有和指定元素值相等的元素，并返回指向最后一个元素下一个位置的迭代器。值得一提的是，调用该函数不会改变容器的大小和容量。 clear() 删除 vector 容器中所有的元素，使其变成空的 vector 容器。该函数会改变 vector 的大小 (变为 0)，但不是改变其容量。 12345678910111213141516171819void test04(){ vector&lt;int&gt;a = { 1,2,3,4,5,6,6,6,6,7,8,9,10 }; int size = a.size(); ptrdiff_t cnt = count(a.begin(), a.end(), 6);//ptrdiff==long long，用于计算6出现的次数 auto it = remove(a.begin(), a.end(), 6);//移除所有的6，不会改变容器的大小和容量，只是覆盖 cout &lt;&lt; *it &lt;&lt; endl;//7，remove 返回的迭代器 it 指向 7，也就是第一个不为 6 的元素之后的新尾部。 cout &lt;&lt; cnt &lt;&lt; endl;//4 for (auto k : a) { cout &lt;&lt; k &lt;&lt; &quot; &quot;;//1 2 3 4 5 7 8 9 10 7 8 9 10 } cout &lt;&lt; endl; a.resize(size - cnt);//调整向量大小，除去末尾的6 for (auto k : a) { cout &lt;&lt; k &lt;&lt; &quot; &quot;;//1 2 3 4 5 7 8 9 10 }} 2.deque 容器头文件 #include&lt;deque (1)遍历容器12345678910void printdeque(const deque&lt;int&gt;&amp; d){ for(deque&lt;int&gt;::const_iterator it=d.begin();it!=d.end();it++) //注意迭代器也要换成带const的 { cout&lt;&lt;*it&lt;&lt;&quot; &quot;; //加const后容器中数据不可修改 } cout&lt;&lt;endl;} (2)构造容器1234567891011121314void test01() { deque&lt;int&gt;d1; for (int i = 0; i &lt; 10; i++) d1.push_front(i+1); printdeque(d1); //区间赋值 deque&lt;int&gt;d2(d1.begin(), d1.end()); printdeque(d2); deque&lt;int&gt;d3(10, 100); printdeque(d3); deque&lt;int&gt;d4(d3); printdeque(d4); } 程序输出： 123410 9 8 7 6 5 4 3 2 1 10 9 8 7 6 5 4 3 2 1 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 (3)赋值操作123456789101112131415161718192021void test03(){ deque&lt;int&gt;d1; for(int i=0;i&lt;10;i++) { d1.push_back(i+1); } printdeque(d1); //operator=赋值 deuqe&lt;int&gt;d2; d2=d1; printdeque(d2); //assign赋值 deque&lt;int&gt;d3; d3.assgin(d1.begin(),d1.end()); printdeque(d3); deque&lt;int&gt;d4; d4.assign(10,100); printdeque(d4); } 程序输出： 12341 2 3 4 5 6 7 8 9 10 1 2 3 4 5 6 7 8 9 10 1 2 3 4 5 6 7 8 9 10 100 100 100 100 100 100 100 100 100 100 (4)插入和删除1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;iostream&gt;#include &lt;deque&gt;using namespace std;// 打印 deque 的内容void printDeque(const deque&lt;int&gt;&amp; d) { for (int elem : d) { cout &lt;&lt; elem &lt;&lt; &quot; &quot;; } if (d.empty()) { cout &lt;&lt; &quot;(empty)&quot;; } cout &lt;&lt; endl;}void testDequeOperations() { deque&lt;int&gt; d; // 1. 头部插入 d.push_front(10); // 在头部插入 10 d.push_front(20); // 在头部插入 20 d.push_front(30); // 在头部插入 30 printDeque(d); // 输出: 30 20 10 // 2. 尾部插入 d.push_back(40); // 在尾部插入 40 d.push_back(50); // 在尾部插入 50 printDeque(d); // 输出: 30 20 10 40 50 // 3. 任意位置插入 d.insert(d.begin() + 2, 100); // 在第三个位置插入 100 d.insert(d.end() - 1, 2, 200); // 在倒数第二个位置插入两个 200 printDeque(d); // 输出: 30 20 100 10 40 200 200 50 // 4. 头部删除 d.pop_front(); // 删除头部元素 printDeque(d); // 输出: 20 100 10 40 200 200 50 // 5. 尾部删除 d.pop_back(); // 删除尾部元素 printDeque(d); // 输出: 20 100 10 40 200 200 // 6. 任意位置删除 d.erase(d.begin() + 1); // 删除第二个位置上的元素 printDeque(d); // 输出: 20 10 40 200 200 // 删除一个范围内的元素 d.erase(d.begin() + 2, d.end() - 1); // 删除第三个到倒数第二个元素 printDeque(d); // 输出: 20 10 200 // 清空整个 deque d.clear(); printDeque(d); // 输出: (empty)}int main() { testDequeOperations(); return 0;} } (5)数据存取1234567deque d1;d1[2];d1.at(2);//d1的第二个元素d1.front();d1.back();//访问d1的首尾元素 3. stack 容器头文件 #include&lt;stack&gt;后进先出 12345678910111213141516void test01(){ stack&lt;int&gt;s; s.push(10); s.push(20); s.push(30); s.push(40); int n=s.size(); for(int i=0;i&lt;n;i++) { cout&lt;&lt;s.top()&lt;&lt;&quot; &quot;;//40 30 20 10 s.pop(); //访问top后出栈 } cout&lt;&lt;endl;} 4. queue 容器头文件 #include&lt;queue&gt;先进先出 1234567891011121314151617181920212223242526272829303132333435#include&lt;queue&gt;using namespace std;void testqueue(){ queue&lt;int&gt;q; q.push(10); q.push(20); q.push(30); //创建一个temp用于打印元素 queue&lt;int&gt;temp=q; while(!q.empty()) { cout&lt;&lt;temp.front()&lt;&lt;&quot; &quot;;//输出队首元素 q.pop();//弹出队首元素 } cout&lt;&lt;endl; //获取队首尾元素 cout&lt;&lt;q.front()&lt;&lt;q.back()&lt;&lt;endl; cout&lt;&lt;q.empty()&lt;&lt;endl; cout&lt;&lt;q.size()&lt;&lt;endl; //清空队列 while(!q.empty()) { q.pop(); }}int main(){ testqueue(); return 0;} 5. string 容器(1)构造123456789101112void test01{ string s1; cout&lt;&lt;&quot;s1=&quot;&lt;&lt;s1&lt;&lt;endl; const char* str= &quot;hello world!&quot;//C风格的字符串str初始化为C++的string类型对象s2 string s2(str); cout&lt;&lt;&quot;s2=&quot;&lt;&lt;s2&lt;&lt;endl; string s3(s2); cout&lt;&lt;&quot;s3=&quot;&lt;&lt;s3&lt;&lt;endl; string s4(10,'b');//使用n个字符b初始化 cout&lt;&lt;&quot;s4=&quot;&lt;&lt;s4&lt;&lt;endl;} 1234s1= s2=hello world! s3=hello world! s4=bbbbbbbbbb (2)赋值123456789101112131415161718void test01{ string str1; str1=&quot;hello world!&quot;; cout&lt;&lt;&quot;str1=&quot;&lt;&lt;str1&lt;&lt;endl; string str2=str1; cout&lt;&lt;&quot;str2=&quot;&lt;&lt;str2&lt;&lt;endl; string str4; str4.assign(&quot;hello&quot;); cout&lt;&lt;&quot;str4=&quot;&lt;&lt;str4&lt;&lt;endl; string str5; str5.assign(&quot;hello&quot;,3);//将前3个字符赋值给str5 cout&lt;&lt;&quot;str5=&quot;&lt;&lt;str5&lt;&lt;endl; string str6; str6.assign(str5); string str7; str7.assign(10,'w');} (3)拼接1234567891011string s1=&quot;你&quot;;s1+=&quot;好&quot;;string s2=&quot;我也爱C语言&quot;;//s1.append(&quot;hello&quot;);//s1.append(&quot;you&quot;,2);//s1.append(s2); 、s1.append(s2,4,7);//从str2的第三个字符开始，截取4个加在末尾，第二个参数为起始字符的位置(位置从0开始计算)，第三个参数为字符的长度 //中文字符占2个位置，英文字符占1个位置cout&lt;&lt;&quot;s1=&quot;&lt;&lt;s1&lt;&lt;endl;//你好爱C语言 &quot;我&quot;（索引 0，长度 1）占两个字节。 &quot;也&quot;（索引 1，长度 1）占两个字节。 &quot;爱&quot;（索引 2，长度 1）占两个字节。 &quot;C&quot;（索引 3，长度 1）占一个字节。 &quot;语&quot;（索引 4，长度 1）占两个字节。 &quot;言&quot;（索引 5，长度 1）占两个字节。 (4)查找和替换123456string s=&quot;abcdefgdefg&quot;;int pos1=s.find(&quot;de&quot;);int pos2=s.find(&quot;df&quot;);//-1int pos3=s.rfind(&quot;df&quot;);//rfind是最后一次出现的位置，find是第一次出现的位置s.replace(1,3,&quot;1111&quot;);//从1号位起3个替换为1111//a1111efgdefg (5)字符串比较1234567891011121314151617void test01() { string str1 = &quot;hfllo&quot;; string str2 = &quot;hello&quot;; if (str1.compare(str2) == 0) { cout &lt;&lt; &quot;str1等于str2&quot; &lt;&lt; endl; } else if (str1.compare(str2) &gt; 0) { cout &lt;&lt; &quot;str1大于str2&quot; &lt;&lt; endl; } else { cout &lt;&lt; &quot;str1小于str2&quot; &lt;&lt; endl; } }//通过逐字符比较ASCII值，大于为1，小于为-1，等于为0,以第一个不一样的字符为准 1str1大于str2 数字 0-9：48-57 大写字母 A-Z：65-90 小写字母 a-z：97-122 (6)字符提取123456string str = &quot;hello&quot;; for (int i = 0; i &lt; 5; i++) cout &lt;&lt; str[i] &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; for (int i = 0; i &lt; 5; i++) cout &lt;&lt; str.at(i) &lt;&lt; &quot; &quot;; (7)插入和删除12345string s1=&quot;abcdefgh&quot;;s1.insert(2,&quot;xxx&quot;);//abxxxcdefghs1.erase(2,3);//删去从2开始的3个字符s1.insert(2,3,'x');//abcdefghs1.insert(2,3,'x');//abxxxcdefgh (8)子串123string s1=&quot;abd*cdf&quot;;int pos=s1.find('*');string s2=s1.substr(0,pos);//abd (9)其他 string s; // 生成一个空字符串s string s(str); // 拷贝构造函数生成str的复制品 string s(str, stridx); // 将字符串str内”始于位置stridx”的部分当作字符串的初值 string s(str, stridx, strlen); // 将字符串str内”始于stridx且长度顶多strlen”的部分作为字符串的初值 string s(cstr); // 将C字符串（以NULL结束）作为s的初值 string s(chars, chars_len); // 将C字符串前chars_len个字符作为字符串s的初值。 string s(num, ‘c’); // 生成一个字符串，包含num个c字符 string s(“value”); string s = “value”; // 将s初始化为一个字符串字面值副本 string s(begin, end); // 以区间begin/end(不包含end)内的字符作为字符串s的初值 s.~string(); //销毁所有字符，释放内存 string s; s.empty(); // s为空串 返回true s.size(); // 返回s中字符个数 类型应为：string::size_type s[n]; // 从0开始相当于下标访问 s1+s2; // 把s1和s2连接成新串 返回新串 s1=s2; // 把s1替换为s2的副本 v1 == v2; // 比较，相等返回true !=, &lt;, &lt;=, &gt;, &gt;= 惯有操作 任何一个大写字母都小于任意的小写字母 123string s(&quot;abc&quot;);s.size();strlen(s.c_str()); 1234567//把string字符串转化为C风格的字符串 string s = &quot;abcdefg&quot;; char str[1000]; strcpy(str, s.c_str()); str[0] = 'p'; str[5] = 'u'; //pbcdeug} 6. set 容器和 multiset 容器#include&lt;set&gt;set不允许容器中有重复的元素multiset允许容器中有重复的元素其他操作基本一致 (1)遍历容器1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;#include&lt;set&gt;using namespace std;void printset(const set&lt;int&gt;&amp;s){ if(s.empty()) { cout&lt;&lt;&quot;set数组为空&quot;&lt;&lt;endl; return; } for(set&lt;int&gt;::const_iterator it=s.begin();it!=s.end();it++) { cout&lt;&lt;*it&lt;&lt;&quot; &quot;; } cout&lt;&lt;endl;}void printmultiset(const multiset&lt;int&gt;&amp;m){ if(m.empty()) { cout&lt;&lt;&quot;multiset数组为空&quot;&lt;&lt;endl; return; } for(multiset&lt;int&gt;::const_iterator it=m.begin();it!=m.end();it++) { cout&lt;&lt;*it&lt;&lt;&quot; &quot;; } cout&lt;&lt;endl;} (2)插入和删除1234567891011121314151617181920212223242526set&lt;int&gt;s;s.insert(10);s.insert(20);s.insert(30); s.insert(40); s.insert(50); s.insert(60); s.insert(70); s.insert(80); s.insert(90); s.insert(100); s.insert(110); s.insert(120);printset(s);//10 20 30 40 50 60 70 80 90 100 110 120set&lt;int&gt;::iterator it=s.begin();set&lt;int&gt;::iterator it2;it2=s.erase(++++it);//删除30.删除迭代器所指元素，返回下一个元素的迭代器printset(s);//10 20 40 50 60 70 80 90 100 110 120set&lt;int&gt;::iterator it1=s.end();s.erase(it2,----it1);//删除区间[it2,----it1)的所有元素，返回下一个元素的迭代器printset(s);s.erase(110);printset(s);//10 20 120s.clear();//清空set容器printset(s);//set数组为空 (2)查找和统计1234567891011121314151617181920212223set&lt;int&gt;s;s.insert(10); s.insert(20); s.insert(30); s.insert(40); s.insert(30); s.insert(60); s.insert(70); s.insert(80); s.insert(70); s.insert(100); s.insert(110); s.insert(120); printset(s);set&lt;int&gt;::()iterator it1;//查找it1=s.find(70);//若存在，返回该键的元素的迭代器，若不存在，返回set.end()if(it1!=s.end()) cout&lt;&lt;*it&lt;&lt;endl;else cout&lt;&lt;&quot;未找到元素&quot;&lt;&lt;endl;//统计int num=s.count(30);cout&lt;&lt;num&lt;&lt;endl;//对于set而言，统计结果只有0和1 程序输出： 12310 20 30 40 60 70 80 100 110 120 70 1 (4)set 与 multiset123456789101112131415161718192021set&lt;int&gt;s;s.insert(20);s.insert(20);s.insert(30);s.insert(40);s.insert(30);s.insert(60);s.insert(70);s.insert(80);s.insert(70);s.insert(100);s.insert(110);s.insert(120);printset(s);pair&lt;set&lt;int&gt;::iterator,bool&gt;ret =s.insert(10);//insert()方法返回一个pair类型，pair&lt;set&lt;int&gt;::iterator,bool&gt;ret，这个first是迭代器，指向插入元素的位置,second是布尔值，表示是否插入成功if(ret.second) cout&lt;&lt;&quot;第一次插入成功&quot;&lt;&lt;endl;else cout&lt;&lt;&quot;第一次插入失败&quot;&lt;&lt;endl;pair&lt;set&lt;int&gt;::iterator,bool&gt;ret1 =s.insert(10);if(ret1.second) cout&lt;&lt;&quot;第二次插入成功&quot;&lt;&lt;endl;else cout&lt;&lt;&quot;第二次插入失败&quot;&lt;&lt;endl; 输出： 12320 30 40 60 70 80 100 110 120 第一次插入成功 第二次插入失败 7. map 和 multimap 容器头文件 #include&lt;map&gt;map 中所有元素都是 pair, 第一个元素为 key (键值), 起到索引作用, 第二个元素为 value（实值）所有元素都有根据元素键值自动排序 map/multimap属于关联式容器，底层结构是用二叉树实现优点：可以根据key值快速找到value值map和multimap区别:map不允许容器中有重复key值元素multimap允许容器中有重复key值元素 (1)遍历12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;#include&lt;map&gt;using namespace std;void printmap(const map&lt;int,int&gt;&amp;m){ if(m.empty()) { cout&lt;&lt;&quot;map容器为空&quot;&lt;&lt;endl; return; } for(map&lt;int,int&gt;::const_iterator it=m.begin();it!=m.end();it++) { cout&lt;&lt;&quot;学号:&quot;&lt;&lt;(*it).first&lt;&lt;&quot; 分数:&quot;&lt;&lt;(*it).second&lt;&lt;endl; } cout&lt;&lt;endl;}void test01(){ map&lt;int,int&gt;m; m.insert(pair&lt;int,int&gt;(1,60)); m.insert(pair&lt;int,int&gt;(2,95)); m.insert(pair&lt;int,int&gt;(4,73)); m.insert(pair&lt;int,int&gt;(3,81)); printmap(m);//按照key值自动排序 map&lt;int,int&gt;m2(m);//拷贝构造 printmap(m2); map&lt;int,int&gt;m3; m3=m2; printmap(m3);} (2)大小和转换1234map&lt;int,int&gt;ma;ma.size();//size()大小map&lt;int,int&gt;ma1;ma.swap(ma1);//swap()转换 (3)插入和删除123456789101112131415161718map&lt;int,int&gt;m;m.insert(pair&lt;int,int&gt;(1,60));m.insert(pair&lt;int,int&gt;(3,95));m.insert(pair&lt;int,int&gt;(4,73));m.insert(pair&lt;int,int&gt;(5,81));m.insert(make_pair(2,10));m.insert(map&lt;int,int&gt;::value_type(6,30));m[7]=40;//这种插数方法和其他的不同在于可以修改已经插入的key对应的valueprintmap(m);m.erase(m.begin(),++++m.begin());printmap(m);m.erase(4);//按照key删除printmap(m);m.clear();printmap(m); 程序输出： 123456789101112131415161718学号：1 分数：60 学号：2 分数：10 学号：3 分数：95 学号：4 分数：73 学号：5 分数：81 学号：6 分数：30 学号：7 分数：40 学号：3 分数：95 学号：4 分数：73 学号：5 分数：81 学号：6 分数：30 学号：7 分数：40 学号：3 分数：95 学号：5 分数：81 学号：6 分数：30 学号：7 分数：40 (4)查找和统计1234567891011121314151617map&lt;int,int&gt;m;m.insert(pair&lt;int, int&gt;(1,60));m.insert(pair&lt;int, int&gt;(3, 95)); m.insert(pair&lt;int, int&gt;(4, 73)); m.insert(pair&lt;int, int&gt;(5, 81)); m.insert(pair&lt;int, int&gt;(2, 84));map&lt;int,int&gt;::iterator it;it=m.find(4);if(it!=m.end()){ cout&lt;&lt;it-&gt;second&lt;&lt;endl;//73 //与cout &lt;&lt; (*it).second &lt;&lt; endl;等价}else{ cout&lt;&lt;&quot;编号不存在&quot;&lt;&lt;endl;}cout&lt;&lt;m.count(4)&lt;&lt;endl;//1 8. priority_queue头文件 #include&lt;queue&gt; priority_queue 是一个元素有序排列的队列，默认队列头部元素优先级最高。因为是一个队列，只能访问第一个元素，这也意味着优先级最高的元素总是第一个被处理。它能够实现常数时间的（默认）最大元素查找，对数代价的插入与释出 (1)构造12priority_queue&lt;int&gt;pq1;priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt;pq2; priority_queue 有三个模板参数：元素类型（T），底层容器类型（Container，默认为 vector&lt;T&gt;），以及比较方式（Compare，默认为 std::less&lt;T&gt;）。 默认构造的 priority_queue (priority_queue&lt;int&gt;) 是一个最大堆，其中最大的元素在堆顶。 通过使用 std::greater&lt;int&gt; 作为比较对象 (priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt;)，你可以创建一个最小堆，其中最小的元素在堆顶。 (2)元素访问top () 访问栈顶元素 123456789101112#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;int main(){ priority_queue&lt;int,vector&lt;int&gt;,less&lt;int&gt;&gt;pq1; pq1.push(10); pq1.push(40); pq1.push(20); cout&lt;&lt;pq1.top()&lt;&lt;endl;//40 return 0;} (3)容量empty ()size () (4)修改器push 插入元素并排序pop 删除队首元素并排序 123456789101112131415161718#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;int main(){ priority_queue&lt;int&gt;pq1; pq1.push(10); pq1.push(40); pq1.push(20); pq1.push(30); while(!pq1.empty()) { cout&lt;&lt;pq1.top()&lt;&lt;&quot; &quot;; pq1.pop(); }//40 30 20 10 //如果是priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt;pq1;则10 20 30 40 return 0;} 9. STL 常用算法下面基本上都需要 #include&lt;algorithm&gt; 头文件 (1)for_each 和 transform12345678910vector&lt;int&gt;v;for(int i=0;i&lt;10;i++){ v.push_back(i+1);}vector&lt;int&gt;vtarget;vtarget.resize(v.size());transform(v.begin(), v.end(), vtarget.begin(), Transform());for_each(vtarget.begin(), vtarget.end(), myprint());//101 102 103 104 105 106 107 108 109 110 v.begin(), v.end()：表示要转换的输入范围是 v 的起始到末尾。 vtarget.begin()：表示转换后的结果要放到 vtarget 中，从其开始位置存储。 Transform()：这是一个函数对象或仿函数，用于指定要对输入范围的每个元素执行的操作。假定的 Transform 类 Transform 需要是一个函数对象，类似于： 123456struct Transform {int operator()(int val) const { return val + 100; } }; 该类重载了 operator()，使得 Transform 类的对象能够像函数一样被调用。 在 transform 函数中，每次调用 Transform() 时，都会对输入的元素执行 val + 100 的操作。 因此，v 中的每个元素 1, 2, ..., 10 将被转换为 101, 102, ..., 110，并存储在 vtarget 中。 for_each 是 C++ 标准库中的另一个算法，用于对范围内的每个元素执行某个操作。 这行代码的参数： vtarget.begin(), vtarget.end()：表示对 vtarget 的所有元素执行操作。 myprint()：这是另一个函数对象，用于指定对每个元素要执行的操作。假定的 myprint 类 myprint 需要是一个函数对象，类似于： 123456struct myprint { void operator()(int val) const { cout &lt;&lt; val &lt;&lt; &quot; &quot;; }}; 该类重载了 operator()，使得 myprint 类的对象可以像函数一样被调用。 函数 说明 find 查找元素 find_if 按条件查找元素 adjacent_find 查找相邻重复元素 binary_search 二分查找法 count 统计元素个数 count_if 按条件统计元素个数 (2)find find 用于查找指定元素。 如果在指定的范围内找到了目标元素，它会返回指向该元素的迭代器。 如果找不到目标元素，则返回一个**结束迭代器 (end())**，表示目标元素不在该范围内。函数原型1iterator find(iterator beg, iterator end, const T&amp; value); iterator beg: 开始迭代器，表示查找范围的起点（包括 beg）。 iterator end: 结束迭代器，表示查找范围的终点（不包括 end 本身）。 value: 要查找的目标值，函数将在 [beg, end) 范围内寻找该值。1234567891011121314vector&lt;int&gt;v;for(int i=0;i&lt;10;i++){ v.push_back(i+1);}vector&lt;int&gt;::iterator it=find(v.begin(),v.end(),5);if(it==v.end()){ cout&lt;&lt;&quot;未找到&quot;&lt;&lt;endl;}else{ cout&lt;&lt;&quot;找到:&quot;&lt;&lt;*it&lt;&lt;endl;} (3)find_if功能描述:按条件查找元素函数原型: find_if(iterator beg, iterator end, _Pred); 按值查找元素,找到返回指定位置选代器,找不到返回结束选代器位置beg开始迭代器end结束迭代器_Pred 函数或者谓词(返回bool类型的仿函数) 12345678910111213141516171819class mycompare { public: bool operator()(int a) { return a &gt; 5; } }; void test01() { vector&lt;int&gt;v; for (int i = 0; i &lt; 10; i++) v.push_back(i + 1); vector&lt;int&gt;::iterator it = find_if(v.begin(), v.end(), mycompare()); if (it == v.end()) cout &lt;&lt; &quot;未找到&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;找到&quot; &lt;&lt; *it &lt;&lt; endl;//找到6 } (4)binary_search查找指定的元素，查到返回true，否则返回false注意：在无序序列中不可用,因为结果会出错降序也不行，只能用于升序序列 12345vector&lt;int&gt;v={0,1,2,3,4,5,6,7,8}; if (binary_search(v.begin(), v.end(), 6)) cout &lt;&lt; &quot;找到了&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;未找到&quot; &lt;&lt; endl; (5)adjacent_find查找相邻重复元素，返回相邻元素的第一个位置的迭代器 123456vector&lt;int&gt;v={0,2,0,3,1,4,3,3,2}; vector&lt;int&gt;::iterator pos = adjacent_find(v.begin(), v.end()); if (pos == v.end()) cout &lt;&lt; &quot;未找到&quot; &lt;&lt; endl; else cout &lt;&lt; *pos &lt;&lt; endl;//输出3 (6)count统计元素个数 123vector&lt;int&gt;v={0,1,2,3,5,3,3,6,8}; int cou = count(v.begin(), v.end(), 3); cout &lt;&lt; cou &lt;&lt; endl; (7)count_if1234567891011121314class greaterfive { public: bool operator()(int a) { return a &gt; 5; } }; void test01() { vector&lt;int&gt;v={0,1,2,7,5,6,3,6,8}; int cou = count_if(v.begin(), v.end(), greaterfive()); cout &lt;&lt; cou &lt;&lt; endl; //4} (8)sort 排序算法12345678910111213141516void myprint(int val) { cout &lt;&lt; val &lt;&lt; &quot; &quot;; } void test01() { vector&lt;int&gt;v={10,30,50,20,40,90}; for_each(v.begin(), v.end(), myprint); //10 30 50 20 40 90cout &lt;&lt; endl; sort(v.begin(), v.end()); for_each(v.begin(), v.end(), myprint); //10 20 30 40 50 90cout &lt;&lt; endl; sort(v.begin(), v.end(), greater&lt;int&gt;()); //greater&lt;int&gt;() 表示 &quot;大于&quot;，因此 sort 函数会将较大的元素排在前面，形成降序排列。for_each(v.begin(), v.end(), myprint); //90 50 40 30 20 10cout &lt;&lt; endl; } (9)random_shuffle123srand((unsigned int)time(NULL)); //设置随机数种子vector&lt;int&gt;v={0,1,2,3,4,5,6,7,8,9}; random_shuffle(v.begin(), v.end());//随机打乱v的排序 在 C++11 及更高版本中，推荐使用 std::shuffle 替代 random_shuffle 1234567891011#include &lt;algorithm&gt; // for std::shuffle#include &lt;random&gt; // for std::default_random_engineint main() { std::vector&lt;int&gt; v = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; std::random_device rd; // 用于获取随机种子 std::default_random_engine rng(rd()); // 随机数生成器 std::shuffle(v.begin(), v.end(), rng); return 0;} (10)merge可以把两个有序序列合在一起，形成一个新的有序序列 12345678910111213141516171819void myprint(int val) { cout &lt;&lt; val &lt;&lt; &quot; &quot;; } void test01() { vector&lt;int&gt;v1; vector&lt;int&gt;v2; for (int i = 0; i &lt; 10; i++) { v1.push_back(i); v2.push_back(i + 1); } vector&lt;int&gt;vTarget;//目标容器 vTarget.resize(v1.size() + v2.size()); merge(v1.begin(), v1.end(), v2.begin(), v2.end(), vTarget.begin()); for_each(vTarget.begin(), vTarget.end(), myprint); //0 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9 10cout &lt;&lt; endl; } (11)reverse逆序 12345678910111213void myprint(int val){ cout&lt;&lt;val&lt;&lt;endl;}void test(){ vector&lt;int&gt;v={10,30,40,50,20}; for_each(v.begin(),v.end(),myprint);//10 30 40 50 20 cout&lt;&lt;endl; reverse(v.begin(),v.end()); for_each(v.begin(),v.end(),myprint);//20 50 40 30 10 cout&lt;&lt;endl;} (12)copy将容器内指定范围的元素拷贝到另一容器中注意：新容器需要预留空间 12345678910111213void mypriny(int val){ cout&lt;&lt;val&lt;&lt;endl;}void test(){ vector&lt;int&gt;v={10,30,40,50,20}; vector&lt;int&gt;v2; v2.resize(v.size()); copy(v.begin(),v.end(),v2.begin()); for_each(v2.begin(),v2.end(),myprint);//10 30 40 50 20 cout&lt;&lt;endl;} (13)replace 和 replace_ifreplace将容器内指定范围的旧元素修改为新元素replace_if将区间内满足条件替换成指定元素 12345678910111213141516171819202122232425void myprint(int val) { cout &lt;&lt; val &lt;&lt; &quot; &quot;; } //compare是一个仿函数（函数对象）。通过重载 operator()，使得 compare 类的对象可以像函数一样被调用。class compare { public: bool operator()(int a) { return a &gt;= 40; } }; void test01() { vector&lt;int&gt;v={10,30,40,30,20,10,30,40,50,20}; for_each(v.begin(), v.end(), myprint); //10 30 40 30 20 10 30 40 50 20cout &lt;&lt; endl; replace(v.begin(), v.begin() + 4, 30, 300); //[v.begin(), v.begin() + 4)所有值为 30 的元素替换为 300for_each(v.begin(), v.end(), myprint); //10 300 40 300 20 10 30 40 50 20cout &lt;&lt; endl; replace_if(v.begin(), v.end(), compare(), 66); for_each(v.begin(), v.end(), myprint); //10 66 66 66 20 10 30 66 66 20cout &lt;&lt; endl; } (14)swap交换 123456vector&lt;int&gt;v={10,30,40,30,20,10,30,40,50,20}; vector&lt;int&gt;v1; for (int i = 0; i &lt; 10; i++) v1.push_back(i + 1);swap(v, v1); for_each(v.begin(), v.end(), myprint); cout &lt;&lt; endl; (15)accumulate 和 fill#include&lt;numeric&gt; accumulate计算容器元素累计总和fill向容器中添加元素 1234567891011121314151617181920212223void myprint(int val) { cout &lt;&lt; val &lt;&lt; &quot; &quot;; } void test01() { vector&lt;int&gt;v{10,30,40,30,20,10,30,40,50,20}; for_each(v.begin(), v.end(), myprint); cout &lt;&lt; endl; int total=accumulate(v.begin(), v.end(), 0); //第三个参数表示起始累加值，0表示最后结果加0 cout &lt;&lt; total &lt;&lt; endl; } void test02() { vector&lt;int&gt;v; v.resize(10); for_each(v.begin(), v.end(), myprint); cout &lt;&lt; endl; fill(v.begin(), v.end() - 2, 6); for_each(v.begin(), v.end(), myprint); cout &lt;&lt; endl; } 输出： 123410 30 40 30 20 10 30 40 50 20 2800 0 0 0 0 0 0 0 0 0 6 6 6 6 6 6 6 6 0 0 (16)交集，并集，差集set_intersection求两个容器的交集set_union并集set_difference差集 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt; // for set_intersection, set_union, set_differenceusing namespace std;void printVector(const vector&lt;int&gt;&amp; v) { for (int val : v) { cout &lt;&lt; val &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl;}int main() { // 两个有序的 vector 容器 vector&lt;int&gt; v1 = {1, 2, 3, 4, 5, 6}; vector&lt;int&gt; v2 = {4, 5, 6, 7, 8, 9}; vector&lt;int&gt; result; // 用于存储结果 // 求交集 result.resize(min(v1.size(), v2.size())); // 交集的最大可能大小为两个容器的最小值 auto it = set_intersection(v1.begin(), v1.end(), v2.begin(), v2.end(), result.begin()); result.resize(it - result.begin()); // 调整结果大小为实际交集元素的大小 cout &lt;&lt; &quot;Intersection of v1 and v2: &quot;; printVector(result); // 输出交集 // 求并集 result.clear(); result.resize(v1.size() + v2.size()); // 并集的最大可能大小为两个容器的和 it = set_union(v1.begin(), v1.end(), v2.begin(), v2.end(), result.begin()); result.resize(it - result.begin()); // 调整结果大小为实际并集元素的大小 cout &lt;&lt; &quot;Union of v1 and v2: &quot;; printVector(result); // 输出并集 // 求差集 v1 - v2 result.clear(); result.resize(v1.size()); // 差集的最大可能大小为第一个容器的大小 it = set_difference(v1.begin(), v1.end(), v2.begin(), v2.end(), result.begin()); result.resize(it - result.begin()); // 调整结果大小为实际差集元素的大小 cout &lt;&lt; &quot;Difference of v1 and v2 (v1 - v2): &quot;; printVector(result); // 输出差集 // 求差集 v2 - v1 result.clear(); result.resize(v2.size()); // 差集的最大可能大小为第二个容器的大小 it = set_difference(v2.begin(), v2.end(), v1.begin(), v1.end(), result.begin()); result.resize(it - result.begin()); // 调整结果大小为实际差集元素的大小 cout &lt;&lt; &quot;Difference of v2 and v1 (v2 - v1): &quot;; printVector(result); // 输出差集 return 0;} (17)next_premutation全排列 1234567891011121314vector&lt;int&gt;vec; for (int i = 0; i &lt; 3; i++) { vec.emplace_back(i + 1); //emplace_back(i + 1)是一个更有效的插入方式（类似于 push_back），用来在容器末尾直接构造元素。} for (auto k : vec) cout &lt;&lt; k &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; while (next_permutation(vec.begin(), vec.end())) { for (auto k : vec) cout &lt;&lt; k &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; } next_permutation 是 C++ &lt;algorithm&gt; 头文件中的一个函数，用于生成从当前排列组合的下一个字典序排列。 如果当前的排列组合已经是最大的排列组合，则 next_permutation 会返回 false，否则返回 true。 需要注意，next_permutation 只能在有序的容器上工作，因此 vec 必须按升序（或其他顺序）排列才能生成所有排列组合。输出：1234561 2 3 1 3 2 2 1 3 2 3 1 3 1 2 3 2 1 (18)lower_bound 和 upper_boundlower_bound( )和upper_bound( )都是利用二分查找的方法在一个排好序的数组中进行查找的。 在从小到大的排序数组中，lower_bound( begin,end,num)：从数组的begin位置到end-1位置二分查找第一个大于或等于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。 upper_bound( begin,end,num)：从数组的begin位置到end-1位置二分查找第一个大于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。 也可以用于vector容器，返回值是迭代器 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int cmd(int a, int b) { return a &gt; b;}int main() { int num[6] = { 1, 2, 4, 7, 15, 34 }; // 默认的排序是从小到大，因此这里其实是多余的操作 sort(num, num + 6); // 按从小到大排序 // 使用 lower_bound 查找第一个大于或等于 7 的位置 int pos1 = lower_bound(num, num + 6, 7) - num; // lower_bound 返回的迭代器减去 num 的起始地址，得到相应的位置索引。 cout &lt;&lt; pos1 &lt;&lt; &quot; &quot; &lt;&lt; num[pos1] &lt;&lt; endl; // 输出：3 7 // 使用 upper_bound 查找第一个大于 7 的位置 int pos2 = upper_bound(num, num + 6, 7) - num; cout &lt;&lt; pos2 &lt;&lt; &quot; &quot; &lt;&lt; num[pos2] &lt;&lt; endl; // 输出：4 15 // 按从大到小排序 sort(num, num + 6, cmd); // cmd 定义为从大到小排序 // 使用 lower_bound 查找第一个小于或等于 7 的位置 int pos3 = lower_bound(num, num + 6, 7, greater&lt;int&gt;()) - num; cout &lt;&lt; pos3 &lt;&lt; &quot; &quot; &lt;&lt; num[pos3] &lt;&lt; endl; // 输出：2 7 // 使用 upper_bound 查找第一个小于 7 的位置 int pos4 = upper_bound(num, num + 6, 7, greater&lt;int&gt;()) - num; cout &lt;&lt; pos4 &lt;&lt; &quot; &quot; &lt;&lt; num[pos4] &lt;&lt; endl; // 输出：3 4 return 0;}","link":"/2024/10/03/STL/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2023/12/13/hello-world/"},{"title":"基于Springboot+Vue的WebApp开发实验报告","text":"Java与面向对象设计的大作业，实验报告docx用pandoc转成了md。 【实验目的】 掌握Java与面向对象基本原理和概念。 掌握Java与面向对象编程思想和主流技术或框架。 掌握基于Java开发完整软件Demo，并能演示。 【实验装备】 个人笔记本，idea，JDK环境，mysql，navicat, vue，git等。 【实验内容】 基于所选择的主题方向，调研、分析和设计3-5个核心场景（模块）作为研究对象，根据掌握的Java和相关知识，实现相对完整的WebApp应用。以Java为基础，可以自由选择搭配其它技术和框架，输出详细的设计文档、项目源代码和可运行的Demo视频。 【实验要求】 按实验内容输出详细设计、实现、运行关键截图，要求行文整洁、紧凑、顺畅。 代码以团队gitee形式提交，视频以百度网盘形式提交，可限时公开访问。 团队Gitee: JavaGroup (gitee.com) 本项目代码: JavaGroup/project(gitee.com) 视频百度网盘：链接提取码：2s45 实验报告需要交代团队成员分工，以及自己承担的任务（要求任务量合理，鼓励交叉参与）；个人报告要求完整，团队成果部分精炼描述，侧重个人为主部分加以详细描述。 【实验分析】 输出实验分析总结和心得体会。 【参考资料】 参考教程：带你从0搭建一个Springboot+vue前后端分离项目，真的很简单！_哔哩哔哩_bilibili 参考资料： 1. 一个 Vue 3 UI 框架 | Element Plus(element-plus.org) 2. Vue.js 教程 | Vue.js 中文文档(cn.vuejs.org) 3. SpringBoot+Vue个人健康管理系统Java毕业设计_哔哩哔哩_bilibili(主要参考要实现什么功能) 这个源代码上传至：JavaGroup/health_management(gitee.com) 【目录】 一.背景分析 经过了解和学习，为实现健康管理系统，我们采取了一种现代化的前后端分离架构，以下是我们选用的关键技术和工具： 1.前端技术 Vue.js：作为一个渐进式JavaScript框架，Vue.js被用于创建高效、灵活的用户界面。它的组件化架构让我们能够重用代码并加快开发速度。 Element-Plus：基于Vue3的桌面端组件库，提供了一套丰富的UI组件，帮助我们在保持界面美观的同时，减少了开发和设计的工作量。 2.后端技术 SpringBoot：简化了基于Spring的应用开发过程，使得我们能够快速搭建和部署微服务。SpringBoot自动配置的特性大幅度减轻了配置工作，让我们能够专注于业务逻辑的实现。 MyBatis：它是一个支持定制SQL、存储过程以及高级映射的持久层框架。MyBatis消除了几乎所有的JDBC代码，并手动设置参数以及获取结果集。通过简单的XML或注解，我们能够将接口映射成数据库中的记录。 Lombok：一个Java库，通过使用注解，能够自动化生成模板代码，如getters、setters、constructors等。Lombok极大地简化了我们的Java代码，使得它更加简洁易读。 3.数据库管理 MySQL：我们选择MySQL作为后端数据库，借助其强大和广泛支持的特性来存储应用数据。 Navicat：作为一款强大的数据库管理工具，Navicat让数据库的管理变得轻松便捷。它不仅支持MySQL，还支持大量其它数据库，提供直观的GUI方便进行数据管理、开发和维护。 二.需求分析 我们计划实现3-5个主核心功能，参考健康管理系统|拾果健康(sghealth.cn)及网上找到一些健康管理系统找到大概想实现的功能。在写好vue+springboot基本框架，搭建好跨域配置，写好依赖，写好基本的响应码，数据库配置，引入数据库表格写好mapper,controller,entity等等后，决定按功能分工，各自实现负责的功能的前端+后端。虽然前后端分离，但是功能一个人同时写，不断加功能完善项目，同时锻炼写前端和后端的能力。 三.系统设计 下面是我们当时设计的方案： 系统：管理员、用户 登录界面参考： 首页 健康信息上传 商品推荐 运动知识 评估与建议 随后进行抽签，选择各自要实现的功能。抽签决定好后先写好头部和侧边栏，新建不同的.vue和路由，之后每个人写自己的.vue并根据需要补充后端.java即可。 四.系统实现 团队成果： 采用前端部分使用Vue.js和Element-Plus来构建用户界面，后端使用SpringBoot和MyBatis进行业务逻辑的处理和数据持久化，同时使用Navicat来管理MySQL数据库，并借助Lombok简化Java代码的开发。 个人报告： 我的任务：准备阶段学习git，gitee的使用和navicat，idea的配置并创建gitee团队；正式写项目时负责4个小功能，分别是登录、注册、设置、健康问答。并简单改动一下其他部分的细节。最后整理项目时导出sql文件，写项目README。 我的gitee：Zhuyuehan (strangersinsist) -Gitee 1).准备阶段： 参照JavaGroup/health_management(gitee.com)学会怎么运行前端后端数据库,git的一些操作。 2).正式项目： 1.登录前端Login.vue，并在health_manage_vue\\src\\router\\index.js设置路由，点击按钮触发js,通过post与后端进行交互。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;script&gt;import request from &quot;@/utils/request&quot;;export default { name: &quot;Login&quot;, components: {User,Lock}, data(){ return { form:{}, rules:{ username:[ {required:true,message:&quot;请输入用户名&quot;,trigger:'blur'}, ], password:[ {required:true,message:&quot;请输入密码&quot;,trigger:'blur'}, ], } } }, methods:{ login(){ request.post(&quot;/api/user/login&quot;,this.form).then(res =&gt;{ console.log(res); if(res.code == '200'){ this.$message({ type: &quot;success&quot;, message:&quot;登录成功&quot; }) //改一下试图存缓存 sessionStorage.setItem(&quot;user&quot;, JSON.stringify(res.data)); this.$router.push(&quot;/&quot;) }else{ this.$message({ type:&quot;error&quot;, message:&quot;用户名或密码错误&quot; }) } }) } }}import { User,Lock,} from '@element-plus/icons-vue'&lt;/script&gt;&lt;template&gt; &lt;div class=&quot;login-container&quot;&gt; &lt;div class=&quot;login-card&quot;&gt; &lt;h1 class=&quot;login-title&quot;&gt;欢迎登录&lt;/h1&gt; &lt;el-form :model=&quot;form&quot; :rules=&quot;rules&quot; class=&quot;login-form&quot; ref=&quot;loginForm&quot; size=&quot;large&quot;&gt; &lt;el-form-item prop=&quot;username&quot; class=&quot;form-item&quot;&gt; &lt;el-icon class=&quot;icon&quot;&gt;&lt;User /&gt;&lt;/el-icon&gt; &lt;el-input v-model=&quot;form.username&quot; placeholder=&quot;用户名：&quot; class=&quot;input-field&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item prop=&quot;password&quot; class=&quot;form-item&quot;&gt; &lt;el-icon class=&quot;icon&quot;&gt;&lt;Lock /&gt;&lt;/el-icon&gt; &lt;el-input type=&quot;password&quot; v-model=&quot;form.password&quot; placeholder=&quot;密码：&quot; class=&quot;input-field&quot; show-password&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;div class=&quot;form-actions&quot;&gt; &lt;el-button class=&quot;action-button&quot; @click=&quot;login&quot;&gt;登录&lt;/el-button&gt; &lt;el-button class=&quot;action-button&quot; @click=&quot;this.$router.push('/register')&quot;&gt;注册&lt;/el-button&gt; &lt;/div&gt; &lt;/el-form&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;//这部分为了优化界面写的比较多，省略，详细看gitee代码&lt;/style&gt; 后端和队友共用的Result.java，User.java，UserMapper.java和UserController.java，用于获取数据库信息及返回数据给前端，我在队友写的代码基础上增加了需要的部分UserController.java: 12345678910111213141516171819202122232425262728package com.example.demo.controller;import …@RestController@RequestMapping(&quot;/user&quot;)public class UserController { @Resource UserMapper userMapper; @PostMapping(&quot;/login&quot;) public Result&lt;?&gt; login(@RequestBody User user){ User res = userMapper.selectOne(Wrappers.&lt;User&gt;lambdaQuery().eq(User::getUsername,user.getUsername()).eq(User::getPassword,user.getPassword())); if(res ==null){ return Result.fail(&quot;用户名或密码错误&quot;); } return Result.success(res); } @PostMapping(&quot;/register&quot;) public Result&lt;?&gt; register(@RequestBody User user){ User res = userMapper.selectOne(Wrappers.&lt;User&gt;lambdaQuery().eq(User::getUsername,user.getUsername())); if(res !=null){ return Result.fail(&quot;用户名重复&quot;); } if(user.getPassword()==null){ user.setPassword(&quot;123456&quot;); } userMapper.insert(user); return Result.success(user); } 最初是这样： 经过美化： 2.注册 与登录基本类似，前端Register.vue，并在index.js设置路由。详细代码可以看gitee。(这个后面和登录用了同样的方式美化了一下) 3.设置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;script&gt;import request from &quot;@/utils/request&quot;;export default { name: &quot;Setting&quot;, components: { }, data(){ return{ form:{}, input:&quot;&quot; } }, created(){ let str=sessionStorage.getItem(&quot;user&quot;)||&quot;{}&quot; this.form=JSON.parse(str) }, methods:{ handleClose(){ this.$router.push('/home'); }, update(){ request.put(&quot;api/user&quot;,this.form).then(res =&gt;{ console.log(res); if(res.code == '200'){ this.$message({ type: &quot;success&quot;, message:&quot;更新成功&quot; }) sessionStorage.setItem(&quot;user&quot;,JSON.stringify(this.form)) this.$router.push('/home'); }else{ this.$message({ type:&quot;error&quot;, message:&quot;更新失败&quot; }) } }) } }}&lt;/script&gt;&lt;template&gt; &lt;div&gt; &lt;el-dialog v-model=&quot;form&quot; title=&quot;个人信息编辑&quot; width=&quot;500&quot; @close=&quot;handleClose&quot;&gt; &lt;el-form :model=&quot;form&quot;&gt; &lt;el-form-item label=&quot;用户名&quot; :label-width=&quot;formLabelWidth&quot;&gt; &lt;el-input v-model=&quot;form.username&quot; disabled&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;密码&quot; :label-width=&quot;formLabelWidth&quot;&gt; &lt;el-input v-model=&quot;form.password&quot; show-password&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;手机号&quot; :label-width=&quot;formLabelWidth&quot;&gt; &lt;el-input v-model=&quot;form.number&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;邮箱&quot; :label-width=&quot;formLabelWidth&quot;&gt; &lt;el-input v-model=&quot;form.email&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;div class=&quot;dialog-footer&quot;&gt; &lt;el-button @click=&quot;this.$router.push('/home')&quot;&gt;取消&lt;/el-button&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;update&quot;&gt; 确认 &lt;/el-button&gt; &lt;/div&gt; &lt;/el-dialog&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;&lt;/style&gt; 这个是header.vue部分的设置，写这部分是新增了vue和路由实现的。这部分不难，是在element plus中找了表单，再写好script部分，获取的user信息就好了。后来优化这部分时补充handleClose方法点击叉号跳转/home页面，使操作更加流畅。 4.健康问答 前端实现：HomeView.vue: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&lt;template&gt;&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;chatbox&quot;&gt; &lt;h2 class=&quot;title&quot;&gt;健康问答&lt;/h2&gt; &lt;div class=&quot;messages&quot; ref=&quot;messageBox&quot;&gt; &lt;div v-for=&quot;(message, index) in messages&quot; :key=&quot;index&quot; :class=&quot;{'message-container': true, 'user-message': message.sender === 'User', 'bot-message': message.sender !== 'User'}&quot; &gt; &lt;el-avatar class=&quot;message-avatar&quot; style=&quot;background-color: cornflowerblue;color: black&quot;&gt;{{message.sender === 'User' ? 'User' : 'Bot'}}&lt;/el-avatar&gt; &lt;div class=&quot;message-content&quot;&gt;{{message.text}}&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;input-section&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;userinput&quot; v-model=&quot;userInput&quot; @keyup.enter=&quot;sendMessage&quot; placeholder=&quot;输入：&quot; /&gt; &lt;button class=&quot;send&quot; @click=&quot;sendMessage&quot; &gt; 发送 &lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import axios from 'axios'export default { name: 'HomeView', components: { }, data(){ return{ userInput: '', messages: [], } }, methods:{ async callAPIMethod(input) { try { const response = await axios.post('http://localhost:9091/reply', { message: input }); return response.data; } catch (error) { console.error(error); } }, async sendMessage() { this.messages.push({ sender: 'User', text: this.userInput, }); console.log(&quot;Ready to send message: &quot; + this.userInput); const response = await this.callAPIMethod(this.userInput); console.log(&quot;Received message: &quot; + response); if(response) { this.messages.push({ sender: 'Bot', text: response, }); } this.$refs.messageBox.scrollTop = this.$refs.messageBox.scrollHeight; this.userInput = ''; }, },}&lt;/script&gt;&lt;style scoped&gt;//这部分太长了省略，详细看gitee代码&lt;/style&gt; 后端实现：MessageController.java 1234567891011121314151617181920212223242526272829package com.example.demo.controller;import …class Message { private String message; // getter // setter}@CrossOrigin(origins = &quot;http://localhost:8080&quot;)@RestControllerpublic class MessageController { @PostMapping(&quot;/reply&quot;) public String reply(@RequestBody Message message) { Random rand = new Random(); String[] responses = {&quot;保持健康~&quot;, &quot;锻炼身体！&quot;, &quot;饮食规律~&quot;}; if (&quot;你好&quot;.equals(message.getMessage())) { return &quot;你好&quot;; } else if (&quot;什么是亚健康管理系统&quot;.equals(message.getMessage())) { return &quot;这个亚健康管理系统是人工智能学院java小组开发的。包括主页，运动知识，健康购物，评估与建议，健康信息上传的功能&quot;; } //省略一些else if else { return responses[rand.nextInt(responses.length)]; } }} 这部分本来我想连一个大语言模型的api，但是后来找不到适合的免费api，并且觉得如果是健康管理系统的话可能直接连一个大模型不太合适，要手动个性化设置一下，遂写了一些回复语代替，比较简洁，仅供演示。如果问”你好”和”什么是亚健康管理系统&quot;等会回复特定的话，问其他就在&quot;保持健康~&quot;,&quot;锻炼身体！&quot;, &quot;饮食规律~&quot;中随机回复一个。 最初是下面左图所示，右图是后来美化了一下。 5.一些其他的小细节 1）头部username显示 最初： 改动后： 显示具体的用户名 123&lt;template #title&gt; &lt;el-avatar style=&quot;background-color: cornflowerblue;color: black&quot;&gt;{{ user.username }}&lt;/el-avatar&gt; &lt;/template&gt; 2）管理员和普通用户权限，管理员可以看到用户管理的页面，这里是在数据库增加了role(int类型，1表示管理员0表示普通用户), 在Aside.vue： 1234 &lt;el-menu-item index=&quot;7&quot; v-if=&quot;user.role===1&quot; @click=&quot;this.$router.push('/user_manage')&quot;&gt; &lt;el-icon&gt;&lt;List /&gt;&lt;/el-icon&gt; &lt;span&gt;用户管理&lt;/span&gt;&lt;/el-menu-item&gt; v-if=&quot;user.role===1&quot; 这样实现的 在User_manage.vue: 123456&lt;el-table-column label=&quot;角色&quot;&gt; &lt;template #default=&quot;scope&quot;&gt; &lt;span v-if=&quot;scope.row.role===1&quot;&gt;管理员&lt;/span&gt; &lt;span v-if=&quot;scope.row.role===0&quot;&gt;普通用户&lt;/span&gt; &lt;/template&gt;&lt;/el-table-column&gt; 实现两者的显示。 3）未登录状况下强制跳转登录（这里是对我负责的登录功能的优化） 在index.js: 123456789101112// 添加一个 beforeEach 路由守卫,这里用于实现未登录情况下强制跳转/loginrouter.beforeEach((to, from, next) =&gt; { // 检查 sessionStorage 中是否已经有 user let user = sessionStorage.getItem('user'); // 如果没有 user 且访问的不是登录界面，那么强制跳转至登录页面 if (!user &amp;&amp; to.path !== '/login'&amp;&amp; to.path !== '/register') { return next({ path: '/login' }); } // 否则就继续进行本次路由 next();}); 6.sql文件的整理上传，详见giteehealth_management.sql 7.README，详见giteeREADME.md 五.总结展望 这次作业前期准备断断续续用了快一个月，后面写项目差不多两周左右。使用多一点框架会在正式开发中快很多，但是想要知道怎么用还是要学不少知识的。我们每个人都写了前端后端，如果你看源码会发现4个人不同的代码风格。总的来说，这次大作业还是学到了很多东西，见证了项目一点点搭建起来，培养团队合作能力，也真的加强了自信”我们可以自己写原创项目”。 展望的话，我们以后可以实现更完整一点的项目，比如文件上传，更丰富的管理员功能，验证码，服务器部署等等。","link":"/2024/06/18/web%E5%BC%80%E5%8F%91/"},{"title":"web开发","text":"AI生成，很杂。 vue. jsVue. js 是一个用于构建用户界面的渐进式 JavaScript 框架，它非常灵活，既可以用于开发单页面应用（SPA），也可以作为大型应用的组成部分。Vue 通过易于理解的模板语法和双向数据绑定，降低了前端开发的复杂度。以下是 Vue. js 的基础知识讲解： 1. Vue 的核心概念1.1 数据绑定Vue 提供了一个直观的方式将数据绑定到 DOM 中。最常用的绑定方式是通过插值表达式 {{}} 或者 v-bind 指令： 123&lt;div id=&quot;app&quot;&gt; {{ message }}&lt;/div&gt; 123456const app = new Vue({ el: '#app', data: { message: 'Hello Vue!' }}); 上面的代码中，message 属性绑定到了 DOM 中的 div 标签，页面渲染时会显示 Hello Vue!。 1.2 双向数据绑定Vue 提供了 v-model 指令来实现表单元素的双向数据绑定。例如： 1234&lt;div id=&quot;app&quot;&gt; &lt;input v-model=&quot;message&quot;&gt; &lt;p&gt;{{ message }}&lt;/p&gt;&lt;/div&gt; 当用户输入文字时，message 的值会实时更新并反映到页面上。 1.3 计算属性当你需要基于已有数据生成新数据时，可以使用 computed 属性，它具有缓存特性，只有在依赖的数据发生变化时才会重新计算： 123456789101112const app = new Vue({ el: '#app', data: { firstName: 'John', lastName: 'Doe' }, computed: { fullName() { return this.firstName + ' ' + this.lastName; } }}); 1.4 事件监听使用 v-on 指令或缩写 @ 来监听事件，并绑定到 Vue 方法上： 1&lt;button v-on:click=&quot;sayHello&quot;&gt;Click Me&lt;/button&gt; 12345678const app = new Vue({ el: '#app', methods: { sayHello() { alert('Hello Vue!'); } }}); 2. Vue 的模板语法2.1 条件渲染使用 v-if, v-else-if 和 v-else 指令来条件性地渲染元素： 1&lt;p v-if=&quot;seen&quot;&gt;Now you see me&lt;/p&gt; 如果 seen 为 true，那么该段文字将显示；否则，DOM 中不会存在该元素。 2.2 列表渲染使用 v-for 渲染列表： 123&lt;ul&gt; &lt;li v-for=&quot;item in items&quot; :key=&quot;item.id&quot;&gt;{{ item.text }}&lt;/li&gt;&lt;/ul&gt; 12345678910const app = new Vue({ el: '#app', data: { items: [ { id: 1, text: 'Learn JavaScript' }, { id: 2, text: 'Learn Vue' }, { id: 3, text: 'Build something awesome' } ] }}); 2.3 属性绑定使用 v-bind 指令（或缩写 :）来动态绑定 HTML 属性： 1&lt;a v-bind:href=&quot;url&quot;&gt;Visit Vue.js&lt;/a&gt; 当 url 的值发生改变时，链接地址会自动更新。 3. Vue 实例每个 Vue 应用都是通过创建一个新的 Vue 实例来启动的： 123456const vm = new Vue({ el: '#app', data: { message: 'Hello Vue!' }}); Vue 实例的属性： el: 指定 Vue 实例控制的 DOM 元素。 data: 定义 Vue 实例的数据属性。 methods: 定义 Vue 实例的方法。 computed: 定义 Vue 实例的计算属性。 4. 组件组件是 Vue 的核心功能，用来构建可复用的 UI 片段。每个组件都是一个独立的 Vue 实例，可以嵌套和组合。 4.1 创建组件使用 Vue.component 创建一个全局组件： 1234Vue.component('todo-item', { props: ['todo'], template: '&lt;li&gt;{{ todo.text }}&lt;/li&gt;'}); 在模板中可以通过 &lt;todo-item&gt; 标签引用： 123&lt;ul&gt; &lt;todo-item v-for=&quot;item in todoList&quot; :key=&quot;item.id&quot; :todo=&quot;item&quot;&gt;&lt;/todo-item&gt;&lt;/ul&gt; 4.2 组件之间的通信 父组件通过 props 向子组件传递数据。 子组件通过 $emit 触发事件通知父组件。 5. 指令Vue 内置了多个指令，用来处理常见的 DOM 操作： 常用指令： v-if / v-else-if / v-else: 条件渲染。 v-for: 列表渲染。 v-show: 显示/隐藏元素（只是修改 display 属性）。 v-bind (:): 绑定属性或表达式。 v-model: 双向数据绑定。 v-on (@): 事件监听。 6. Vue RouterVue Router 是官方的路由库，用于构建单页面应用（SPA）。它通过映射 URL 到组件，来动态加载和渲染不同的页面内容： 12345678910const routes = [ { path: '/home', component: Home }, { path: '/about', component: About }];const router = new VueRouter({ routes});const app = new Vue({ router}).$mount('#app'); 7. VuexVuex 是用于管理 Vue 应用的状态管理模式，特别适合多组件共享状态的场景： state: 存放全局状态。 getters: 从 state 中派生出数据。 mutations: 修改 state 的唯一方法。 actions: 类似于 mutation，但包含异步操作。 8. 生命周期钩子Vue 实例在创建和销毁时，会经历多个生命周期阶段。常用的钩子函数有： created: 实例创建完成后调用。 mounted: DOM 挂载完成后调用。 updated: 数据更新完成后调用。 destroyed: 实例销毁后调用。 了解这些生命周期钩子有助于更好地管理 Vue 组件的行为。 9. 单文件组件单文件组件（.vue 文件）将 HTML、JavaScript 和 CSS 集成到一个文件中，是 Vue 中开发组件的标准方式： 12345678910111213141516171819&lt;template&gt; &lt;div&gt;{{ message }}&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { data() { return { message: 'Hello Single File Component!' }; }};&lt;/script&gt;&lt;style scoped&gt;div { color: red;}&lt;/style&gt; springbootSpring Boot 是基于 Spring 框架的简化开发工具，旨在快速构建和部署生产级别的 Spring 应用。它通过简化配置、内嵌服务器和自动化配置机制，让开发者专注于业务逻辑，而不需要关注复杂的 XML 配置。以下是 Spring Boot 的基础知识讲解： 1. Spring Boot 的核心概念1.1 自动配置（Auto-Configuration）Spring Boot 的核心理念之一是 自动配置，它基于 Spring 框架提供的 @Configuration 注解，并且依赖于条件性注解（如 @Conditional），能够根据项目依赖自动配置合适的 Spring Bean，省去大量的手工配置工作。 例如，当你在项目中添加 spring-boot-starter-web 依赖时，Spring Boot 会自动配置一个内嵌的 Tomcat 服务器、Spring MVC 组件等。 1.2 Starter 依赖Spring Boot 提供了多种 Starter 依赖 来简化项目构建。常见的 Starter 有： spring-boot-starter-web：用于构建 Web 应用（包含 Tomcat、Spring MVC） spring-boot-starter-data-jpa：用于集成 JPA 和数据库操作：java 标准的对象-关系映射（ORM）工具 spring-boot-starter-test：包含常用的测试库（JUnit、Mockito） 通过使用这些 Starter 依赖，开发者可以快速引入 Spring Boot 生态中常用的功能，而不需要一个个手动添加依赖。 1.3 内嵌服务器Spring Boot 内置了多种常见的服务器（如 Tomcat、Jetty 和 Undertow），默认使用 Tomcat。它允许应用打包成 JAR 文件（而不是传统的 WAR 文件）并直接运行，极大地简化了部署流程。 1.4 Spring Boot ActuatorSpring Boot 提供了 Actuator 监控工具，可以用来检查和管理应用的健康状况和性能。通过 spring-boot-starter-actuator 依赖，能够查看应用运行时的一些指标（如健康检查、线程状态、环境属性等）。 2. Spring Boot 的项目结构创建的标准 Spring Boot 项目通常具有以下目录结构： 123456789101112my-springboot-project├── src│ ├── main│ │ ├── java│ │ │ └── com.example.demo # Java 源文件│ │ │ └── DemoApplication.java│ │ ├── resources│ │ ├── application.properties # Spring Boot 配置文件│ │ └── static # 静态资源（如 HTML, CSS）│ │ └── templates # Thymeleaf 模板文件夹│ └── test # 测试文件夹└── pom.xml # Maven 项目配置文件 2.1 DemoApplication.javaSpring Boot 项目的主类通常放在 src/main/java 目录下，它是 Spring Boot 应用的入口点。常见的主类格式如下： 1234567891011package com.example.demo;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class DemoApplication { public static void main(String[] args) { SpringApplication.run(DemoApplication.class, args); }} 主类使用了 @SpringBootApplication 注解，它是以下三个注解的组合： @Configuration: 标识该类是一个 Spring 配置类。 @EnableAutoConfiguration: 启用 Spring Boot 的自动配置机制。 @ComponentScan: 启动组件扫描，从而发现和注册 Spring Bean。 3. 创建 Spring Boot 项目3.1 使用 Spring Initializr 创建项目Spring Initializr 是官方提供的项目生成器工具，访问 Spring Initializr 你可以在线生成 Spring Boot 项目。 打开 Spring Initializr。 配置以下选项： Project: 选择 Maven Project 或 Gradle Project。 Language: 选择 Java。 Spring Boot Version: 选择 2.x 或 3.x 版本。 Project Metadata: 配置项目的基本信息（如 Group、Artifact）。 Dependencies: 添加所需的依赖（如 Spring Web、Spring Data JPA、MySQL Driver）。 点击 Generate 按钮，下载生成的项目 ZIP 文件，解压并导入到 IDE 中。 3.2 使用 IDE 创建 Spring Boot 项目常用的 IDE（如 IntelliJ IDEA、Eclipse）中都有创建 Spring Boot 项目的集成工具，使用这些工具可以快速创建和配置 Spring Boot 项目。 4. Spring Boot 的配置Spring Boot 使用 application.properties 或 application.yml 文件来进行配置。以下是常见的配置项： 1234567891011121314# 配置服务器端口server.port=8081# 配置数据库spring.datasource.url=jdbc:mysql://localhost:3306/testdbspring.datasource.username=rootspring.datasource.password=123456# 配置 JPAspring.jpa.hibernate.ddl-auto=updatespring.jpa.show-sql=true# 配置日志logging.level.org.springframework=INFO application.yml 格式：12345678910111213141516server: port: 8081spring: datasource: url: jdbc:mysql://localhost:3306/testdb username: root password: 123456 jpa: hibernate: ddl-auto: update show-sql: truelogging: level: org.springframework: INFO 5. 常用注解5.1 Spring Boot 核心注解 @SpringBootApplication：标识 Spring Boot 启动类，是配置和组件扫描的入口。 @RestController：组合了 @Controller 和 @ResponseBody，用于定义 RESTful 控制器。 @RequestMapping：定义请求映射，可以用于类或方法上。 @GetMapping / @PostMapping：简化的 GET / POST 请求映射注解。 @Autowired：自动注入 Bean。 5.2 数据访问相关注解 @Entity：标识 JPA 实体类。 @Table：定义数据库表名。 @Id：标识主键。 @Repository：标识数据访问层组件。 5.3 事务管理注解 @Transactional：定义事务性操作，确保数据一致性。 6. Spring Boot 的 Web 开发6.1 创建一个简单的 RESTful API使用 Spring Boot 创建一个简单的 RESTful API 只需要几个步骤： 123456789@RestController@RequestMapping(&quot;/api&quot;)public class HelloController { @GetMapping(&quot;/hello&quot;) public String hello() { return &quot;Hello Spring Boot!&quot;; }} 启动应用后，访问 http://localhost:8080/api/hello，你会看到 Hello Spring Boot! 的返回内容。 6.2 创建一个简单的服务层（Service）123456@Servicepublic class UserService { public String getUserName() { return &quot;John Doe&quot;; }} 6.3 创建一个简单的控制器层（Controller）调用服务层123456789101112@RestController@RequestMapping(&quot;/user&quot;)public class UserController { @Autowired private UserService userService; @GetMapping(&quot;/name&quot;) public String getUserName() { return userService.getUserName(); }} 7. Spring Boot 数据库操作7.1 使用 Spring Data JPA12345678@Entitypublic class User { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; private String name; private String email;} 12public interface UserRepository extends JpaRepository&lt;User, Long&gt; {} 通过简单定义 UserRepository 接口，Spring Data JPA 会自动生成常用的数据操作方法（如 findAll、save、deleteById）。 8. Spring Boot 测试Spring Boot 提供了集成测试功能，使用 @SpringBootTest 注解可以方便地进行单元测试和集成测试： 12345678@SpringBootTestpublic class DemoApplicationTests { @Test public void contextLoads() { // 测试 Spring 上下文加载 }} 9. 部署 Spring Boot 应用 打包项目： 使用以下命令将项目打包成 JAR 文件： 1mvn clean package 运行 JAR 文件： 1java -jar target/my-springboot-project.jar 希望这些基础内容能帮助你快速理解和上手 Spring Boot！ demo下面是一个简单的 Vue + Spring Boot 的 Demo，演示前后端分离开发，通过 Vue 作为前端框架和 Spring Boot 作为后端提供 RESTful API，前端请求后端数据并显示在页面上。 1. 创建 Spring Boot 后端项目1.1 创建 Spring Boot 项目 访问 Spring Initializr，选择以下配置： Project: Maven Project Language: Java Spring Boot Version: 最新版本（例如 3.x 或 2.7.x） Group: com.example Artifact: springboot-vue-demo Dependencies: Spring Web: 提供 RESTful API 支持 Spring Data JPA: 数据持久化层支持 H 2 Database: 内存数据库（用于开发和测试） Lombok: 简化实体类的开发 点击 Generate 按钮下载项目并解压。 在 IDE 中（如 IntelliJ IDEA 或 Eclipse）导入项目。 1.2 配置 Spring Boot 应用 在 src/main/resources/application.properties 中添加以下配置： 12345678910# 配置 H2 数据库spring.datasource.url=jdbc:h2:mem:testdbspring.datasource.driverClassName=org.h2.Driverspring.datasource.username=saspring.datasource.password=passwordspring.h2.console.enabled=true# JPA 配置spring.jpa.show-sql=truespring.jpa.hibernate.ddl-auto=update 1.3 创建后端实体类、仓库和控制器 创建实体类 User 在 src/main/java/com/example/springbootvuedemo/entity/User.java 中创建一个简单的实体类： 123456789101112131415161718192021package com.example.springbootvuedemo.entity;import jakarta.persistence.Entity;import jakarta.persistence.GeneratedValue;import jakarta.persistence.GenerationType;import jakarta.persistence.Id;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;@Entity@Data@NoArgsConstructor@AllArgsConstructorpublic class User { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; private String name; private String email;} 创建仓库接口 UserRepository 在 src/main/java/com/example/springbootvuedemo/repository/UserRepository.java 中创建一个 JPA 仓库接口： 1234567package com.example.springbootvuedemo.repository;import com.example.springbootvuedemo.entity.User;import org.springframework.data.jpa.repository.JpaRepository;public interface UserRepository extends JpaRepository&lt;User, Long&gt; {} 创建 RESTful 控制器 UserController 在 src/main/java/com/example/springbootvuedemo/controller/UserController.java 中创建控制器类： 123456789101112131415161718192021222324252627package com.example.springbootvuedemo.controller;import com.example.springbootvuedemo.entity.User;import com.example.springbootvuedemo.repository.UserRepository;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.*;import java.util.List;@RestController@RequestMapping(&quot;/api/users&quot;)@CrossOrigin // 允许跨域请求public class UserController { @Autowired private UserRepository userRepository; @GetMapping public List&lt;User&gt; getAllUsers() { return userRepository.findAll(); } @PostMapping public User createUser(@RequestBody User user) { return userRepository.save(user); }} 初始化数据 在 src/main/java/com/example/springbootvuedemo/DemoApplication.java 的启动类中添加初始化数据： 1234567891011121314151617181920212223242526package com.example.springbootvuedemo;import com.example.springbootvuedemo.entity.User;import com.example.springbootvuedemo.repository.UserRepository;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.CommandLineRunner;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class DemoApplication implements CommandLineRunner { @Autowired private UserRepository userRepository; public static void main(String[] args) { SpringApplication.run(DemoApplication.class, args); } @Override public void run(String... args) throws Exception { // 初始化一些测试数据 userRepository.save(new User(null, &quot;John Doe&quot;, &quot;john.doe@example.com&quot;)); userRepository.save(new User(null, &quot;Jane Roe&quot;, &quot;jane.roe@example.com&quot;)); }} 1.4 启动后端服务启动 Spring Boot 项目（运行 DemoApplication），后端服务会监听在 http://localhost:8080，并且提供以下 RESTful API： GET http://localhost:8080/api/users：获取所有用户列表 POST http://localhost:8080/api/users：添加新用户 2. 创建 Vue 前端项目2.1 使用 Vue CLI 创建项目 确保已经安装了 Vue CLI（如果没有安装，可以使用 npm install -g @vue/cli 安装）。 在终端中执行以下命令创建 Vue 项目： 1vue create vue-frontend 选择 Default ([Vue 2] babel, eslint) 或 Vue 3，然后等待项目创建完成。 进入项目目录并启动 Vue 开发服务器： 12cd vue-frontendnpm run serve 2.2 修改 Vue 项目结构 在 src 目录中创建一个新的组件文件 UserList.vue： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;template&gt; &lt;div&gt; &lt;h1&gt;User List&lt;/h1&gt; &lt;table border=&quot;1&quot;&gt; &lt;tr&gt; &lt;th&gt;ID&lt;/th&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th&gt;Email&lt;/th&gt; &lt;/tr&gt; &lt;tr v-for=&quot;user in users&quot; :key=&quot;user.id&quot;&gt; &lt;td&gt;{{ user.id }}&lt;/td&gt; &lt;td&gt;{{ user.name }}&lt;/td&gt; &lt;td&gt;{{ user.email }}&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import axios from 'axios';export default { data() { return { users: [] }; }, mounted() { this.getUsers(); }, methods: { async getUsers() { try { const response = await axios.get('http://localhost:8080/api/users'); this.users = response.data; } catch (error) { console.error(&quot;There was an error!&quot;, error); } } }};&lt;/script&gt;&lt;style&gt;table { width: 100%; border-collapse: collapse;}th, td { padding: 8px; text-align: left;}&lt;/style&gt; 修改 src/App.vue 文件，将组件引入并使用： 123456789101112131415&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;UserList /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import UserList from './components/UserList.vue';export default { components: { UserList }};&lt;/script&gt; 安装 axios 依赖（用于 HTTP 请求）： 1npm install axios 2.3 运行并测试前后端 启动 Vue 开发服务器： 1npm run serve 启动 Spring Boot 后端服务器： 访问 http://localhost:8080/api/users 查看后端数据。 在浏览器中访问 http://localhost:8081，前端页面会展示所有用户信息。 3. 实现跨域访问由于前后端分离，Vue 前端会遇到跨域问题。为了解决跨域问题，可以在 Spring Boot 控制器类上添加 @CrossOrigin 注解，也可以在 application.properties 中添加以下配置： 12# 允许所有来源访问后端 APIspring.mvc.cors.allowed-origins=* 这样，Vue 前端和 Spring Boot 后端就可以无障碍地通信了。 4. 项目运行效果 启动后，Vue 前端展示了用户列表，并通过 HTTP 请求实时从 Spring Boot 后端获取数据，达到前后端分离开发的效果。","link":"/2024/10/06/web%E5%BC%80%E5%8F%91%EF%BC%88%E5%B7%B2%E5%AE%8C%E6%88%90%EF%BC%89/"},{"title":"web开发知识储备","text":"AI生成，很杂。 前后端交互前端和后端的交互是现代 Web 应用程序开发中的核心部分。通常，前端（用户界面）通过网络协议（如 HTTP/HTTPS）向后端（服务器）发送请求，后端接收这些请求、处理数据并返回结果。这种交互可以通过多种方式实现，以下是常见的交互流程和技术： 1. 基本的前后端交互流程 前端发起请求：用户在前端界面上执行操作（例如点击按钮、提交表单）。这些操作通常会通过 JavaScript 触发 HTTP 请求（GET、POST、PUT、DELETE 等）。 后端处理请求：后端服务器收到请求后，会调用相应的控制器或服务逻辑来处理请求，进行数据库查询、业务逻辑处理等。 后端返回响应：处理完请求后，后端将结果（通常是 JSON、XML 等格式的数据）作为 HTTP 响应返回给前端。 前端处理响应：前端接收到后端返回的数据后，会更新用户界面（如展示数据、跳转页面、弹出提示信息等）。 Ajax（Asynchronous JavaScript and XML）和Fetch是 Web 开发中用于向服务器发送异步请求并接收数据的两种常见技术。它们允许网页在不刷新整个页面的情况下与服务器进行通信。这种异步通信方式提高了用户体验，并成为现代 Web 开发的关键技术之一。 2.1.AjaxAjax 是一种在 JavaScript 中发起 HTTP 请求的技术。尽管名字中带有 XML，但实际上它可以使用任何格式进行数据传输（例如，JSON、HTML、纯文本等）。Ajax 的核心是 XMLHttpRequest 对象（XHR），这是一种原生的 JavaScript API。 1. Ajax 的工作原理Ajax 的基本工作流程如下： 浏览器事件触发：用户的某些操作（如按钮点击、表单提交等）会触发 JavaScript 代码。 JavaScript 发起 HTTP 请求：使用 XMLHttpRequest 对象向服务器发送请求。 服务器处理请求：服务器接收到请求后，执行相应的操作（如查询数据库、计算、返回数据等）。 JavaScript 处理响应：当服务器返回数据后，JavaScript 会处理这个响应，更新页面的部分内容，而无需重新加载整个页面。 2. Ajax 请求示例以下是使用 XMLHttpRequest 发起 GET 请求并处理响应的一个简单例子： 12345678910111213141516171819// 创建XMLHttpRequest对象var xhr = new XMLHttpRequest();// 初始化请求xhr.open('GET', 'https://api.example.com/data', true);// 设置回调函数，监听状态变化xhr.onreadystatechange = function() { if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) { // 请求成功，处理响应 console.log(xhr.responseText); // 可以将JSON解析为对象 var data = JSON.parse(xhr.responseText); console.log(data); }};// 发送请求xhr.send(); 3. Ajax 中常用的属性和方法 **open (method, url, async)**：初始化请求。method 为 HTTP 方法（如 GET、POST），url 是请求的 URL，async 表示请求是否异步。 **send (data)**：发送请求。对于 GET 请求，data 通常为空；对于 POST 请求，data 可以是提交的数据。 onreadystatechange：当 readyState 变化时触发的回调函数，readyState 表示请求的不同状态（例如，发送请求、接收响应等）。 status：HTTP 状态码，200 表示请求成功。 responseText：服务器返回的响应文本。 4. Ajax 中的状态码 readyState：表示 XMLHttpRequest 对象的状态。 0: 请求未初始化。 1: 服务器连接已建立。 2: 请求已接收。 3: 请求处理中。 4: 请求完成，且响应已准备好。 5. Ajax 的优缺点 优点： 页面无需刷新即可与服务器通信。 用户体验流畅、响应迅速。 灵活支持各种数据格式（JSON、XML、HTML、纯文本等）。 缺点： 代码较为冗长，尤其是处理多个回调函数时，易出现嵌套和混乱。 异步处理逻辑可能导致“回调地狱”（Callback Hell）。 2.2、FetchFetch API 是现代 JavaScript 中的原生 API，用于发起 HTTP 请求，代替了传统的 XMLHttpRequest。相比于 Ajax，Fetch API 提供了更简单、灵活的语法，并基于 Promise 机制，简化了异步处理，避免了复杂的回调嵌套问题。 1. Fetch 的工作原理Fetch 的工作原理和 Ajax 类似，都是发起 HTTP 请求并处理服务器的响应。不过，Fetch API 使用 Promise，这意味着你可以轻松地链式处理异步操作并捕获错误。 2. Fetch 请求示例以下是使用 fetch 发起 GET 请求的一个简单示例： 12345678910111213fetch('https://api.example.com/data') .then(response =&gt; { if (!response.ok) { throw new Error('Network response was not ok'); } return response.json(); // 将响应解析为JSON }) .then(data =&gt; { console.log(data); // 处理成功的响应数据 }) .catch(error =&gt; { console.error('There was a problem with the fetch operation:', error); }); 3. Fetch API 的特点 Promise：fetch 基于 Promise，因此可以使用 then() 和 catch() 处理成功或失败的情况。这使得代码更简洁、易于阅读。 响应处理：Fetch API 默认不直接返回响应数据，而是返回一个包含响应的 Response 对象。需要调用相应的解析方法（如 json()、text()、blob() 等）来提取数据。 支持各种 HTTP 方法：可以通过 fetch() 的配置对象传递方法、请求头、主体数据等。 4. POST 请求示例发送 POST 请求时，可以通过 fetch() 的第二个参数配置请求方法和发送的数据： 1234567891011121314fetch('https://api.example.com/data', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ name: 'John', age: 30 })}) .then(response =&gt; response.json()) .then(data =&gt; { console.log('Success:', data); }) .catch(error =&gt; { console.error('Error:', error); }); 5. 常用属性和方法 **fetch (url, [options])**：发起请求，url 为请求地址，options 为可选的配置对象（如 method、headers、body 等）。 response. ok：布尔值，表示响应是否成功（状态码在 200-299 之间）。 response. status：HTTP 状态码。 **response.json ()**：将响应体解析为 JSON 对象。 **response.text ()**：将响应体解析为纯文本。 **response.blob ()**：将响应体解析为二进制大对象（文件、图片等）。 6. Fetch 的优缺点 优点： 更简洁的语法，基于 Promise，链式调用使代码更易读。 内置的错误处理机制，可以通过 catch() 轻松捕获错误。 默认支持 CORS（跨域资源共享）。 缺点： 旧版浏览器不完全支持 Fetch，需要使用 Polyfill。 fetch 不会在网络错误时自动抛出异常，比如 404 或 500 错误，开发者需要手动检查 response.ok。 2.3、Ajax 和 Fetch 特性 Ajax (XMLHttpRequest) Fetch 请求方式 基于 XMLHttpRequest 对象 基于 Promise 语法 相对复杂，回调较多 简洁、链式调用 支持的 HTTP 方法 GET, POST, PUT, DELETE 等 GET, POST, PUT, DELETE 等 数据格式支持 JSON, XML, HTML, 文本等 JSON, 文本, Blob 等 错误处理 状态码检查麻烦 使用 catch() 捕获错误 跨域支持 需要手动设置 CORS 默认支持 CORS 浏览器兼容性 兼容性好，几乎所有浏览器支持 部分老版本浏览器需要 Polyfill Ajax 是一种早期的异步请求方式，基于 XMLHttpRequest，可以灵活控制请求和响应，但代码复杂度较高，尤其在处理异步回调时容易陷入“回调地狱”。 Fetch 是现代的替代方案，基于 Promise，提供了更加简洁的 API，使异步请求的处理更加直观和简化，广泛应用于现代 JavaScript 开发中。 在新项目中，推荐使用 Fetch API 进行异步通信，因为它不仅语法更简洁，还具备更好的可读性和易维护性。 3.跨域问题跨域问题是前后端分离架构中常见的一个问题。跨域（CORS，Cross-Origin Resource Sharing）是指浏览器出于安全性考虑，阻止网页从一个域（Origin）向另一个域发起请求。跨域请求的限制是浏览器的同源策略（Same-Origin Policy）导致的。为了确保用户信息的安全，浏览器默认会拦截不同源的 HTTP 请求，除非服务器明确允许跨域请求。 同源策略是 Web 浏览器的一个安全机制，要求页面的协议、域名、端口号都相同，才能相互访问资源。如果有任何一个不相同，就会被视为跨域。 同源策略具体限制的行为包括： Cookie、LocalStorage 和 IndexedDB 不能被跨域访问。 DOM 不能被跨域访问。 AJAX 请求 不能发送或接收跨域资源。 跨域问题出现的主要原因是浏览器的同源策略，当协议、域名或端口号不同的情况下，浏览器认为请求是跨域的，通常会拒绝执行。 例如，以下情况会被视为跨域请求： http://www.example.com 向 https://www.example.com 发起请求（协议不同）。 http://www.example.com 向 http://api.example.com 发起请求（域名不同）。 http://www.example.com:80 向 http://www.example.com:8080 发起请求（端口不同）。 跨域问题是前后端分离开发中常见的安全问题，浏览器出于安全考虑默认限制跨域请求。为了处理跨域问题，常见的解决方案包括： CORS：标准的跨域解决方案，通过服务器设置 HTTP 头来允许跨域访问。 JSONP：适用于 GET 请求的跨域方案，但存在一定安全隐患。 服务器代理和 Nginx 反向代理：通过同源服务器转发请求，从而绕过浏览器的跨域限制。 PostMessage 和 WebSocket：用于跨窗口通信和实时双向通信。 在实际项目中，选择哪种跨域处理方式应根据具体场景和需求决定。对于大多数现代 Web 应用，CORS 是最常用且推荐的解决方案。 1. CORS（跨域资源共享）CORS 是解决跨域问题的标准方式。它允许服务器通过设置响应头来告诉浏览器，哪些域名可以访问资源。CORS 主要是通过在服务器端设置特殊的 HTTP 头来实现的。 工作原理：当浏览器发起跨域请求时，会在请求中携带一些特殊的 HTTP 头（如 Origin），服务器根据这些头信息决定是否允许该请求。如果服务器允许跨域访问，会在响应中设置相应的 CORS 头部信息，浏览器则根据这些信息决定是否允许前端代码访问资源。 常见的 CORS 响应头： Access-Control-Allow-Origin：指定允许跨域请求的域名，例如 * 表示允许任何域名跨域请求，或者指定具体域名 https://example.com。 Access-Control-Allow-Methods：指定允许的 HTTP 方法，如 GET、POST、PUT 等。 Access-Control-Allow-Headers：指定允许的自定义请求头，如 Content-Type、Authorization 等。 Access-Control-Allow-Credentials：表示是否允许发送凭据（如 Cookies、HTTP 认证信息）。 示例：1234Access-Control-Allow-Origin: https://example.comAccess-Control-Allow-Methods: GET, POSTAccess-Control-Allow-Headers: Content-Type, AuthorizationAccess-Control-Allow-Credentials: true 在 Java 后端中，可以通过以下代码开启 CORS 支持： 12345678910111213141516171819202122232425import javax.servlet.Filter;import javax.servlet.FilterChain;import javax.servlet.FilterConfig;import javax.servlet.ServletException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class CorsFilter implements Filter { @Override public void init(FilterConfig filterConfig) throws ServletException {} @Override public void doFilter(javax.servlet.ServletRequest req, javax.servlet.ServletResponse res, FilterChain chain) throws IOException, ServletException { HttpServletResponse response = (HttpServletResponse) res; response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;); response.setHeader(&quot;Access-Control-Allow-Methods&quot;, &quot;POST, GET, OPTIONS, DELETE&quot;); response.setHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;Content-Type, Authorization&quot;); response.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;); chain.doFilter(req, res); } @Override public void destroy() {}} 在 Node. js 的 Express 中，可以通过 cors 中间件来启用跨域支持： 123456789101112131415const express = require('express');const cors = require('cors');const app = express();app.use(cors({ origin: 'https://example.com', // 允许指定的域名跨域 methods: ['GET', 'POST'], // 允许的HTTP方法 credentials: true, // 允许携带cookie等凭据}));app.get('/data', (req, res) =&gt; { res.json({ message: 'Hello, world!' });});app.listen(3000); 2. JSONP（JSON with Padding）JSONP 是一种早期的跨域请求解决方案，主要用于 GET 请求。它通过在 HTML 中创建一个 &lt;script&gt; 标签来请求跨域资源，并使用回调函数处理返回的数据。因为 &lt;script&gt; 标签不受同源策略限制，所以可以用来跨域。 JSONP 原理： 前端创建一个 &lt;script&gt; 标签，其 src 属性指向需要跨域的 URL，并附带一个回调函数的参数。 服务器将数据包裹在回调函数中，返回给浏览器，浏览器执行这段脚本，并调用回调函数处理数据。 示例：前端代码： 123456789&lt;script&gt; function handleData(response) { console.log(response); // 处理跨域返回的数据 } var script = document.createElement('script'); script.src = 'https://api.example.com/data?callback=handleData'; document.body.appendChild(script);&lt;/script&gt; 服务器返回的数据格式： 1handleData({ &quot;name&quot;: &quot;John&quot;, &quot;age&quot;: 30 }); 缺点： 只能用于 GET 请求，无法处理 POST、PUT 等请求。 存在安全隐患，如果服务器返回了恶意代码，可能会对页面造成破坏。 3. 服务器代理使用服务器代理是一种常见的解决跨域请求的方法，尤其适用于开发环境。通过在同源服务器上创建一个代理，将前端的请求转发到目标服务器，这样在前端看来，所有请求都由同源服务器发起，避免了浏览器的跨域限制。 工作原理： 前端向同源的代理服务器发起请求。 代理服务器将请求转发到目标服务器，并将响应结果返回给前端。 前端完全不知道这个过程，只看到了代理服务器的响应。 示例：在 Node. js 中设置代理服务器： 12345678910const express = require('express');const request = require('request');const app = express();app.use('/api', (req, res) =&gt; { const url = 'https://api.example.com' + req.url; req.pipe(request(url)).pipe(res);});app.listen(3000); 在开发过程中，像 Vue. js、React 这样的框架也支持配置开发服务器代理。例如，在 Vue 项目中可以在 vue.config.js 中配置代理： 1234567891011module.exports = { devServer: { proxy: { '/api': { target: 'https://api.example.com', changeOrigin: true, pathRewrite: { '^/api': '' } } } }} 4. Nginx 反向代理如果项目部署在 Nginx 服务器上，可以通过 Nginx 的反向代理功能来处理跨域问题。通过配置 Nginx，将前端请求代理到后端服务器。 Nginx 配置示例：123456789101112server { listen 80; server_name example.com; location /api/ { proxy_pass http://api.example.com/; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; }} 5. PostMessagePostMessage 是一种用于跨窗口或跨域消息传递的 API。它允许不同窗口之间（包括 iframe）传递消息，从而可以通过中间的窗口进行数据传递。 示例：父窗口发送消息给 iframe： 12var iframe = document.getElementById('myIframe');iframe.contentWindow.postMessage('Hello from parent', 'https://example.com'); iframe 接收消息： 12345window.addEventListener('message', function(event) { if (event.origin === 'https://parent.com') { console.log(event.data); // 处理来自父窗口的消息 }}); 6. WebSocketsWebSocket 是一种双向通信协议，客户端和服务器可以实时进行通信。WebSocket 并不受同源策略的限制，因此在跨域场景中可以作为一种替代方案。 WebSocket 跨域示例：12345678910111213// 创建一个WebSocket连接const socket = new WebSocket('wss://api.example.com/socket');socket.onopen = function() { console.log('WebSocket connection opened'); socket.send('Hello Server');};socket.onmessage = function(event) { console.log('Message from server:', event.data);}; 前后端分离前后端分离是一种软件架构设计模式，将 Web 应用程序的前端和后端分开，前端主要负责用户界面和用户体验，后端则负责业务逻辑、数据存储和服务器端的处理。前后端通过 API 接口进行通信。 一、前后端分离的定义在前后端分离的架构中，前端和后端相互独立开发、部署，前端通过 API（通常是 REST 或 GraphQL）向后端发送请求，后端返回数据给前端，前端根据返回的数据进行渲染和处理。 前端：通常由 HTML、CSS 和 JavaScript 组成，通过框架（如 React、Vue、Angular 等）来构建动态的单页应用程序（SPA，Single Page Application）。 后端：通常由服务器、数据库和应用程序逻辑组成，通过不同的语言或框架（如 Java、Node. js、Python、PHP、Go 等）来处理业务逻辑和数据存储。 二、前后端分离的优势 开发效率提升：前后端可以并行开发，互不干扰。前端开发人员专注于界面、用户体验和客户端逻辑，后端开发人员专注于业务逻辑、数据处理和性能优化。 技术栈独立：前端和后端可以使用不同的技术栈。例如，前端可以使用现代的 JavaScript 框架（如 React、Vue），后端可以使用 Python、Java、Node. js 等不同的技术来构建服务。 提高可维护性：由于前端和后端是分离的，代码更加模块化，更容易维护和更新，减少耦合性。 前后端分离的团队协作：在分离架构下，前端和后端团队有更清晰的职责分工，便于并行开发，减少了相互依赖的阻碍。 灵活的部署策略：前后端分离后，前端应用可以独立部署在内容分发网络（CDN）上，而后端服务可以通过云服务或服务器集群部署。这样可以提升用户访问的速度和可靠性。 三、前后端分离的实现方式前后端分离的关键是API 接口的定义和通信。目前主流的通信方式有两种： RESTful API： 定义：基于 HTTP 协议的一种架构风格，使用标准的 HTTP 方法（GET、POST、PUT、DELETE 等）来操作资源。API 通常返回 JSON 格式的数据。 优点：轻量级、容易理解和实现，广泛应用于前后端分离的系统中。 缺点：对于复杂的查询可能需要多次 API 调用，效率较低。 示例： 前端请求：12345678fetch('https://api.example.com/users', { method: 'GET', headers: { 'Content-Type': 'application/json' }}).then(response =&gt; response.json()).then(data =&gt; console.log(data)); 后端响应：12345{ &quot;id&quot;: 1, &quot;name&quot;: &quot;John Doe&quot;, &quot;email&quot;: &quot;john.doe@example.com&quot;} GraphQL： 定义：一种查询语言，允许客户端指定需要的具体数据结构，避免了冗余数据的传输。 优点：灵活、减少网络请求次数，客户端可以按需获取数据。 缺点：较为复杂，特别是对于小型项目，学习和实现成本较高。 示例： 前端请求：123456{ user(id: 1) { name email }} 后端响应：12345678{ &quot;data&quot;: { &quot;user&quot;: { &quot;name&quot;: &quot;John Doe&quot;, &quot;email&quot;: &quot;john.doe@example.com&quot; } }} 四、前后端分离的架构模式 单页应用程序（SPA）： 定义：SPA 是一种通过 JavaScript 加载页面内容的 Web 应用程序，只需要加载一次 HTML 框架，后续的数据都通过 API 请求加载，不再刷新整个页面。 优点：用户体验更流畅、响应速度快。 缺点：初次加载时间较长，搜索引擎优化（SEO）相对较难。 常见的 SPA 框架有： React：由 Facebook 开发的组件化框架，使用虚拟 DOM 来提升性能。 Vue. js：一个渐进式 JavaScript 框架，易于上手且灵活性高。 Angular：由 Google 开发的前端框架，提供了完整的解决方案，包括路由、状态管理等。 多页应用程序（MPA）： 定义：传统的 Web 开发模式，每次请求都会加载一个新的 HTML 页面。 优点：适合 SEO 和页面较为独立的应用。 缺点：页面间的切换速度较慢，用户体验稍差。 后端渲染与前端交互的结合： 有些项目会选择结合前后端渲染的方式，即后端负责初次页面的渲染，前端负责交互和后续的数据加载。这种模式可以兼顾 SEO 和用户体验。 五、前后端分离的挑战 接口设计与文档管理：前后端分离后，接口成为了关键的沟通桥梁，如何设计清晰、易于理解和扩展的 API 接口以及完善的接口文档是一个重要的挑战。 可以使用工具如 Swagger 或 Postman 来生成和管理 API 文档。 跨域问题：由于前后端可能运行在不同的域名或端口下，跨域请求会成为一个问题。通常使用 CORS（跨域资源共享）来解决。 安全问题：前后端分离后，前端的代码可能会在客户端暴露出来，如何保护 API 接口的安全性（如认证、加密等）是一个需要重点考虑的问题。 性能优化：前后端分离的架构下，前端和后端的交互会增加网络请求次数，因此需要考虑如何减少请求、使用缓存机制等优化性能。 总结前后端分离是一种提升开发效率、灵活性和可维护性的架构设计模式。通过明确的 API 接口，前后端开发可以并行进行，并且可以灵活选择技术栈和部署方式。在实现前后端分离时，开发团队需要关注接口设计、跨域、安全和性能等问题，以确保系统的稳定性和用户体验。 node. jsNode. js 是一个基于 Chrome V 8 JavaScript 引擎的 JavaScript 运行时环境。它最初由 Ryan Dahl 于 2009 年创建，用于在服务器端运行 JavaScript，摆脱了 JavaScript 只能在浏览器中执行的局限。以下是 Node. js 的一些基础知识和关键概念： 1. 非阻塞 I/O 和事件驱动Node. js 最核心的概念之一是其非阻塞、事件驱动的架构。传统的服务器模型通常是同步的，当一个请求进来时，服务器会等待数据处理完成后才能继续处理下一个请求。而在 Node. js 中，使用异步非阻塞 I/O（输入输出）操作，服务器可以处理多个请求，而不必等待每一个请求处理完成。这大大提高了并发处理能力。 非阻塞 I/O：当 Node. js 执行 I/O 操作（如文件读写、网络请求）时，不会阻塞主线程等待结果，而是通过回调函数处理操作完成后的结果。 事件驱动：Node. js 使用事件循环来处理回调函数。事件循环是一个无限循环，等待事件触发并执行相应的回调函数。 2. 单线程模型尽管 Node. js 是单线程的，它可以通过事件循环和回调机制处理大量并发任务。其单线程模型与浏览器的 JavaScript 运行时环境相似，但与浏览器不同的是，Node. js 提供了服务器端的 I/O API 来处理文件、网络请求等。 3. NPM（Node Package Manager）NPM 是 Node. js 的包管理器，允许开发者安装、共享、使用其他开发者创建的库和工具包。它是世界上最大的开源库之一。 安装包：使用 npm install &lt;package_name&gt; 命令可以安装依赖包。 管理依赖：package.json 文件用于记录项目的依赖项和其他项目元信息，开发者可以在其中定义项目所需的包、脚本、版本等。 4. 模块化系统Node. js 使用 CommonJS 模块系统，允许开发者将代码分割成多个独立的模块。每个文件都是一个模块，通过 require() 函数可以引入其他模块。 导出模块：使用 module.exports 或 exports 来导出一个模块。 导入模块：使用 require() 来导入其他模块。 5. 内置模块Node. js 提供了一些强大的内置模块，用于处理文件系统、网络、HTTP、加密等操作。常见的内置模块有： fs：文件系统模块，用于处理文件读写。 http：用于创建 HTTP 服务器和处理 HTTP 请求。 path：处理文件和目录路径的实用工具。 os：操作系统相关的信息，比如内存、CPU、平台等。 6. 异步编程Node. js 异步编程的核心是回调函数和基于回调的编程模型。然而，随着 JavaScript 语言的发展，Node. js 也支持了更现代的异步处理方式，比如： 回调函数：传统异步模式，常见于早期的 Node. js API。 Promise：现代 JavaScript 中的异步模式，使用 .then() 和 .catch() 链式处理异步任务。 async/await：通过 async 和 await 关键字，允许开发者以更接近同步的方式编写异步代码，提高了可读性。 7. 创建 HTTP 服务器Node. js 常用于构建 HTTP 服务器。利用 http 模块，可以轻松地创建一个服务器并处理客户端请求。 1234567891011const http = require('http');const server = http.createServer((req, res) =&gt; { res.statusCode = 200; res.setHeader('Content-Type', 'text/plain'); res.end('Hello World\\n');});server.listen(3000, () =&gt; { console.log('Server running at http://localhost:3000/');}); 这个简单的例子创建了一个 HTTP 服务器，监听端口 3000，并响应 “Hello World”。 8. Express 框架尽管 Node. js 原生支持创建 HTTP 服务器，很多开发者会选择使用 Express 这样的轻量级框架来简化路由、请求处理等任务。Express 是一个基于 Node. js 的 Web 框架，非常适合用于快速构建 Web 应用和 API。 12345678910const express = require('express');const app = express();app.get('/', (req, res) =&gt; { res.send('Hello World');});app.listen(3000, () =&gt; { console.log('Server running at http://localhost:3000/');}); 9. 文件系统操作Node. js 中的 fs 模块用于与文件系统交互，允许你读取、写入、删除文件等。 读取文件： 123456789const fs = require('fs');fs.readFile('example.txt', 'utf8', (err, data) =&gt; { if (err) { console.error(err); return; } console.log(data);}); 写入文件： 123456789const fs = require('fs');fs.writeFile('example.txt', 'Hello, Node.js', (err) =&gt; { if (err) { console.error(err); return; } console.log('File has been written');}); 10. 环境变量与配置为了在开发和生产环境中管理不同的配置，Node. js 支持通过环境变量来进行配置。常见的做法是使用 .env 文件存储环境变量，然后通过 process.env 来访问这些变量。 1console.log(process.env.PORT); // 打印环境变量 PORT 的值 11. 调试与错误处理Node. js 提供了一些调试和错误处理的工具和方式。开发者可以通过 console.log() 进行简单的日志输出，或者使用内置的调试工具 node inspect 进行代码调试。同时，Node. js 也支持捕获全局未捕获的异常（uncaughtException），但更推荐的做法是使用 try...catch 捕获局部异常。 总结Node. js 是一个强大的工具，适合用于构建高并发、I/O 密集型的应用程序，如实时聊天、流媒体应用和 API 服务器等。通过其事件驱动、非阻塞 I/O 模型，Node. js 可以处理大量的并发连接，同时还提供了丰富的内置模块和包管理器，使开发者能够快速搭建各种类型的应用。 杂七杂八1. MyBatisMyBatis 是一个优秀的持久层框架，简化了 Java 应用程序对数据库的访问。它通过 XML 或注解将 SQL 语句与 Java 对象绑定，提供了灵活的 SQL 执行、参数传递和结果集映射等功能。 特点： 灵活的 SQL 映射：可以直接编写原生 SQL，因此开发者有完全的控制权，适合复杂查询场景。 自动映射结果集：将数据库查询的结果直接映射到 Java 对象，减少手动映射的工作量。 动态 SQL 支持：支持通过 XML 配置动态生成 SQL，减少冗余代码。 轻量级：相较于 Hibernate 等 ORM 框架，MyBatis 更轻量且灵活。 工作流程： 定义 SQL 映射文件：编写 SQL 查询语句，并通过映射文件（XML 或注解）将 SQL 与 Java 方法进行绑定。 调用 SQL：通过接口或 Mapper 方法调用 SQL 查询，MyBatis 会自动执行并将结果映射到 Java 对象。 示例： 1234&lt;!-- SQL映射文件（XML） --&gt;&lt;select id=&quot;findUserById&quot; resultType=&quot;User&quot;&gt; SELECT * FROM users WHERE id = #{id}&lt;/select&gt; 12// 调用Mapper方法User user = userMapper.findUserById(1); 2. LombokLombok 是一个 Java 库，通过注解的方式简化了 Java 代码的开发，特别是减少了样板代码（如 getter/setter、构造函数、toString 等）的编写。它通过在编译时生成相应的代码，从而使开发者的代码更加简洁和易读。 常用注解： @Getter / @Setter：自动生成类的 getter 和 setter 方法。 @ToString：自动生成 toString() 方法。 @EqualsAndHashCode：自动生成 equals() 和 hashCode() 方法。 @NoArgsConstructor / @AllArgsConstructor：自动生成无参构造函数或全参构造函数。 @Data：组合注解，包含了 @Getter、@Setter、@ToString、@EqualsAndHashCode 和 @RequiredArgsConstructor。 使用示例：1234567import lombok.Data;@Datapublic class User { private String name; private int age;} 在这个示例中，Lombok 会为 User 类自动生成 getName()、setName()、getAge()、setAge()、toString() 等方法。 3. MavenMaven 是一个 Java 项目的构建工具，主要用于项目管理和依赖管理。通过定义项目的 pom.xml 文件，Maven 可以自动下载所需的依赖库、编译代码、运行测试、生成报告、打包和发布项目。 主要功能： 项目管理：Maven 定义了一套标准的项目结构和生命周期，规范了项目的构建过程。 依赖管理：通过 pom.xml 文件定义项目所需的依赖，Maven 自动从中央仓库或其他指定仓库下载依赖库并处理版本冲突。 构建和打包：Maven 支持将 Java 项目编译、测试并打包为 JAR、WAR 等格式。 插件机制：Maven 具有丰富的插件系统，可以扩展其功能（如代码生成、测试覆盖率报告、部署等）。 Maven 项目结构： src/main/java：Java 源代码目录。 src/main/resources：资源文件目录（如配置文件、静态资源）。 src/test/java：测试代码目录。 pom. xml：Maven 配置文件，用于定义依赖、插件等。 示例（pom.xml 文件）：1234567891011121314151617&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;my-app&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;version&gt;2.5.4&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 这个 pom.xml 文件定义了一个 Spring Boot Web 项目，并指定了相应的依赖。 AxiosAxios 是一个基于 Promise 的 HTTP 客户端，可以在 浏览器 和 Node. js 环境中使用。它用于发送 HTTP 请求，比如 GET、POST、PUT、DELETE 等，并处理服务器的响应。Axios 可以简化 HTTP 请求的处理、错误的捕获、请求拦截器和响应拦截器等操作，是前端开发中非常流行的请求库之一。开发者可以轻松地进行 HTTP 请求、处理异步操作、拦截请求和响应以及管理请求的生命周期。它不仅简化了 HTTP 请求的代码，还提供了丰富的配置和功能，广泛应用于 Vue. js、React 等现代 JavaScript 框架中。 Axios 的特点 支持 Promise：Axios 是基于 Promise 设计的，所以与现代 JavaScript 中的异步操作非常兼容。 支持浏览器和 Node. js 环境：不仅可以在前端浏览器中使用，也可以在服务端（Node. js）中运行。 支持请求和响应拦截器：可以在请求或响应被处理之前，进行一些自定义逻辑处理，比如在每个请求中自动添加认证 token 或者统一处理错误响应。 自动转换 JSON：Axios 会自动将响应数据解析为 JSON 格式，并且在请求中自动设置合适的请求头（Content-Type: application/json），让你更轻松地处理数据格式。 支持取消请求：通过 CancelToken，你可以取消一个已经发出的请求，常用于防止重复请求或在用户离开页面时中止请求。 防止 CSRF：Axios 提供了很方便的方式来发送跨站点请求伪造（CSRF）防护令牌。 支持上传和下载进度事件：可以监听文件上传或下载的进度，方便文件传输的处理。 使用 Axios 安装 Axios： 在项目中安装 Axios，可以通过 npm 或者在 HTML 中通过 CDN 引入。 使用 npm 安装： 1npm install axios 在 HTML 中通过 CDN 引入： 1&lt;script src=&quot;https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt; 基本用法： 发送一个简单的 GET 请求： 123456789axios.get('https://jsonplaceholder.typicode.com/posts') .then(function (response) { // 请求成功的处理 console.log(response.data); }) .catch(function (error) { // 请求失败的处理 console.error(error); }); 发送一个 POST 请求： 1234567891011axios.post('https://jsonplaceholder.typicode.com/posts', { title: 'foo', body: 'bar', userId: 1 }) .then(function (response) { console.log(response.data); }) .catch(function (error) { console.error(error); }); **使用 async/await**： 结合现代 JavaScript 的 async/await 语法，代码会更加简洁： 12345678910async function getPosts() { try { const response = await axios.get('https://jsonplaceholder.typicode.com/posts'); console.log(response.data); } catch (error) { console.error(error); }}getPosts(); 发送带参数的请求： 使用 GET 请求带有查询参数的 API 调用，可以通过 params 来传递： 1234567891011axios.get('https://jsonplaceholder.typicode.com/posts', { params: { userId: 1 }}).then(function (response) { console.log(response.data);}).catch(function (error) { console.error(error);}); 发送自定义请求： 你可以自定义请求的所有参数，包括方法、URL、请求头、数据等： 123456789101112131415161718axios({ method: 'post', url: 'https://jsonplaceholder.typicode.com/posts', data: { title: 'foo', body: 'bar', userId: 1 }, headers: { 'Content-Type': 'application/json' }}).then(function (response) { console.log(response.data);}).catch(function (error) { console.error(error);}); 常用功能 设置全局配置： 可以为 Axios 设置全局默认配置，比如默认的 API 基础 URL 或请求超时： 123axios.defaults.baseURL = 'https://api.example.com';axios.defaults.timeout = 10000; // 超时时间设置为 10 秒axios.defaults.headers.common['Authorization'] = 'Bearer token'; 请求和响应拦截器： 拦截器可以在请求发送前或响应返回前进行处理。常见的用法是添加认证 token 或者统一处理错误。 请求拦截器： 12345678axios.interceptors.request.use(function (config) { // 在发送请求之前做一些处理 console.log('请求发送前的处理'); return config;}, function (error) { // 处理请求错误 return Promise.reject(error);}); 响应拦截器： 12345678axios.interceptors.response.use(function (response) { // 对响应数据进行处理 return response;}, function (error) { // 对响应错误做一些处理 console.error('响应错误处理'); return Promise.reject(error);}); 取消请求： 在某些场景下，你可能需要取消已经发出的请求。比如用户切换页面时，你可以中止未完成的请求： 1234567891011const CancelToken = axios.CancelToken;let cancel;axios.get('/some-endpoint', { cancelToken: new CancelToken(function executor(c) { cancel = c; // 保存取消函数 })});// 取消请求cancel('请求被取消'); 上传和下载进度： 监听文件上传或下载的进度，可以使用 onUploadProgress 和 onDownloadProgress： 123456axios.post('/upload', formData, { onUploadProgress: function (progressEvent) { let percentCompleted = Math.round((progressEvent.loaded * 100) / progressEvent.total); console.log(percentCompleted); }}); 常见错误处理 处理 HTTP 错误：可以在 catch 中捕获服务器返回的 HTTP 错误，并根据 response.status 做不同的处理： 12345678910111213141516axios.get('/some-endpoint') .then(response =&gt; { console.log(response.data); }) .catch(error =&gt; { if (error.response) { // 服务器返回的错误 console.error('服务器返回的错误:', error.response.status); } else if (error.request) { // 请求已经发送，但是没有响应 console.error('请求发送后无响应:', error.request); } else { // 其它错误 console.error('其他错误:', error.message); } }); 超时错误：如果设置了请求超时时间，可以通过 error.code 检测是否发生超时错误： 123456axios.get('/some-endpoint', { timeout: 5000 }) .catch(error =&gt; { if (error.code === 'ECONNABORTED') { console.error('请求超时'); } });","link":"/2024/10/06/web%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86%E5%82%A8%E5%A4%87%EF%BC%88%E5%B7%B2%E5%AE%8C%E6%88%90%EF%BC%89/"},{"title":"docker学习笔记","text":"小白的docker学习全过程 参考文献 黑马程序员Docker快速入门到项目部署，MySQL部署+Nginx部署+docker自定义镜像+DockerCompose项目实战一套搞定_哔哩哔哩_bilibili Ubuntu · Docker – 从入门到实践 (docker-practice.github.io) Docker 教程 | 菜鸟教程 (runoob.com) 介绍 开源的应用容器引擎，基于 GO 语言 可以让开发者打包应用以及依赖报到一个轻量级可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。 概念 镜像 image ，相当于一个 root 文件系统 容器 container ,镜像是静态的定义，容器是镜像运行时的实体，容器可以被创建，启动，停止，删除，暂停等等。 仓库 respository，一个代码控制中心，用来保存镜像,目前 Docker 官方维护了一个公共仓库 Docker Hub。大部分需求都可以通过在 Docker Hub 中直接下载镜像来实现。 Dockerfile ,一个文本文件，包含了构建 Docker 镜像的所有指令。Docker Dockerfile | 菜鸟教程 (runoob.com) Docker Compose, Compose 是用于定义和运行多容器 Docker 应用程序的工具。通过Compose，可以使用 YML 文件来配置应用程序需要的所有服务。然后，使用一个命令，就可以从 YML 文件配置中创建并启动所有服务。Docker Compose | 菜鸟教程 (runoob.com) Swarm 集群管理，Swarm 集群管理 | 菜鸟教程 (runoob.com) 准备1234567891011121314151617181920212223242526272829PS C:\\Users\\zhuyu&gt; wsl --list --verbose NAME STATE VERSION* Ubuntu Running 2PS C:\\Users\\zhuyu&gt; wslWelcome to fish, the friendly interactive shellType help for instructions on how to use fishzyh@QAQ /m/c/U/zhuyu&gt; neofetch .-/+oossssoo+/-. zyh@QAQ `:+ssssssssssssssssss+:` ------- -+ssssssssssssssssssyyssss+- OS: Ubuntu 22.04.3 LTS on Windows 10 x86_64 .ossssssssssssssssssdMMMNysssso. Kernel: 5.15.153.1-microsoft-standard-WSL2 /ssssssssssshdmmNNmmyNMMMMhssssss/ Uptime: 5 mins +ssssssssshmydMMMMMMMNddddyssssssss+ Packages: 521 (dpkg), 6 (snap) /sssssssshNMMMyhhyyyyhmNMMMNhssssssss/ Shell: fish 3.3.1.ssssssssdMMMNhsssssssssshNMMMdssssssss. Terminal: Windows Terminal+sssshhhyNMMNyssssssssssssyNMMMysssssss+ CPU: 11th Gen Intel i5-1135G7 (8) @ 2.419GHzossyNMMMNyMMhsssssssssssssshmmmhssssssso GPU: 613e:00:00.0 Microsoft Corporation Device 008eossyNMMMNyMMhsssssssssssssshmmmhssssssso Memory: 525MiB / 7808MiB+sssshhhyNMMNyssssssssssssyNMMMysssssss+.ssssssssdMMMNhsssssssssshNMMMdssssssss. /sssssssshNMMMyhhyyyyhdNMMMNhssssssss/ +sssssssssdmydMMMMMMMMddddyssssssss+ /ssssssssssshdmNNNNmyNMMMMhssssss/ .ossssssssssssssssssdMMMNysssso. -+sssssssssssssssssyyyssss+- `:+ssssssssssssssssss+:` .-/+oossssoo+/-.zyh@QAQ /m/c/U/zhuyu&gt; 解释检查 WSL 安装状态：wsl --list --verbose进入 WSL：wsl展示系统信息： neofetch 是一个命令行工具，用于显示系统信息和操作系统的 ASCII 艺术图案。 安装我按照这个教程来的：Ubuntu · Docker – 从入门到实践 (docker-practice.github.io) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239Welcome to fish, the friendly interactive shellType help for instructions on how to use fishzyh@QAQ ~&gt; $ sudo apt-get updatefish: Expected a variable name after this $.zyh@QAQ ~&gt; $ sudo apt-get updatefish: Expected a variable name after this $.zyh@QAQ ~&gt; sudo apt-get update[sudo] password for zyh:Hit:1 http://mirrors.matrix.moe/ubuntu jammy InReleaseGet:2 http://mirrors.matrix.moe/ubuntu jammy-updates InRelease [128 kB]Get:3 http://mirrors.matrix.moe/ubuntu jammy-backports InRelease [127 kB]Get:4 http://mirrors.matrix.moe/ubuntu jammy-security InRelease [129 kB]Get:5 http://mirrors.matrix.moe/ubuntu jammy-updates/main amd64 Packages [2058 kB]Get:6 http://mirrors.matrix.moe/ubuntu jammy-updates/main Translation-en [355 kB]Get:7 http://mirrors.matrix.moe/ubuntu jammy-updates/main amd64 c-n-f Metadata [17.8 kB]Get:8 http://mirrors.matrix.moe/ubuntu jammy-updates/restricted amd64 Packages [2495 kB]Get:9 http://mirrors.matrix.moe/ubuntu jammy-updates/restricted Translation-en [429 kB]Get:10 http://mirrors.matrix.moe/ubuntu jammy-updates/universe amd64 Packages [1124 kB]Get:11 http://mirrors.matrix.moe/ubuntu jammy-updates/universe Translation-en [261 kB]Get:12 http://mirrors.matrix.moe/ubuntu jammy-updates/universe amd64 c-n-f Metadata [26.1 kB]Get:13 http://mirrors.matrix.moe/ubuntu jammy-backports/universe amd64 Packages [28.8 kB]Get:14 http://mirrors.matrix.moe/ubuntu jammy-backports/universe amd64 c-n-f Metadata [672 B]Get:15 http://mirrors.matrix.moe/ubuntu jammy-security/main amd64 Packages [1839 kB]Get:16 http://mirrors.matrix.moe/ubuntu jammy-security/main Translation-en [298 kB]Get:17 http://mirrors.matrix.moe/ubuntu jammy-security/main amd64 c-n-f Metadata [13.3 kB]Get:18 http://mirrors.matrix.moe/ubuntu jammy-security/restricted amd64 Packages [2431 kB]Get:19 http://mirrors.matrix.moe/ubuntu jammy-security/restricted Translation-en [418 kB]Get:20 http://mirrors.matrix.moe/ubuntu jammy-security/universe amd64 Packages [903 kB]Get:21 http://mirrors.matrix.moe/ubuntu jammy-security/universe Translation-en [177 kB]Get:22 http://mirrors.matrix.moe/ubuntu jammy-security/universe amd64 c-n-f Metadata [19.3 kB]Fetched 13.3 MB in 5s (2688 kB/s)Reading package lists... Donezyh@QAQ ~&gt; sudo apt-get install \\ apt-transport-https \\ ca-certificates \\ curl \\ gnupg \\ lsb-releaseReading package lists... DoneBuilding dependency tree... DoneReading state information... Donelsb-release is already the newest version (11.1.0ubuntu4).lsb-release set to manually installed.ca-certificates is already the newest version (20230311ubuntu0.22.04.1).ca-certificates set to manually installed.gnupg is already the newest version (2.2.27-3ubuntu2.1).gnupg set to manually installed.The following additional packages will be installed: libcurl4The following NEW packages will be installed: apt-transport-httpsThe following packages will be upgraded: curl libcurl42 upgraded, 1 newly installed, 0 to remove and 144 not upgraded.Need to get 485 kB of archives.After this operation, 172 kB of additional disk space will be used.Do you want to continue? [Y/n] yGet:1 http://mirrors.matrix.moe/ubuntu jammy-updates/universe amd64 apt-transport-https all 2.4.13 [1510 B]Get:2 http://mirrors.matrix.moe/ubuntu jammy-updates/main amd64 curl amd64 7.81.0-1ubuntu1.18 [194 kB]Get:3 http://mirrors.matrix.moe/ubuntu jammy-updates/main amd64 libcurl4 amd64 7.81.0-1ubuntu1.18 [289 kB]Fetched 485 kB in 0s (1154 kB/s)Selecting previously unselected package apt-transport-https.(Reading database ... 28748 files and directories currently installed.)Preparing to unpack .../apt-transport-https_2.4.13_all.deb ...Unpacking apt-transport-https (2.4.13) ...Preparing to unpack .../curl_7.81.0-1ubuntu1.18_amd64.deb ...Unpacking curl (7.81.0-1ubuntu1.18) over (7.81.0-1ubuntu1.14) ...Preparing to unpack .../libcurl4_7.81.0-1ubuntu1.18_amd64.deb ...Unpacking libcurl4:amd64 (7.81.0-1ubuntu1.18) over (7.81.0-1ubuntu1.14) ...Setting up apt-transport-https (2.4.13) ...Setting up libcurl4:amd64 (7.81.0-1ubuntu1.18) ...Setting up curl (7.81.0-1ubuntu1.18) ...Processing triggers for man-db (2.10.2-1) ...Processing triggers for libc-bin (2.35-0ubuntu3.4) ...zyh@QAQ ~&gt; curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpgzyh@QAQ ~&gt; echo \\ &quot;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://mirrors.aliyun.com/docker-ce/linux/ubuntu \\ $(lsb_release -cs) stable&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/nullfish: $(...) is not supported. In fish, please use '(lsb_release)'. $(lsb_release -cs) stable&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null^zyh@QAQ ~&gt; echo \\ &quot;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://mirrors.aliyun.com/docker-ce/linux/ubuntu \\ $(lsb_release -cs) stable&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/nullfish: $(...) is not supported. In fish, please use '(lsb_release)'. $(lsb_release -cs) stable&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null^zyh@QAQ ~&gt; echo \\ &quot;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://mirrors.aliyun.com/docker-ce/linux/ubuntu \\ $(lsb_release -cs) stable&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null echo \\ &quot;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://mirrors.aliyun.com/docker-ce/linux/ubuntu \\ (lsb_release -cs) stable&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/nullfish: $(...) is not supported. In fish, please use '(lsb_release)'. $(lsb_release -cs) stable&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null^zyh@QAQ ~&gt; echo \\ &quot;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://mirrors.aliyun.com/docker-ce/linux/ubuntu \\ $(lsb_release -cs) stable&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null echo \\ &quot;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://mirrors.aliyun.com/docker-ce/linux/ubuntu \\ (lsb_release -cs) stable&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null ^Czyh@QAQ ~&gt; echo \\ &quot;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://mirrors.aliyun.com/docker-ce/linux/ubuntu \\ (lsb_release -cs) stable&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/nullzyh@QAQ ~&gt; sudo apt-get updateHit:1 http://mirrors.matrix.moe/ubuntu jammy InReleaseHit:2 http://mirrors.matrix.moe/ubuntu jammy-updates InReleaseHit:3 http://mirrors.matrix.moe/ubuntu jammy-backports InReleaseHit:4 http://mirrors.matrix.moe/ubuntu jammy-security InReleaseIgn:5 https://mirrors.aliyun.com/docker-ce/linux/ubuntu (lsb_release InReleaseErr:6 https://mirrors.aliyun.com/docker-ce/linux/ubuntu (lsb_release Release 404 Not Found [IP: 36.250.255.105 443]Reading package lists... DoneE: The repository 'https://mirrors.aliyun.com/docker-ce/linux/ubuntu (lsb_release Release' does not have a Release file.N: Updating from such a repository can't be done securely, and is therefore disabled by default.N: See apt-secure(8) manpage for repository creation and user configuration details.zyh@QAQ ~ [100]&gt; lsb_release -csjammyzyh@QAQ ~&gt; deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://mirrors.aliyun.com/docker-ce/linux/ubuntu jammy stableCommand 'deb' not found, did you mean: command 'dub' from snap dub (1.19.0) command 'den' from snap den (1.2.0-0) command 'dub' from deb dub (1.27.0-2) command 'dcb' from deb iproute2 (5.15.0-1ubuntu2) command 'dab' from deb bsdgames (2.17-29) command 'dex' from deb dex (0.9.0-1) command 'debc' from deb devscripts (2.22.1ubuntu1) command 'edb' from deb edb-debugger (1.3.0-1) command 'deb3' from deb quilt (0.66-2.1) command 'debi' from deb devscripts (2.22.1ubuntu1) command 'derb' from deb icu-devtools (70.1-2)See 'snap info &lt;snapname&gt;' for additional versions.zyh@QAQ ~ [127]&gt; echo &quot;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://mirrors.aliyun.com/docker-ce/linux/ubuntu jammy stable&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/nullzyh@QAQ ~&gt; sudo apt-get updateHit:1 http://mirrors.matrix.moe/ubuntu jammy InReleaseHit:2 http://mirrors.matrix.moe/ubuntu jammy-updates InReleaseHit:3 http://mirrors.matrix.moe/ubuntu jammy-backports InReleaseHit:4 http://mirrors.matrix.moe/ubuntu jammy-security InReleaseGet:5 https://mirrors.aliyun.com/docker-ce/linux/ubuntu jammy InRelease [48.8 kB]Get:6 https://mirrors.aliyun.com/docker-ce/linux/ubuntu jammy/stable amd64 Packages [39.3 kB]Fetched 88.2 kB in 1s (122 kB/s)Reading package lists... Donezyh@QAQ ~&gt; sudo apt-get install docker-ce docker-ce-cli containerd.io docker-compose-pluginReading package lists... DoneBuilding dependency tree... DoneReading state information... DoneThe following additional packages will be installed: dbus-user-session docker-buildx-plugin docker-ce-rootless-extras libslirp0 pigz slirp4netnsSuggested packages: aufs-tools cgroupfs-mount | cgroup-liteThe following NEW packages will be installed: containerd.io dbus-user-session docker-buildx-plugin docker-ce docker-ce-cli docker-ce-rootless-extras docker-compose-plugin libslirp0 pigz slirp4netns0 upgraded, 10 newly installed, 0 to remove and 144 not upgraded.Need to get 122 MB of archives.After this operation, 440 MB of additional disk space will be used.Do you want to continue? [Y/n] yGet:1 https://mirrors.aliyun.com/docker-ce/linux/ubuntu jammy/stable amd64 containerd.io amd64 1.7.22-1 [29.5 MB]Get:2 http://mirrors.matrix.moe/ubuntu jammy/universe amd64 pigz amd64 2.6-1 [63.6 kB]Get:3 http://mirrors.matrix.moe/ubuntu jammy-updates/main amd64 dbus-user-session amd64 1.12.20-2ubuntu4.1 [9442 B]Get:4 http://mirrors.matrix.moe/ubuntu jammy/main amd64 libslirp0 amd64 4.6.1-1build1 [61.5 kB]Get:5 http://mirrors.matrix.moe/ubuntu jammy/universe amd64 slirp4netns amd64 1.0.1-2 [28.2 kB]Get:6 https://mirrors.aliyun.com/docker-ce/linux/ubuntu jammy/stable amd64 docker-buildx-plugin amd64 0.16.2-1~ubuntu.22.04~jammy [29.9 MB]Get:7 https://mirrors.aliyun.com/docker-ce/linux/ubuntu jammy/stable amd64 docker-ce-cli amd64 5:27.2.1-1~ubuntu.22.04~jammy [15.0 MB]Get:8 https://mirrors.aliyun.com/docker-ce/linux/ubuntu jammy/stable amd64 docker-ce amd64 5:27.2.1-1~ubuntu.22.04~jammy [25.6 MB]Get:9 https://mirrors.aliyun.com/docker-ce/linux/ubuntu jammy/stable amd64 docker-ce-rootless-extras amd64 5:27.2.1-1~ubuntu.22.04~jammy [9572 kB]Get:10 https://mirrors.aliyun.com/docker-ce/linux/ubuntu jammy/stable amd64 docker-compose-plugin amd64 2.29.2-1~ubuntu.22.04~jammy [12.5 MB]Fetched 122 MB in 1min 7s (1832 kB/s)Selecting previously unselected package pigz.(Reading database ... 28752 files and directories currently installed.)Preparing to unpack .../0-pigz_2.6-1_amd64.deb ...Unpacking pigz (2.6-1) ...Selecting previously unselected package containerd.io.Preparing to unpack .../1-containerd.io_1.7.22-1_amd64.deb ...Unpacking containerd.io (1.7.22-1) ...Selecting previously unselected package dbus-user-session.Preparing to unpack .../2-dbus-user-session_1.12.20-2ubuntu4.1_amd64.deb ...Unpacking dbus-user-session (1.12.20-2ubuntu4.1) ...Selecting previously unselected package docker-buildx-plugin.Preparing to unpack .../3-docker-buildx-plugin_0.16.2-1~ubuntu.22.04~jammy_amd64.deb ...Unpacking docker-buildx-plugin (0.16.2-1~ubuntu.22.04~jammy) ...Selecting previously unselected package docker-ce-cli.Preparing to unpack .../4-docker-ce-cli_5%3a27.2.1-1~ubuntu.22.04~jammy_amd64.deb ...Unpacking docker-ce-cli (5:27.2.1-1~ubuntu.22.04~jammy) ...Selecting previously unselected package docker-ce.Preparing to unpack .../5-docker-ce_5%3a27.2.1-1~ubuntu.22.04~jammy_amd64.deb ...Unpacking docker-ce (5:27.2.1-1~ubuntu.22.04~jammy) ...Selecting previously unselected package docker-ce-rootless-extras.Preparing to unpack .../6-docker-ce-rootless-extras_5%3a27.2.1-1~ubuntu.22.04~jammy_amd64.deb ...Unpacking docker-ce-rootless-extras (5:27.2.1-1~ubuntu.22.04~jammy) ...Selecting previously unselected package docker-compose-plugin.Preparing to unpack .../7-docker-compose-plugin_2.29.2-1~ubuntu.22.04~jammy_amd64.deb ...Unpacking docker-compose-plugin (2.29.2-1~ubuntu.22.04~jammy) ...Selecting previously unselected package libslirp0:amd64.Preparing to unpack .../8-libslirp0_4.6.1-1build1_amd64.deb ...Unpacking libslirp0:amd64 (4.6.1-1build1) ...Selecting previously unselected package slirp4netns.Preparing to unpack .../9-slirp4netns_1.0.1-2_amd64.deb ...Unpacking slirp4netns (1.0.1-2) ...Setting up dbus-user-session (1.12.20-2ubuntu4.1) ...Setting up docker-buildx-plugin (0.16.2-1~ubuntu.22.04~jammy) ...Setting up containerd.io (1.7.22-1) ...Created symlink /etc/systemd/system/multi-user.target.wants/containerd.service → /lib/systemd/system/containerd.service.Setting up docker-compose-plugin (2.29.2-1~ubuntu.22.04~jammy) ...Setting up docker-ce-cli (5:27.2.1-1~ubuntu.22.04~jammy) ...Setting up libslirp0:amd64 (4.6.1-1build1) ...Setting up pigz (2.6-1) ...Setting up docker-ce-rootless-extras (5:27.2.1-1~ubuntu.22.04~jammy) ...Setting up slirp4netns (1.0.1-2) ...Setting up docker-ce (5:27.2.1-1~ubuntu.22.04~jammy) ...Created symlink /etc/systemd/system/multi-user.target.wants/docker.service → /lib/systemd/system/docker.service.Created symlink /etc/systemd/system/sockets.target.wants/docker.socket → /lib/systemd/system/docker.socket.Processing triggers for man-db (2.10.2-1) ...Processing triggers for libc-bin (2.35-0ubuntu3.4) ...zyh@QAQ ~&gt; sudo systemctl enable dockerSynchronizing state of docker.service with SysV service script with /lib/systemd/systemd-sysv-install.Executing: /lib/systemd/systemd-sysv-install enable dockerzyh@QAQ ~&gt; sudo systemctl start dockerzyh@QAQ ~&gt; sudo groupadd dockergroupadd: group 'docker' already existszyh@QAQ ~ [9]&gt; docker run --rm hello-worlddocker: permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock: Head &quot;http://%2Fvar%2Frun%2Fdocker.sock/_ping&quot;: dial unix /var/run/docker.sock: connect: permission denied.See 'docker run --help'.zyh@QAQ ~ [126]&gt; 解决 Unable to find image 'hello-world:latest' locally 的问题。 1234567891011121314151617181920212223242526272829303132333435363738394041Welcome to fish, the friendly interactive shellType help for instructions on how to use fishzyh@QAQ ~&gt; docker run --rm hello-worldUnable to find image 'hello-world:latest' locallydocker: Error response from daemon: Get &quot;https://registry-1.docker.io/v2/&quot;: context deadline exceeded (Client.Timeout exceeded while awaiting headers).See 'docker run --help'.zyh@QAQ ~ [125]&gt; sudo vim /etc/docker/daemon.json[sudo] password for zyh:zyh@QAQ ~&gt; sudo systemctl daemon-reloadzyh@QAQ ~&gt; sudo systemctl restart dockerzyh@QAQ ~&gt; docker run --rm hello-worldUnable to find image 'hello-world:latest' locallylatest: Pulling from library/hello-worldc1ec31eb5944: Pull completeDigest: sha256:91fb4b041da273d5a3273b6d587d62d518300a6ad268b28628f74997b93171b2Status: Downloaded newer image for hello-world:latestHello from Docker!This message shows that your installation appears to be working correctly.To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub. (amd64) 3. The Docker daemon created a new container from that image which runs the executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it to your terminal.To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bashShare images, automate workflows, and more with a free Docker ID: https://hub.docker.com/For more examples and ideas, visit: https://docs.docker.com/get-started/zyh@QAQ ~&gt; 使用 daocloud 镜像加速： 123456{ &quot;registry-mirrors&quot;: [ &quot;https://docker.m.daocloud.io&quot; ]} `` 使用 查看 docker 版本1docker --version 启动 docker 服务1sudo systemctl start docker 检查 docker 服务状态1sudo systemctl status docker 运行第一个容器1docker run hello-world 或者1docker run --rm hello-world 拉取镜像1docker pull nginx ps: nginx 是一个高性能的 HTTP 和反向代理 web 服务器 列出 docker 镜像1docker images 运行容器1docker run -d -p 8080:80 nginx 会将 nginx 容器的端口 80 投射到宿主机的 8080 端口，可以通过 https://localhost:8080 访问 Nginx 服务。 列出所有容器1docker ps 1docker ps -a 启动容器1docker start XX 停止容器1docker stop XX 删除容器1docker rm XX 删除本地镜像1docker rmi XX 查看容器日志1docker logs XX 进入容器内部1docker exec -it XX /bin/sh docker compose运行以下命令以下载 Docker Compose 的当前稳定版本：将可执行权限应用于二进制文件：创建软链：测试是否安装成功： 1234567891011121314zyh@QAQ ~ [3]&gt; set os (uname -s) set arch (uname -m) sudo curl -L &quot;https://github.com/docker/compose/releases/download/v2.2.2/docker-compose-$os-$arch&quot; -o /usr/local/bin/docker-compose % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed 0 0 0 0 0 0 0 0 --:--:-- 0:00:01 --:--:-- 0100 23.5M 100 23.5M 0 0 55309 0 0:07:25 0:07:25 --:--:-- 47077zyh@QAQ ~&gt; sudo chmod +x /usr/local/bin/docker-compose[sudo] password for zyh:zyh@QAQ ~&gt; sudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-composezyh@QAQ ~&gt; docker-compose --versionDocker Compose version v2.2.2 测试：使用一个简单的 docker-compose.yml 文件来运行一个 Nginx 容器。测试步骤： 创建一个测试文件夹，并进入该文件夹： 12mkdir dockercomposetestcd dockercomposetest 创建一个 docker-compose.yml 文件： 1nano docker-compose.yml 在文件中粘贴以下内容： 123456version: '3'services: web: image: nginx:alpine ports: - &quot;8080:80&quot; 这个文件会使用 nginx:alpine 镜像，并将本地的 8080 端口映射到容器的 80 端口。 运行 Docker Compose： 1sudo docker-compose up 如果 Docker Compose 正常工作，看到下面的输出，表明 Nginx 容器启动成功： 12345678910111213141516171819202122232425262728293031323334353637383940zyh@QAQ ~/dockercomposetest&gt; sudo docker-compose up[+] Running 9/9 ⠿ web Pulled 30.8s ⠿ 43c4264eed91 Pull complete 2.4s ⠿ 5b19511a843d Pull complete 2.6s ⠿ 652d69a25e85 Pull complete 2.6s ⠿ 51676974aef5 Pull complete 2.7s ⠿ bb16f69e8876 Pull complete 2.7s ⠿ 6fb07faa0055 Pull complete 2.7s ⠿ c298c5a0cd21 Pull complete 4.8s ⠿ 0c02f601d0ee Pull complete 12.0s[+] Running 2/2 ⠿ Network dockercomposetest_default Created 0.2s ⠿ Container dockercomposetest-web-1 Created 0.2sAttaching to dockercomposetest-web-1dockercomposetest-web-1 | /docker-entrypoint.sh: /docker-entrypoint.d/ is not empty, will attempt to perform configurationdockercomposetest-web-1 | /docker-entrypoint.sh: Looking for shell scripts in /docker-entrypoint.d/dockercomposetest-web-1 | /docker-entrypoint.sh: Launching /docker-entrypoint.d/10-listen-on-ipv6-by-default.shdockercomposetest-web-1 | 10-listen-on-ipv6-by-default.sh: info: Getting the checksum of /etc/nginx/conf.d/default.confdockercomposetest-web-1 | 10-listen-on-ipv6-by-default.sh: info: Enabled listen on IPv6 in /etc/nginx/conf.d/default.confdockercomposetest-web-1 | /docker-entrypoint.sh: Sourcing /docker-entrypoint.d/15-local-resolvers.envshdockercomposetest-web-1 | /docker-entrypoint.sh: Launching /docker-entrypoint.d/20-envsubst-on-templates.shdockercomposetest-web-1 | /docker-entrypoint.sh: Launching /docker-entrypoint.d/30-tune-worker-processes.shdockercomposetest-web-1 | /docker-entrypoint.sh: Configuration complete; ready for start updockercomposetest-web-1 | 2024/09/24 16:43:16 [notice] 1#1: using the &quot;epoll&quot; event methoddockercomposetest-web-1 | 2024/09/24 16:43:16 [notice] 1#1: nginx/1.27.1dockercomposetest-web-1 | 2024/09/24 16:43:16 [notice] 1#1: built by gcc 13.2.1 20240309 (Alpine 13.2.1_git20240309)dockercomposetest-web-1 | 2024/09/24 16:43:16 [notice] 1#1: OS: Linux 5.15.153.1-microsoft-standard-WSL2dockercomposetest-web-1 | 2024/09/24 16:43:16 [notice] 1#1: getrlimit(RLIMIT_NOFILE): 1048576:1048576dockercomposetest-web-1 | 2024/09/24 16:43:16 [notice] 1#1: start worker processesdockercomposetest-web-1 | 2024/09/24 16:43:16 [notice] 1#1: start worker process 30dockercomposetest-web-1 | 2024/09/24 16:43:16 [notice] 1#1: start worker process 31dockercomposetest-web-1 | 2024/09/24 16:43:16 [notice] 1#1: start worker process 32dockercomposetest-web-1 | 2024/09/24 16:43:16 [notice] 1#1: start worker process 33dockercomposetest-web-1 | 2024/09/24 16:43:16 [notice] 1#1: start worker process 34dockercomposetest-web-1 | 2024/09/24 16:43:16 [notice] 1#1: start worker process 35dockercomposetest-web-1 | 2024/09/24 16:43:16 [notice] 1#1: start worker process 36dockercomposetest-web-1 | 2024/09/24 16:43:16 [notice] 1#1: start worker process 37dockercomposetest-web-1 | 172.19.0.1 - - [24/Sep/2024:16:43:39 +0000] &quot;GET / HTTP/1.1&quot; 200 615 &quot;-&quot; &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/129.0.0.0 Safari/537.36 Edg/129.0.0.0&quot; &quot;-&quot; 打开浏览器并访问 http://localhost:8080，看到 Nginx 的欢迎页面，表明 Docker Compose 运行成功。 停止容器，按 Ctrl+C，然后运行以下命令来清理环境： 1sudo docker-compose down 实战这里以我的项目 project: 基于Springboot+Vue的亚健康管理系统 (gitee.com) 为例，将这个 web 项目部署到 docker 中运行。通过Docker容器化的方式，不需要在本地（Windows或WSL）安装Node.js、MySQL、Java等开发依赖，这些依赖项完全可以由Docker来管理。Docker容器会为每个服务提供一个独立的运行环境，本地机器不需要直接安装这些服务。只需要安装Docker和Docker Compose工具，剩下的依赖都在Docker中管理。通过Git和Docker Compose，团队成员可以轻松启动、重建和管理开发环境，简化协作流程。 项目调研关键信息将一个包含 Vue、Spring Boot 和 MySQL 的项目部署到 Docker 中的过程涉及构建多个 Docker 容器来分别运行前端、后端和数据库。需要考虑以下关键信息： Vue 项目的打包配置： Vue 项目是否已经通过 npm run build 或者 yarn build 进行生产环境打包？ 是否有 Dockerfile 或现成的部署脚本？ Spring Boot 应用的构建方式： Spring Boot 项目是否使用 Maven 或 Gradle 进行构建？ 是否已生成了 .jar 文件，或者是否有 Dockerfile 来构建 Spring Boot 容器？ MySQL 配置： MySQL 数据库的版本？ 数据库的初始化脚本（如有的话）？ MySQL 的数据库配置，是否需要挂载外部数据卷保存数据？ 应用的连接配置： Vue 前端如何连接到 Spring Boot 后端？（例如，API 地址在开发时是否通过代理，或者已经设置为生产环境的 URL） Spring Boot 如何连接 MySQL？是否有外部配置（如 application.properties 或 application.yml 中的数据库连接设置）？ 其他配置： 是否有任何环境变量，配置文件或 secrets 需要传递给容器？ 是否需要使用 Docker Compose 来管理多个容器（例如前端、后端、数据库）？ 实际情况 ： vue项目还没打包，没有dockerfile 2.springboot采用maven构建，没有.jar文件，没有dockerfile 其中pom.xml为：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;3.2.5&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;demo&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;17&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!--SpringMvc--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--mybatis--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.0.3&lt;/version&gt; &lt;/dependency&gt; &lt;!--MySQL--&gt; &lt;dependency&gt; &lt;groupId&gt;com.mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-j&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;!--lombok--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter-test&lt;/artifactId&gt; &lt;version&gt;3.0.3&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-spring-boot3-starter&lt;/artifactId&gt; &lt;version&gt;3.5.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;/groupId&gt; &lt;artifactId&gt;hutool-all&lt;/artifactId&gt; &lt;version&gt;5.8.25&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;excludes&gt; &lt;exclude&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/exclude&gt; &lt;/excludes&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/project&gt; 我不知道mysql的版本；MySQL 的数据库配置需要挂载外部数据卷保存数据 vue前端和springboot后端通过跨域配置进行连接 ,vue.config.js内容为: 1234567891011121314151617181920212223242526272829 // 跨域配置module.exports = { devServer: { //记住，别写错了devServer//设置本地默认端口 选填 //port: 9876, proxy: { //设置代理，必须填 '/api': { //设置拦截器 拦截器格式 斜杠+拦截器名字，名字可以自己定 target: 'http://localhost:9091', //代理的目标地址 changeOrigin: true, //是否设置同源，输入是的 pathRewrite: { //路径重写 '^/api': '' //选择忽略拦截器里面的内容 } } } }} 没有环境变量，配置文件或 secrets 需要传递给容器需要使用 Docker Compose 来管理多个容器，即前端、后端、数据库 大致的部署流程 为 Vue 应用创建 Dockerfile：该 Dockerfile 用于将 Vue 应用打包为静态文件并部署到 Nginx 或其他 web 服务器中。 为 Spring Boot 应用创建 Dockerfile：这个 Dockerfile 将包含 Java 环境和 Spring Boot .jar 文件。 使用 Docker Compose 配置文件：编写 docker-compose.yml 文件，用于启动 Vue 前端、Spring Boot 后端和 MySQL 数据库的三个服务。 方案注意：下面有两种方案，我采取的是方案二 方案一：使用Docker Desktop的WSL集成Docker Desktop，启用WSL 2 集成，这样Docker Desktop会将WSL与Windows的Docker环境整合在一起。 打开Docker Desktop，在设置中启用 WSL 2 integration，并选择你使用的WSL发行版（如Ubuntu）。 在Windows PowerShell或WSL中运行Docker：在Windows的PowerShell中：1cd D:\\Desktop\\project docker-compose up --build 在WSL中：1cd /mnt/d/Desktop/project docker-compose up --build 优点：这种方式将WSL与Windows Docker紧密结合，无论你是在Windows还是WSL中操作Docker，都可以使用相同的Docker环境。 方案二：将项目目录映射到WSL中的文件系统如果你想继续使用WSL中的Docker，而不能直接在WSL中访问Windows文件系统，那么可以通过以下方法解决： 挂载Windows的文件系统到WSL： 在WSL中，Windows的文件系统已经挂载在/mnt/目录下。例如，C:\\盘的文件可以在WSL中通过/mnt/c/访问。 在WSL中访问Windows上的项目： 你可以在WSL中通过/mnt/目录访问Windows的文件。例如，如果你的项目在D:\\Desktop\\project下，你可以在WSL中访问它：1cd /mnt/d/Desktop/project 在WSL中运行Docker命令： 进入项目目录后，你可以在WSL的fish shell中运行Docker命令：1docker-compose up --build 优点： 这种方式允许你使用WSL中的Docker，但仍然能够访问Windows文件系统，避免了项目文件复制的麻烦。 方案三：将项目文件复制到WSL的文件系统中如果你希望项目文件完全在WSL的Linux文件系统中，你可以将项目文件从Windows复制到WSL中，之后再通过WSL的Docker进行操作。 复制项目到WSL：在PowerShell中运行以下命令，将项目复制到WSL的文件系统中（例如，复制到/home/your-user/projects目录）： 1cp -r D:\\Desktop\\project\\health_manage_springboot \\\\wsl$\\Ubuntu\\home\\your-user\\projects\\ 在WSL中进入项目目录：打开WSL的终端，进入项目目录：1cd ~/projects/health_manage_springboot 运行Docker命令：在项目目录下，运行docker-compose up --build命令：1docker-compose up --build 优点：这种方式将项目文件复制到WSL的Linux文件系统中，确保在WSL环境下操作更加流畅，避免文件系统访问的问题。 操作通过创建 Dockerfile、配置 Docker Compose 文件，将前端、后端和数据库拆解为不同的容器。 1. 打包 Vue 项目在部署到 Docker 之前，Vue 项目需要打包成静态文件。 步骤： 确保你已经安装了 Node. js。 在项目根目录下，执行以下命令打包 Vue 项目：12npm installnpm run build 这将生成一个 dist 目录，里面是打包好的静态资源文件。 2. 创建 Vue 的 Dockerfile在 Vue 项目的根目录中，创建一个 Dockerfile，用于构建一个运行 Vue 静态文件的 Nginx 容器。 Dockerfile (Vue)1234567891011121314151617181920212223242526272829303132# 选择node环境作为构建阶段FROM node:16 AS build-stage# 设置工作目录WORKDIR /app# 将package.json和package-lock.json复制到容器中COPY package*.json ./# 安装依赖RUN npm install# 将项目代码复制到容器中COPY . .# 打包项目RUN npm run build# Nginx用于托管打包后的静态文件FROM nginx:alpine AS production-stage# 将Nginx配置文件替换为自定义配置文件COPY nginx.conf /etc/nginx/nginx.conf# 将打包后的静态文件复制到Nginx的html目录COPY --from=build-stage /app/dist /usr/share/nginx/html# 暴露80端口EXPOSE 80# 启动NginxCMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;] Nginx 配置文件 (nginx. conf)你需要创建一个 nginx.conf 文件，指定如何处理前端资源： 1234567891011121314151617181920212223242526272829303132333435# nginx.confworker_processes auto;events { worker_connections 1024;}http { include /etc/nginx/mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; # 配置server块，处理前端请求和API代理 server { listen 80; server_name localhost; location / { root /usr/share/nginx/html; index index.html index.htm; try_files $uri $uri/ /index.html; } # 代理API请求到后端Spring Boot服务 location /api/ { proxy_pass http://backend:9091/; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; } }} 3. 打包 Spring Boot 项目为了将 Spring Boot 项目部署到 Docker 中，我们需要先生成一个可执行的 JAR 文件。 使用系统环境中的Maven： 在项目根目录下，使用 Maven 打包 Spring Boot 项目：1mvn clean package 这将在 target 目录中生成一个 JAR 文件。 IDEA的Maven工具：这里由于我开发时使用的 maven 是 idea 自带的，在终端运行时会报错，故使用 IDE 自带的 Maven 项目进行打包。 打开IntelliJ IDEA，进入Spring Boot项目。 点击右侧的“Maven”工具窗口（如果看不到，可以通过View -&gt; Tool Windows -&gt; Maven来打开）。 展开项目中的Maven模块，找到Lifecycle。 在Lifecycle下，找到clean和package两个任务。 先双击clean，然后再双击package。 这样，IntelliJ IDEA会使用自带的Maven来清理项目并打包为JAR文件。打包完成后，生成的JAR文件会在target目录下。 4. 创建 Spring Boot 的 Dockerfile在 Spring Boot 项目的根目录中，创建一个 Dockerfile，用于构建 Spring Boot 容器。 Dockerfile (Spring Boot)1234567891011121314# 使用openjdk作为基础镜像FROM openjdk:17-jdk-alpine# 设置工作目录WORKDIR /app# 复制打包好的JAR文件到容器中COPY target/demo-0.0.1-SNAPSHOT.jar app.jar# 暴露9091端口EXPOSE 9091# 启动Spring Boot应用ENTRYPOINT [&quot;java&quot;, &quot;-jar&quot;, &quot;app.jar&quot;] 5. MySQL 容器配置为了将 MySQL 运行在 Docker 中，我们可以直接使用官方的 MySQL 镜像，并通过 Docker Compose 配置其数据库、用户和挂载外部数据卷来保存数据。在 6 中可以完成这个需求。 6. 创建 Docker Compose 文件Docker Compose 文件用于管理这三个服务（Vue 前端、Spring Boot 后端、MySQL 数据库）。 docker-compose. yml12345678910111213141516171819202122232425262728293031323334353637383940414243version: '3'services: # Vue前端 frontend: build: context: ./vue-project # 指定Vue项目的根目录 dockerfile: Dockerfile dns: - 8.8.8.8 - 8.8.4.4 #这里指定使用Google DNS服务器（8.8.8.8和8.8.4.4），因为我在npm install时出现ETIMEOUT，故设置Google的公共DNS服务器解决该问题。也可以通过增加网络超时时间或者本地安装依赖导入node_modules解决 ports: - &quot;8080:80&quot; # 将容器的80端口映射到主机的8080端口 depends_on: - backend # 确保后端先启动 # Spring Boot后端 backend: build: context: ./springboot-project # 指定Spring Boot项目的根目录 dockerfile: Dockerfile ports: - &quot;9091:9091&quot; # 映射后端服务端口 environment: SPRING_DATASOURCE_URL: jdbc:mysql://db:3306/health?useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=UTC SPRING_DATASOURCE_USERNAME: root SPRING_DATASOURCE_PASSWORD: 123456 depends_on: - db # 确保数据库先启动 # MySQL数据库 db: image: mysql:8.0 # MySQL镜像 environment: MYSQL_ROOT_PASSWORD: 123456 # 设置root密码 MYSQL_DATABASE: health # 初始化数据库 volumes: - db_data:/var/lib/mysql # 挂载卷，用于持久化存储 - /mnt/d/Desktop/project/health_management.sql:/docker-entrypoint-initdb.d/health_management.sql # 挂载SQL文件 ports: - &quot;3306:3306&quot; # 映射MySQL端口volumes: db_data: # 数据卷用于存储MySQL数据 7. 使用 Docker Compose 启动服务 在 WSL 中导航到项目的根目录1cd /mnt/d/Desktop/project 运行 docker compose 命令1docker-compose up --build 这个命令会： 构建 Vue 前端、Spring Boot 后端和 MySQL 的容器镜像。 使用 Nginx 托管 Vue 前端的静态文件。 将前端请求代理到后端 Spring Boot 应用。 启动 MySQL 并将数据保存在本地挂载卷中。 8. 检查服务是否正常运行 访问 http://localhost:8080 来查看 Vue 前端是否正常工作。 后端 Spring Boot 服务应该在 http://localhost:9091 正常运行。 通过 docker logs &lt;container_name&gt; 查看各个容器的日志，确保一切正常。 如果导入 sql 文件出现问题，检查SQL文件是否已经成功导入：进入 mysql 容器：1docker exec -it &lt;container_id&gt; /bin/bash (用 docker ps -a 获取 container_id)登录 mysql:1mysql -u root t-p 检查数据库中是否有你导入的表和数据：12USE health; SHOW TABLES; 如果 SQL 文件没有挂载成功的话可以采取手动导入 SQL 文件:注意这里的 sql 表格如果你是从 gitee 上直接 clone 的需要删除 CREATE DATABASE health; 这条语句，因为数据库 health 已经存在。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455zyh@QAQ /m/d/D/project (master)&gt; docker exec -it 649ab335c63b /bin/bashbash-5.1# mysql -u root -pEnter password:Welcome to the MySQL monitor. Commands end with ; or \\g.Your MySQL connection id is 13Server version: 8.0.39 MySQL Community Server - GPLCopyright (c) 2000, 2024, Oracle and/or its affiliates.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.mysql&gt; USE health;Reading table information for completion of table and column namesYou can turn off this feature to get a quicker startup with -ADatabase changedmysql&gt; SHOW TABLES;+------------------+| Tables_in_health |+------------------+| body || user |+------------------+2 rows in set (0.00 sec)mysql&gt; SELECT * FROM user;+----+----------+----------+-------------+------+----------------------+--------+| id | username | password | number | role | email | avatar |+----+----------+----------+-------------+------+----------------------+--------+| 1 | gss | 123456 | 13343243242 | 1 | super@aliyun.com | || 2 | zhangsan | 123456 | NULL | 1 | zhangsan@gmail.com | || 3 | lisi | 123456 | NULL | 1 | lisi@gmail.com | || 4 | wangwu | 123456 | NULL | 0 | wangwu@gmail.com | || 5 | zhaoer | 123456 | NULL | 0 | zhaoer@gmail.com | || 6 | songliu | 123456 | 4322432434 | 0 | songliu@gmail.com | || 13 | Alice | 123456 | 234532111 | 0 | alice@example.com | || 14 | Bob | 123456 | 13564736363 | 0 | bob@example.com | || 15 | Charlie | 123456 | 25323626 | 0 | charlie@example.com | || 16 | David1 | 123456 | 145256264 | 0 | david@example.com | || 17 | Emma | 123456 | 152334445 | 0 | emma@example.com | || 18 | Frank | 123456 | 1566543646 | 0 | frank@example.com | || 19 | Grace | 123456 | 1435253535 | 0 | grace@example.com | || 20 | Henry | 123456 | 15325363463 | 0 | henry@example.com | || 21 | Isabella | 123456 | 15353435 | 0 | isabella@example.com | || 22 | Jacob | 123456 | 114523424 | 0 | jacob@example.com | || 31 | test | 123456 | NULL | 0 | | |+----+----------+----------+-------------+------+----------------------+--------+17 rows in set (0.00 sec)mysql&gt; 上述信息表示一切功能正常。 补充 ： 停止正在运行的容器：1docker-compose down 停止并删除所有服务容器、网络和卷（不删除数据卷）再次启动：1docker-compose up --build 停止容器而不删除1docker-compose stop 再次启动：1docker-compose start 查看当前运行的容器1docker ps 包含历史：1docker ps -a","link":"/2024/09/25/docker%E5%AD%A6%E4%B9%A0/"},{"title":"W4terCTF2024 writeup","text":"纯小白，做出的题很少 图片很糊但就先这样吧队友：https://github.com/kuku172放个友链Lst4r-max.github.io Spam 2024先找垃圾邮件，搜了很多东西后找到spammimic - encoded，然后第一步解码： 159,6f,75,20,6c,69,6b,65,20,65,6d,6f,6a,69,73,2c,20,64,6f,6e,27,74,20,79,6f,75,3f,0a,0a,01f643,01f4b5,01f33f,01f3a4,01f6aa,01f30f,01f40e,01f94b,01f6ab,01f606,2705,01f606,01f6b0,01f4c2,01f32a,263a,01f6e9,01f30f,01f4c2,01f579,01f993,01f405,01f375,01f388,01f600,01f504,01f6ab,01f3a4,01f993,2705,01f4ee,01f3a4,01f385,01f34e,01f643,01f309,01f383,01f34d,01f374,01f463,01f6b9,01f923,01f418,01f3f9,263a,01f463,01f4a7,01f463,01f993,01f33f,2328,01f32a,01f30f,01f643,01f375,2753,2602,01f309,01f606,01f3f9,01f375,01f4a7,01f385,01f449,01f30a,01f6b9,01f6aa,01f374,01f60e,01f383,01f32a,01f643,01f441,01f94b,01f451,01f4a7,01f418,01f3a4,01f94b,01f418,01f6e9,01f923,01f309,01f6e9,23e9,01f60d,2753,01f418,01f621,2600,01f60d,01f643,01f601,01f600,01f601,01f6ab,01f4c2,2705,2603,01f6ab,01f60e,01f52a,01f451,01f600,01f579,01f6ab,01f60d,01f32a,01f4c2,01f44c,01f34d,01f44c,01f993,01f590,01f923,01f60e,01f3ce,01f34d,01f3f9,01f34c,01f34d,01f3a4,2600,01f3f9,01f388,01f6b0,01f4a7,2600,2709,01f3f9,01f34d,01f993,01f385,01f374,2602,23e9,01f6aa,01f40d,263a,01f418,01f607,01f621,01f375,01f30f,01f993,01f375,01f6e9,01f4c2,01f44c,01f3f9,01f5d2,01f5d2,0a,0a,42,74,77,2c,20,74,68,65,20,6b,65,79,20,69,73,20,22,4b,45,59,22 前后是ACSII，中间是emoji的unicode。 123456789101112def hex_to_ascii(hex_string): bytes_object = bytes.fromhex(hex_string) ascii_string = bytes_object.decode(&quot;ASCII&quot;) return ascii_stringhex_string1 = &quot;59,6f,75,20,6c,69,6b,65,20,65,6d,6f,6a,69,73,2c,20,64,6f,6e,27,74,20,79,6f,75,3f,0a,0a&quot;hex_string1 = hex_string1.replace(',', '')print(hex_to_ascii(hex_string1)) hex_string2 = &quot;0a,0a,42,74,77,2c,20,74,68,65,20,6b,65,79,20,69,73,20,22,4b,45,59,22&quot;hex_string2 = hex_string2.replace(',', '')print(hex_to_ascii(hex_string2)) 1234unicode_string =&quot;01f643,01f4b5,01f33f,01f3a4,01f6aa,01f30f,01f40e,01f94b,01f6ab,01f606,2705,01f606,01f6b0,01f4c2,01f32a,263a,01f6e9,01f30f,01f4c2,01f579,01f993,01f405,01f375,01f388,01f600,01f504,01f6ab,01f3a4,01f993,2705,01f4ee,01f3a4,01f385,01f34e,01f643,01f309,01f383,01f34d,01f374,01f463,01f6b9,01f923,01f418,01f3f9,263a,01f463,01f4a7,01f463,01f993,01f33f,2328,01f32a,01f30f,01f643,01f375,2753,2602,01f309,01f606,01f3f9,01f375,01f4a7,01f385,01f449,01f30a,01f6b9,01f6aa,01f374,01f60e,01f383,01f32a,01f643,01f441,01f94b,01f451,01f4a7,01f418,01f3a4,01f94b,01f418,01f6e9,01f923,01f309,01f6e9,23e9,01f60d,2753,01f418,01f621,2600,01f60d,01f643,01f601,01f600,01f601,01f6ab,01f4c2,2705,2603,01f6ab,01f60e,01f52a,01f451,01f600,01f579,01f6ab,01f60d,01f32a,01f4c2,01f44c,01f34d,01f44c,01f993,01f590,01f923,01f60e,01f3ce,01f34d,01f3f9,01f34c,01f34d,01f3a4,2600,01f3f9,01f388,01f6b0,01f4a7,2600,2709,01f3f9,01f34d,01f993,01f385,01f374,2602,23e9,01f6aa,01f40d,263a,01f418,01f607,01f621,01f375,01f30f,01f993,01f375,01f6e9,01f4c2,01f44c,01f3f9,01f5d2,01f5d2&quot;unicode_list = unicode_string.split(',')emoji_string = ''.join(chr(int('0x' + uni, 16)) for uni in unicode_list)print(emoji_string) 12You like emojis, don't you?Btw, the key is &quot;KEY&quot; 1🙃💵🌿🎤🚪🌏🐎🥋🚫😆✅😆🚰📂🌪☺🛩🌏📂🕹🦓🐅🍵🎈😀🔄🚫🎤🦓✅📮🎤🎅🍎🙃🌉🎃🍍🍴👣🚹🤣🐘🏹☺👣💧👣🦓🌿⌨🌪🌏🙃🍵❓☂🌉😆🏹🍵💧🎅👉🌊🚹🚪🍴😎🎃🌪🙃👁🥋👑💧🐘🎤🥋🐘🛩🤣🌉🛩⏩😍❓🐘😡☀😍🙃😁😀😁🚫📂✅☃🚫😎🔪👑😀🕹🚫😍🌪📂👌🍍👌🦓🖐🤣😎🏎🍍🏹🍌🍍🎤☀🏹🎈🚰💧☀✉🏹🍍🦓🎅🍴☂⏩🚪🐍☺🐘😇😡🍵🌏🦓🍵🛩📂👌🏹🗒🗒 找到下面的工具：emoji-aes 发现密钥的问题，试了KEY的unicode, ascii,等等，🔑的unicode，用KEY生成垃圾邮件，都失败了。找到正确的密钥🔑。解密结果是： 10x???? ⊕ dxBUQVJndGJbbGByE3tGUW57VxV0bH9db3FSe2YFUndUexVUYWl/QW1FAW1/bW57EhQSEF0= 这个字符串应该是被异或操作过的结果，找到正确的16进制数与其进行异或就能得到原始信息。下面是暴力破解来找出可能的结果。异或运算的一个特点是自反的，就是用同一个键进行两次异或操作就可以恢复原始信息。 1234567import base64cipher_text = base64.b64decode('dxBUQVJndGJbbGByE3tGUW57VxV0bH9db3FSe2YFUndUexVUYWl/QW1FAW1/bW57EhQSEF0=')for xor_key in range(0x10000): # 试验所有 0x0000 到 0xffff 的可能key plain_text = ''.join(chr(b ^ (xor_key &amp; 0xff)) for b in cipher_text) print(f'0x{xor_key:04x}: {plain_text}') 第一次的代码有点问题，遍历输出只发现了一个很像的数据。分析了下奇数位和偶数位异或的值是不一样的，0x？？？？看得出来是个四位十六进制，这个奇数位看起来基本是对的。改一下代码，然后一样遍历枚举，就找到flag了。 12345678import base64cipher_text = base64.b64decode('dxBUQVJndGJbbGByE3tGUW57VxV0bH9db3FSe2YFUndUexVUYWl/QW1FAW1/bW57EhQSEF0=')xor_key_even = 0xfe20for xor_key_odd in range(0x10000): plain_text = &quot;&quot;.join(chr(cipher_text[i] ^ ((xor_key_odd if i % 2 else xor_key_even) &amp; 0xff)) for i in range(len(cipher_text))) print(f'key_odd: 0x{xor_key_odd:04x}, deciphered message: {plain_text}') GZ GPTnc：乱码解决方案：乱码恢复 手动改乱码比较慢，就使用python的pwn库，并导入codecs模块（基础编解码功能）进行无限交互直至远程服务器终止。 1234567891011from pwn import *import codecsconn = remote('127.0.0.1', 50338)while True: data = conn.recv().decode('utf-8') gbk_data = data.encode('gbk') print(f&quot;接收到的数据：{data}&quot;) conn.interactive() conn.close() 看提示，应该是每次返回的有隐藏数据（想到去年的shadow，感觉这次输出光标也有奇怪的闪动）。确定了下每次输出后都有隐藏信息，这题是考隐写的。把终端输出复制过来看到vscode的提示： 然后去查一下锁定类型：零宽度字符隐写，并找到工具Unicode Steganography with Zero-Width Characters。用笨蛋方法一句句复制粘贴上去解码的，把每次的Hidden Text粘贴上去就得到完整的flag了。 broken.mp4解压后一个视频是完好的，打开看看，很明显的提示了，明显是在微信打开的嘛，去微信上搜搜标题，很好找到这篇文章链接然后去下载公众号上说的那个软件恢复一下就OK了 Sign In四道签到题的最后一个（晚上公选课无聊乱翻榜单看到的） Remember It 0第一次做pwn题，随便试试，签到题的话一般跟着做就行（主要是懒得想其他方法了）看源码，笨蛋方法没问题，就一步步敲的然后cat flag Shuffle Puts签到题，嗯，打开IDA直接看strings 总结小白第一次玩CTF还是挺开心的，感觉算是入了门。（一周前容器实例还不会开netcat还不会用的）。如果这周事情不那么多就好了，这周太忙了有效做题时间不多，很多方向都没学，基本上就是在做Misc了。","link":"/2024/05/03/writeup/"},{"title":"html+css+js基础","text":"html+css+js基础 html1123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;!--使用 &lt;meta&gt; 元素来描述HTML文档的描述，关键词，作者，字符集等--&gt; &lt;title&gt;菜鸟教程(unboob.com)&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;标题&lt;/h1&gt; &lt;h2&gt;标题&lt;/h2&gt; &lt;p&gt;段落&lt;/p&gt; &lt;a href=&quot;#section2&quot;&gt;跳转到第二部分&lt;/a&gt; &lt;br&gt; &lt;a href=&quot;https://www.runoob.com/html/html-basic.html&quot;&gt;链接&lt;/a&gt; &lt;br&gt; &lt;hr&gt; &lt;p&gt;hr标签在HTML页面中创建水平线&lt;/p&gt; &lt;hr&gt; &lt;!-- 注释 --&gt; &lt;p&gt;浏览器会自动地在段落的前后添加空行&lt;/p&gt; &lt;p&gt;这个是&lt;br&gt;分行&lt;/p&gt; &lt;hr&gt; &lt;b&gt;加粗&lt;/b&gt;&lt;br&gt;&lt;br&gt; &lt;strong&gt;加粗&lt;/strong&gt;&lt;br&gt;&lt;br&gt; &lt;big&gt;放大&lt;/big&gt; &lt;small&gt;缩小&lt;/small&gt; &lt;i&gt;斜体&lt;/i&gt;&lt;br&gt;&lt;br&gt; &lt;em&gt;斜体&lt;/em&gt;&lt;br&gt;&lt;br&gt; &lt;sub&gt;下标&lt;/sub&gt;&lt;sup&gt;上标&lt;/sup&gt; &lt;hr&gt; &lt;img src=&quot;https://www.runoob.com/images/logo.png&quot; width=&quot;258&quot; height=&quot;39&quot; /&gt; &lt;hr&gt; &lt;pre&gt;此例演示如何使用pre标签 对空行和 空格 进行控制 &lt;/pre&gt; &lt;hr&gt; &lt;p&gt;&lt;del&gt;删除&lt;/del&gt;&lt;ins&gt;插入&lt;/ins&gt;&lt;/p&gt; &lt;hr&gt; &lt;!-- 在页面中的某个位置 --&gt; &lt;p&gt;这个地方是跳转的第二部分&lt;a name=&quot;section2&quot;&gt;&lt;/a&gt;&lt;/p&gt; &lt;hr&gt; &lt;a href=&quot;https://www.runoob.com/&quot; target=&quot;_blank&quot;&gt;访问菜鸟教程!&lt;/a&gt; &lt;!--_self 在本页面打开--&gt; &lt;p&gt;如果你将 target 属性设置为 &amp;quot;blank&amp;quot;, 链接将在新窗口打开。&lt;/p&gt; &lt;hr&gt; &lt;a id=&quot;tips&quot;&gt;有用的提示部分&lt;/a&gt; &lt;a href=&quot;#tips&quot;&gt;访问有用的提示部分&lt;/a&gt; &lt;hr&gt; &lt;p&gt;无边框的图片链接: &lt;a href=&quot;http://www.runoob.com/html/html-tutorial.html&quot;&gt; &lt;img border=&quot;0&quot; src=&quot;smiley.gif&quot; alt=&quot;HTML 教程&quot; width=&quot;32&quot; height=&quot;32&quot;&gt;&lt;/a&gt;&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 21234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;style type=&quot;test/css&quot;&gt; body{ background-color: rgb(194, 194, 128); } p{ color: blueviolet; } &lt;/style&gt; &lt;link rel=&quot;shortcut icon&quot; href=&quot;https://csdiy.wiki/images/title.png&quot;&gt; &lt;!--带图片的标签--&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt; &lt;base href=&quot;https://www.runoob.com/images/&quot; target =&quot;_blank&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;img src =&quot;logo.png&quot; border=&quot;0&quot; alt=&quot;alt&quot; width=&quot;500&quot; height=&quot;100&quot;&gt; &lt;br&gt;&lt;br&gt; &lt;a href=&quot;https://www.runoob.com/images/&quot;&gt;菜鸟教程&lt;/a&gt; &lt;h1&gt;标题&lt;/h1&gt; &lt;p&gt;段落&lt;/p&gt; &lt;br&gt; &lt;a href=&quot;http://www.runoob.com/&quot; style=&quot;text-decoration:none;&quot;&gt;访问 runoob.com!&lt;/a&gt; &lt;!--没有下划线的链接--&gt; &lt;hr&gt; &lt;p&gt;内联样式&lt;/p&gt; &lt;p style=&quot;color:rgba(10, 254, 14, 0.221);margin-left:20px;&quot;&gt;段落&lt;/p&gt; &lt;hr&gt; &lt;body style=&quot;background-color: rgb(195, 161, 178);&quot;&gt; &lt;h2 style=&quot;background-color: blueviolet;&quot;&gt;标题&lt;/h2&gt; &lt;p style=&quot;background-color: aquamarine;&quot;&gt;段落&lt;/p&gt; &lt;/body&gt; &lt;hr&gt; &lt;h1 style=&quot;text-align: center;&quot;&gt;居中对齐&lt;/h1&gt; &lt;hr&gt; &lt;/body&gt;&lt;/html&gt; 3123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;测试&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;列标题1&lt;/th&gt; &lt;th&gt;列标题2&lt;/th&gt; &lt;th&gt;列标题3&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;行1,列1&lt;/td&gt; &lt;td&gt;行1,列2&lt;/td&gt; &lt;td&gt;行1,列3&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;行2,列1&lt;/td&gt; &lt;td&gt;行2,列2&lt;/td&gt; &lt;td&gt;行2,列3&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;hr&gt;&lt;p&gt; 每个表格从一个 table 标签开始。 每个表格行从 tr 标签开始。 每个表格的数据从 td 标签开始。 &lt;/p&gt; &lt;h4&gt;一列:&lt;/h4&gt; &lt;table border=&quot;1&quot;&gt; &lt;tr&gt; &lt;td&gt;100&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;h4&gt;一行三列:&lt;/h4&gt; &lt;table border=&quot;1&quot;&gt; &lt;tr&gt; &lt;td&gt;100&lt;/td&gt; &lt;td&gt;200&lt;/td&gt; &lt;td&gt;300&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;h4&gt;两行三列:&lt;/h4&gt; &lt;table border=&quot;1&quot;&gt; &lt;tr&gt; &lt;th&gt;Header 1&lt;/th&gt; &lt;th&gt;Header 2&lt;/th&gt; &lt;th&gt;Header 3&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;100&lt;/td&gt; &lt;td&gt;200&lt;/td&gt; &lt;td&gt;300&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;400&lt;/td&gt; &lt;td&gt;500&lt;/td&gt; &lt;td&gt;600&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt; &lt;hr&gt; &lt;h4&gt;单元格跨两列:&lt;/h4&gt;&lt;table border=&quot;1&quot;&gt;&lt;tr&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th colspan=&quot;2&quot;&gt;Telephone&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt; &lt;td&gt;Bill Gates&lt;/td&gt; &lt;td&gt;555 77 854&lt;/td&gt; &lt;td&gt;555 77 855&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;table&gt;&lt;/table&gt;&lt;/html&gt; 41234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;测试网页&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;h1&lt;/h1&gt;&lt;h2&gt;h2&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;form&gt; 生日: &lt;input type=&quot;text&quot;&gt;&lt;br&gt;年龄: &lt;input type=&quot;text&quot; &gt;&lt;/form&gt;&lt;form&gt;密码: &lt;input type=&quot;password&quot;&gt;&lt;/form&gt;&lt;form&gt;&lt;input type=&quot;radio&quot; &gt;China&lt;br&gt;&lt;input type=&quot;radio&quot; &gt;UK&lt;/form&gt;&lt;form&gt;&lt;input type=&quot;checkbox&quot;&gt;China&lt;br&gt;&lt;input type=&quot;checkbox&quot;&gt;UK&lt;/form&gt;&lt;form &gt;心情: &lt;input type=&quot;text&quot;&gt;&lt;input type=&quot;submit&quot; &gt;&lt;/form&gt;&lt;ol&gt;&lt;li&gt;你好&lt;/li&gt;&lt;li&gt;hello&lt;/li&gt; &lt;/ol&gt;&lt;ul&gt;&lt;li&gt;你好&lt;/li&gt;&lt;li&gt;hello&lt;/li&gt;&lt;/ul&gt; 51234567891011121314151617181920212223242526272829&lt;font color=&quot;&quot; size=&quot;&quot; face=&quot;&quot;&gt;&lt;/font&gt; &lt;!-- 字体 --&gt;&lt;h1&gt;&lt;/h1&gt; &lt;!--标题 --&gt;&lt;p&gt;&lt;/p&gt; &lt;!-- 段落 --&gt;&lt;b&gt;&lt;/b&gt; &lt;!--粗体--&gt;&lt;i&gt;&lt;/i&gt; &lt;!--斜体--&gt;&lt;hr&gt;&lt;!--下划线--&gt;&lt;br&gt;&lt;!--换行--&gt;&lt;img src=&quot;&quot; width=&quot;&quot; height=&quot;&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;!--type属性: circle: 空心圆; square: 实心正方形--&gt;&lt;!--无序列表标签--&gt;&lt;ul type=&quot;square&quot;&gt; &lt;li&gt;a&lt;/li&gt; &lt;li&gt;b&lt;/li&gt;&lt;/ul&gt;&lt;!--有序列表标签--&gt;&lt;!--start:起始索引(默认是1)type属性:1:阿拉伯数字; a:小写英文字母; A:大写英文字母; i:小写罗马数字; I:大写罗马数字--&gt;&lt;ol start=&quot;1&quot; type=&quot;1&quot;&gt; &lt;li&gt;乔丹&lt;/li&gt; &lt;li&gt;詹姆斯&lt;/li&gt;&lt;/ol&gt;&lt;!--超链接标签--&gt;&lt;!--target属性: 链接打开方式--&gt;&lt;a href=&quot;指定需要跳转的目标路径&quot; target=&quot;打开的方式&quot;&gt;需要展现给用户查看的内容&lt;/a&gt;&lt;!--假链接--&gt;&lt;a href=&quot;#&quot;&gt;假链接&lt;/a&gt; 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;table border=&quot;1px&quot; width=&quot;600px&quot; cellspacing=&quot;0px&quot; cellpadding=&quot;10px&quot; bgcolor=&quot;navajowhite&quot; align=&quot;center&quot;&gt;&lt;!--边框、宽度、单元格间距、单元格内边距、背景颜色和对齐方式--&gt;&lt;caption&gt;表格标题&lt;/caption&gt;&lt;tr&gt;&lt;th&gt;姓名&lt;/th&gt;&lt;th&gt;性别&lt;/th&gt;&lt;th&gt;地址&lt;/th&gt;&lt;/tr&gt;&lt;tr align=&quot;center&quot;&gt;&lt;td rowspan=&quot;2&quot;&gt;11&lt;/td&gt;&lt;td&gt;12&lt;/td&gt;&lt;td&gt;13&lt;/td&gt;&lt;/tr&gt;&lt;tr align=&quot;center&quot;&gt;&lt;td&gt;22&lt;/td&gt;&lt;td&gt;23&lt;/td&gt;&lt;/tr&gt;&lt;tr align=&quot;center&quot;&gt;&lt;td&gt;31&lt;/td&gt;&lt;td colspan=&quot;2&quot;&gt;32&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; table 中定义 tr, tr 中定义 td, td 中存放内容 6表单标签&lt;form&gt;&lt;/form&gt;输入类型 &lt;input&gt; 选择菜单 &lt;select&gt; 文本域 &lt;textarea&gt; input&lt;input type=&quot;xxx&quot;/&gt; text（默认） 文本框 password 密码框 radio 单选框：同一组单选框 name 属性相同 checkbox 复选框：同一组多选框 name 属性相同 file 文件选择框 date 日期选择框 hidden 隐藏域：向服务器提交数据，不在页面上展示出来 submit 提交按钮：内置提交表单的功能 button 普通按钮：不内置任何功能，需要在学习 js 之后给它绑定点击事件 reset 重置按钮：内置重置表单的功能 select12345678&lt;select name=&quot;&quot;&gt; &lt;!--如果option没有添加value属性，那么提交数据时就会提交选中的option标签体的内容--&gt; &lt;!--如果option添加了value属性，那么提交数据时就会提交选中的option标签体的value值--&gt; &lt;!--option标签通过selected属性设置默认选中--&gt; &lt;option value=&quot;&quot;&gt;显示的内容1&lt;/option&gt; &lt;option value=&quot;&quot;&gt;显示的内容2&lt;/option&gt;&lt;/select&gt; 显示的内容 1 显示的内容 2 textarea1&lt;textarea row=&quot;20&quot; cols=&quot;30&quot; name=&quot;introduce&quot;&gt;&lt;/textarea&gt; 如果表单项的数据需要提交给服务器，必须具备 name 属性同一组单选、多选框需要具备相同的 name输入框、密码框、文件选择框、日期选择框等等的 value 属性的值，就是你输入的值单选或多选框，默认 value 均为 on，所以我们需要手动给单选框和多选框设置 value readonly 属性：表示只读，数据可以向服务器提交disabled 属性：表示不可用, 数据无法向服务器提交placeholder 属性：表示输入提示checked 属性：单选和多选框也可以设置默认选中 7123456789&lt;a id=&quot;top&quot;&gt;&lt;/a&gt;&lt;a href=&quot;#top&quot;&gt;回到顶部&lt;/a&gt;&lt;a&gt;&lt;img src=&quot;./img/dog.jpg&quot;/&gt;&lt;br/&gt;&lt;/a&gt;&lt;details&gt; &lt;summary&gt;概要信息&lt;/summary&gt; 详情信息&lt;/details&gt; css层叠样式表 1. CSS 语法CSS 规则由选择器和声明块组成。 选择器：用于选择页面上的 HTML 元素。 声明块：包含多个 CSS 声明，每个声明定义元素的某个样式属性。 123选择器 { 属性名: 属性值;} 示例： 1234p { color: red; font-size: 16px;} 选择器：p（选择所有 &lt;p&gt; 元素） 声明块：color: red; 和 font-size: 16px;（将段落的文字颜色设为红色，字体大小设为 16 像素） 2. 将 CSS 添加到 HTML 中1. 内联样式（Inline CSS）直接在 HTML 元素的 style 属性中编写 CSS。适用于单个元素的样式定义。 1&lt;p style=&quot;color: blue; font-size: 20px;&quot;&gt;这是一个内联样式的段落。&lt;/p&gt; 2. 内部样式表（Internal CSS）将 CSS 代码写在 HTML 文档的 &lt;head&gt; 部分的 &lt;style&gt; 标签中。适用于单个页面的样式定义。 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;style&gt; p { color: green; font-size: 18px; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;这是一个内部样式表的段落。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 3. 外部样式表（External CSS）将 CSS 代码写在独立的 .css 文件中，并通过 &lt;link&gt; 标签引用。适用于多个页面共享样式。 123456789&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;styles.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;这是一个外部样式表的段落。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 在 styles.css 文件中： 1234p { color: purple; font-size: 22px;} 3. 选择器CSS 选择器用于选择特定的 HTML 元素，以应用样式。常见的选择器包括： 元素选择器：选择某种 HTML 元素。 1p { color: red; } /* 选择所有 &lt;p&gt; 元素 */ 类选择器：选择带有特定类的元素，类选择器以 . 开头。 1.intro { font-weight: bold; } /* 选择 class=&quot;intro&quot; 的元素 */ ID 选择器：选择具有特定 ID 的元素，ID 选择器以 # 开头。 1#main-title { color: blue; } /* 选择 id=&quot;main-title&quot; 的元素 */ 通用选择器：选择页面上的所有元素。 1* { margin: 0; padding: 0; } /* 清除所有元素的外边距和内边距 */ 后代选择器：选择嵌套在其他元素内的元素。 1div p { color: green; } /* 选择所有在 &lt;div&gt; 内的 &lt;p&gt; 元素 */ 属性选择器 :根据HTML元素的属性来选择元素，选择所有 type 属性为 text 的 &lt;input&gt; 元素。 123input[type=&quot;text&quot;] { background-color: yellow;} 以上是基本选择器，组合选择器只举一例： 后代选择器 : 选择某个元素的所有后代元素。 123div p { color: blue;} 4. CSS 属性一些常见的 CSS 属性如下： 颜色相关 color: 文本颜色。 background-color: 背景颜色。 1234h1 { color: blue; background-color: yellow;} 文本和字体 font-size: 字体大小。 font-family: 字体系列。 font-weight: 字体粗细（如 bold、normal）。 text-align: 文本对齐方式（如 left、right、center）。 12345p { font-size: 16px; font-family: Arial, sans-serif; text-align: center;} 布局相关 margin: 元素外边距。 padding: 元素内边距。 width: 宽度。 height: 高度。 123456div { margin: 20px; padding: 10px; width: 300px; height: 200px;} 边框 border: 边框样式，宽度、颜色和类型可以组合。 123img { border: 2px solid black;} 显示和定位 display: 定义元素的显示方式，如 block、inline、none。 position: 定义元素的定位方式，如 relative、absolute、fixed。 123456789.hidden { display: none;}.absolute-box { position: absolute; top: 50px; left: 100px;} 5. 层叠与优先级CSS 的 C（Cascading）代表“层叠”，它表示当多个样式同时作用于一个元素时，浏览器会按以下优先级规则决定使用哪个样式： 内联样式：直接写在元素内的样式，优先级最高。 ID 选择器：ID 选择器的样式优先级高于类选择器和元素选择器。 类选择器：类选择器的优先级高于元素选择器。 元素选择器：元素选择器的优先级最低。 如果多个样式有相同的优先级，后定义的样式会覆盖先定义的样式。 1234567p { color: red; /* 将会被覆盖 */}p { color: blue; /* 最终生效 */} 6. 响应式设计CSS 可以通过媒体查询来响应不同设备的屏幕大小。这样可以使网站在不同设备上（如手机、平板、桌面）表现良好。 12345@media screen and (max-width: 600px) { body { background-color: lightblue; }} 7. CSS 框模型（Box Model）每个 HTML 元素都被看作一个盒子，CSS 盒模型包含以下几个部分： 内容（content）：元素的内容。 内边距（padding）：内容周围的空白区域。 边框（border）：内边距外的边框。 外边距（margin）：边框外的空白区域。 123456div { width: 200px; padding: 10px; border: 5px solid black; margin: 20px;} 在这个例子中，div 的内容宽度是 200 px，内边距 10 px，边框 5 px，外边距 20 px。 8. 其他div是块级元素，会独占一行；span是行内元素，不会独占一行div中可以嵌套其它的标签，span标签中只能嵌套文本/图片/超链接 jsJavaScript 是一种广泛应用于网页开发的编程语言，通常用于增强用户交互、动态更新内容、表单验证、动画以及其他客户端功能。 1. JavaScript 的用途JavaScript 主要用于以下任务： 动态内容更新：可以根据用户交互修改网页内容，无需刷新整个页面。 表单验证：在用户提交表单之前，验证输入是否合法。 浏览器控制：可以控制浏览器的行为，比如弹出对话框、导航历史等。 事件驱动编程：响应用户的鼠标点击、键盘按键等操作。 动画和图形：通过 DOM 操作和 CSS 动画，JavaScript 可以实现丰富的视觉效果。 2. JavaScript 语法1. 基本语法JavaScript 是一种基于语句的语言，语句以分号 ; 结束（虽然不强制要求，但最好使用）。 变量声明：通过 var、let 或 const 声明变量。 var：有函数作用域，较老的变量声明方式。 let：有块作用域，适用于现代 JavaScript。 const：声明不可变的常量。 123var name = &quot;John&quot;; // 使用 var 声明变量let age = 30; // 使用 let 声明变量const city = &quot;Paris&quot;; // 使用 const 声明常量 2. 数据类型JavaScript 有六种基本的数据类型： 数字（Number）：整数和浮点数。 字符串（String）：用双引号或单引号括起来的文本。 布尔值（Boolean）：true 或 false。 未定义（Undefined）：未定义的变量。 空（Null）：表示空值。 对象（Object）：用于存储键值对或复杂数据结构。 12345let number = 42; // 数字let text = &quot;Hello, World!&quot;; // 字符串let isTrue = true; // 布尔值let notDefined; // 未定义变量let emptyValue = null; // 空值 3. 运算符JavaScript 提供了多种运算符来处理数据。 算术运算符：+（加）、-（减）、*（乘）、/（除）、%（取余）。 赋值运算符：=（赋值）、+=（加并赋值）、-=（减并赋值）等。 比较运算符：==（相等）、===（严格相等）、!=（不相等）、&gt;、&lt; 等。 逻辑运算符：&amp;&amp;（与）、||（或）、!（非）。 1234567let x = 10;let y = 5;console.log(x + y); // 输出 15console.log(x &gt; y); // 输出 trueconsole.log(x == &quot;10&quot;); // 输出 true (== 不检查类型)console.log(x === &quot;10&quot;); // 输出 false (=== 检查类型) 3. 条件语句条件语句用于根据条件执行不同的代码。 if… else 语句：根据条件执行不同的代码块。 1234567let age = 20;if (age &gt;= 18) { console.log(&quot;成人&quot;);} else { console.log(&quot;未成年&quot;);} switch 语句：用于对多个条件进行比较。 123456789101112let color = &quot;blue&quot;;switch (color) { case &quot;red&quot;: console.log(&quot;红色&quot;); break; case &quot;blue&quot;: console.log(&quot;蓝色&quot;); break; default: console.log(&quot;未知颜色&quot;);} 4. 循环JavaScript 提供了几种循环结构，用于重复执行某些代码。 for 循环：用于执行指定次数的循环。 123for (let i = 0; i &lt; 5; i++) { console.log(&quot;循环次数: &quot; + i);} while 循环：只要条件为 true，就会不断执行。 12345let i = 0;while (i &lt; 5) { console.log(&quot;循环次数: &quot; + i); i++;} do… while 循环：至少会执行一次，然后根据条件判断是否继续。 12345let i = 0;do { console.log(&quot;循环次数: &quot; + i); i++;} while (i &lt; 5); 5. 函数函数是用于封装可重复使用代码的块。可以通过定义函数来组织代码，并通过调用函数执行代码。 函数声明： 123456function greet(name) { return &quot;Hello, &quot; + name;}let message = greet(&quot;Alice&quot;);console.log(message); // 输出 &quot;Hello, Alice&quot; 函数表达式：可以将函数赋值给变量。 12345const sayHello = function(name) { return &quot;Hello, &quot; + name;};console.log(sayHello(&quot;Bob&quot;)); // 输出 &quot;Hello, Bob&quot; 箭头函数：ES 6 引入的一种简洁写法。 12const add = (a, b) =&gt; a + b;console.log(add(5, 3)); // 输出 8 箭头函数箭头函数（Arrow Function）是ES6中引入的一种更简洁的书写函数的方法。它使用 =&gt; 语法，通常用于简化匿名函数的书写方式。 简洁语法：箭头函数提供了一种更简洁的书写方式，尤其是针对简单函数。 this 绑定：箭头函数不创建自己的 this，而是**继承封闭上下文中的 this**。 不适合作为构造函数：箭头函数不能被用作构造函数，也没有 new 关键字的行为。 没有 arguments 对象：箭头函数没有 arguments 对象，但可以使用剩余参数语法来处理参数。箭头函数特别适合需要保留上下文 this 的场景，或需要编写简洁代码时的使用。 123456789101112// 传统函数表达式let traditionalFunction = function(a, b) { return a + b;};// 箭头函数let arrowFunction = (a, b) =&gt; { return a + b;};// 如果只有一行返回语句，可以省略花括号和`return`let arrowFunctionShort = (a, b) =&gt; a + b; 参数：如果只有一个参数，参数括号可以省略。 1let singleParam = x =&gt; x * 2; 没有参数时：必须使用空括号。 1let noParam = () =&gt; console.log('No parameters'); 箭头函数在处理 this 时有一个重要特性：它不会创建自己的 this，而是继承自定义它的上下文。这与传统的函数不同，传统函数的 this 取决于函数是如何调用的。 123456789101112131415161718function TraditionalFunction() { this.value = 1; setTimeout(function() { this.value++; console.log(this.value); // undefined，因为this在此指向全局对象（或undefined，取决于是否使用strict模式） }, 1000);}function ArrowFunction() { this.value = 1; setTimeout(() =&gt; { this.value++; console.log(this.value); // 2，因为箭头函数的this是继承自ArrowFunction中的this }, 1000);}new TraditionalFunction(); // 输出 NaN 或 undefinednew ArrowFunction(); // 输出 2 箭头函数与传统函数的另一个不同点是，箭头函数不能作为构造函数（即不能用 new 关键字来调用），而传统函数可以。 12345678let ArrowFunction = () =&gt; {};let TraditionalFunction = function() {};// 传统函数可以用new关键字创建实例let obj1 = new TraditionalFunction(); // 允许// 箭头函数不允许使用newlet obj2 = new ArrowFunction(); // 错误：ArrowFunction is not a constructor 传统函数有一个 arguments 对象，表示传递给函数的所有参数。箭头函数没有自己的 arguments，但可以通过剩余参数语法来获取参数。 1234567891011let traditionalFunction = function() { console.log(arguments);};traditionalFunction(1, 2, 3); // 输出：{0: 1, 1: 2, 2: 3}let arrowFunction = (...args) =&gt; { console.log(args);};arrowFunction(1, 2, 3); // 输出：[1, 2, 3] arguments对象arguments 对象是 JavaScript 中所有非箭头函数内置的一个类数组对象，包含了函数调用时传入的所有参数。它允许你访问传递给函数的参数，而不需要明确在函数声明中定义它们。 arguments 是一个类数组对象，包含了传给函数的所有参数。 它对处理不确定数量的参数非常有用。 arguments 在 ES 6 中已经被 ... 剩余参数语法部分取代，后者更灵活方便。 它不能在箭头函数中使用，在这种情况下，它会从外层上下文继承。arguments 对象虽然经典，但在现代 JavaScript 中，通常更推荐使用 剩余参数 (...rest) 来处理可变数量的参数，因为它提供了更清晰的语法和更强大的功能。 特点： 类数组对象： arguments 是一个类似数组的对象，它有 length 属性，但不是真正的数组，因此没有数组的方法（如 push, forEach 等）。然而，你可以通过索引来访问各个参数。 动态性： 无论函数定义了多少个参数，arguments 对象都会包含函数调用时传入的所有参数（即使传入的参数比函数声明的参数多或少）。 不可用于箭头函数： arguments 对象在箭头函数中不存在。箭头函数不会绑定自己的 arguments 对象，它会从它的封闭上下文中继承 arguments。 1234567function exampleFunction() { console.log(arguments); console.log(arguments[0]); // 访问第一个参数 console.log(arguments.length); // 参数个数}exampleFunction(1, &quot;Hello&quot;, true); 输出： 123[Arguments] { '0': 1, '1': 'Hello', '2': true }13 应用场景： 处理可变参数个数的函数：arguments 对象经常用于函数的参数个数不固定时，特别是在 ES 6 之前没有默认参数和剩余参数的场景下。 123456789function sum() { let total = 0; for (let i = 0; i &lt; arguments.length; i++) { total += arguments[i]; } return total;}console.log(sum(1, 2, 3, 4)); // 输出：10 与剩余参数对比：在 ES 6 引入的剩余参数（Rest Parameters）后，arguments 对象的使用有所减少。剩余参数可以将传入的参数作为一个真正的数组，而不是类数组对象，这更加方便。 **使用 arguments**： 12345678function multiply() { let result = 1; for (let i = 0; i &lt; arguments.length; i++) { result *= arguments[i]; } return result;}console.log(multiply(2, 3, 4)); // 输出：24 使用剩余参数： 1234function multiply(...args) { return args.reduce((product, current) =&gt; product * current, 1);}console.log(multiply(2, 3, 4)); // 输出：24 在这个例子中，...args 是一个真正的数组，可以直接使用数组方法如 reduce，而不需要像 arguments 那样手动迭代。 6. 事件和 DOM 操作在 JavaScript 中，事件 和 DOM 操作 是构建动态网页的核心。事件使网页能够对用户的交互（如点击、键盘输入等）作出响应，而 DOM（Document Object Model） 操作则允许 JavaScript 动态地更改网页的内容和结构。 事件：通过事件处理器监听用户行为（如点击、按键等），并通过 addEventListener() 绑定事件。事件对象可以提供详细的事件信息。 DOM 操作：允许我们动态地获取、修改、创建、删除页面中的 HTML 元素，进而实现动态的网页交互。 一、事件事件 是用户或浏览器执行的动作，例如鼠标点击、按键按下、窗口加载等。通过事件，我们可以使网页具有交互性。 常见事件类型 鼠标事件： click：当用户点击元素时触发。 dblclick：当用户双击元素时触发。 mouseover：当鼠标移到元素上时触发。 mouseout：当鼠标移出元素时触发。 mousedown / mouseup：鼠标按下和释放时触发。 键盘事件： keydown：按下键盘按键时触发。 keyup：释放按键时触发。 表单事件： submit：表单提交时触发。 change：表单元素的值发生变化时触发（如 &lt;input&gt;、&lt;select&gt;）。 窗口事件： load：页面加载完成时触发。 resize：浏览器窗口大小发生变化时触发。 scroll：当页面或元素滚动时触发。 事件处理器（Event Handlers） 事件处理器（或事件监听器）是指在特定事件发生时执行的函数。有三种常见的方式来添加事件处理器： 方法 1：HTML 内联事件处理 将 JavaScript 直接写在 HTML 元素的事件属性中。 1&lt;button onclick=&quot;alert('你点击了按钮!')&quot;&gt;点击我&lt;/button&gt; 方法 2：DOM 的 onEvent 属性 通过 JavaScript 设置元素的 onEvent 属性（例如 onclick）来添加事件处理。 1234let button = document.querySelector(&quot;button&quot;);button.onclick = function() { alert(&quot;按钮被点击了&quot;);}; 方法 3：addEventListener() 方法 这是推荐的方式，允许我们为同一事件添加多个事件处理器，并能更好地控制事件（如移除事件处理器等）。 1234let button = document.querySelector(&quot;button&quot;);button.addEventListener(&quot;click&quot;, function() { alert(&quot;按钮被点击了&quot;);}); 使用 addEventListener() 的好处： 可以为同一个元素添加多个事件监听器。 可以在需要时轻松移除事件处理器。 支持事件冒泡和捕获。 事件对象（Event Object） 当事件被触发时，浏览器会生成一个事件对象，该对象包含了与事件相关的详细信息，例如触发事件的元素、鼠标的坐标、按键状态等。 常用属性： target：事件触发的元素。 type：事件类型，如 click、keydown。 key：当处理键盘事件时，表示按下的键。 clientX / clientY：鼠标事件中，表示鼠标点击时的 X 和 Y 坐标。 123document.addEventListener(&quot;click&quot;, function(event) { console.log(&quot;点击位置 X: &quot; + event.clientX + &quot;，Y: &quot; + event.clientY);}); 事件传播模型 事件传播是指事件从触发源开始如何传播到其他相关元素。JavaScript 中有三种传播阶段： 捕获阶段：事件从文档的根元素向事件目标传播。 目标阶段：事件到达目标元素（触发事件的元素）。 冒泡阶段：事件从目标元素向上冒泡，经过其祖先元素。 事件监听器默认在冒泡阶段执行，但可以通过 addEventListener 的第三个参数将监听器绑定在捕获阶段。 123document.querySelector(&quot;div&quot;).addEventListener(&quot;click&quot;, function(event) { console.log(&quot;DIV 捕获阶段&quot;);}, true); // 第三个参数为 true，表示在捕获阶段执行 二、DOM 操作DOM（Document Object Model） 是网页的编程接口，表示页面的结构。通过 DOM，我们可以动态地修改、创建、删除页面中的元素，改变样式，响应用户交互等。 获取 DOM 元素获取元素: **getElementById()**：通过元素的 ID 获取元素。 1let element = document.getElementById(&quot;myElement&quot;); **getElementsByClassName()**：通过类名获取元素集合。 1let elements = document.getElementsByClassName(&quot;myClass&quot;); **getElementsByTagName()**：通过标签名获取元素集合。 1let elements = document.getElementsByTagName(&quot;p&quot;); **querySelector()**：通过 CSS 选择器获取第一个匹配的元素。 1let element = document.querySelector(&quot;.myClass&quot;); **querySelectorAll()**：通过 CSS 选择器获取所有匹配的元素。 1let elements = document.querySelectorAll(&quot;.myClass&quot;); 修改 DOM 元素 修改内容 **innerHTML**：更改元素的 HTML 内容。 12let div = document.getElementById(&quot;myDiv&quot;);div.innerHTML = &quot;&lt;p&gt;新内容&lt;/p&gt;&quot;; **textContent**：更改元素的纯文本内容（不会解析 HTML）。 12let div = document.getElementById(&quot;myDiv&quot;);div.textContent = &quot;新文本内容&quot;; 修改属性 **setAttribute()**：设置元素的属性。 12let img = document.querySelector(&quot;img&quot;);img.setAttribute(&quot;src&quot;, &quot;newImage.jpg&quot;); **removeAttribute()**：移除元素的属性。 12let img = document.querySelector(&quot;img&quot;);img.removeAttribute(&quot;alt&quot;); 直接修改属性：可以通过点语法直接修改元素的属性。 12let input = document.querySelector(&quot;input&quot;);input.type = &quot;password&quot;; 修改样式 可以通过 style 属性直接修改元素的内联样式： 123let div = document.getElementById(&quot;myDiv&quot;);div.style.color = &quot;blue&quot;;div.style.backgroundColor = &quot;yellow&quot;; 创建和删除元素 创建新元素 **createElement()**：创建一个新的 DOM 元素。12let newElement = document.createElement(&quot;div&quot;);newElement.textContent = &quot;这是一个新元素&quot;; 插入元素 **appendChild()**：将新元素添加为某个元素的子元素。 12let parentElement = document.getElementById(&quot;parent&quot;);parentElement.appendChild(newElement); **insertBefore()**：在指定子元素前插入新元素。 12let firstChild = parentElement.firstChild;parentElement.insertBefore(newElement, firstChild); 删除元素 **removeChild()**：从父元素中删除子元素。 123let parentElement = document.getElementById(&quot;parent&quot;);let child = document.getElementById(&quot;child&quot;);parentElement.removeChild(child); **remove()**：直接删除当前元素。 12let element = document.getElementById(&quot;myElement&quot;);element.remove(); 事件与 DOM 操作结合 通过事件处理和 DOM 操作的结合，我们可以构建动态交互的网页。例如，点击按钮后动态生成一个新的段落： 12345678910&lt;button id=&quot;addParagraph&quot;&gt;添加段落&lt;/button&gt;&lt;div id=&quot;content&quot;&gt;&lt;/div&gt;&lt;script&gt; document.getElementById(&quot;addParagraph&quot;).addEventListener(&quot;click&quot;, function() { let newParagraph = document.createElement(&quot;p&quot;); newParagraph.textContent = &quot;这是一个新段落&quot;; document.getElementById(&quot;content&quot;).appendChild(newParagraph); });&lt;/script&gt; 在这个示例中，点击按钮时，新的段落会动态添加到 div 中。 7. 数组和对象1. 数组：JavaScript 数组用于存储多个值。12let fruits = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;];console.log(fruits[1]); // 输出 &quot;banana&quot; push()：在数组末尾添加元素。 pop()：移除数组末尾的元素。 length：获取数组长度。 2. 对象：对象用于存储键值对，可以表示一个实体及其属性。12345678let person = { name: &quot;John&quot;, age: 30, city: &quot;New York&quot;};console.log(person.name); // 输出 &quot;John&quot;person.age = 31; // 修改对象属性 8. 异步编程JavaScript 提供了一些工具来处理异步操作，如请求数据或处理定时任务。它允许程序在等待较长时间的操作（如文件读取、网络请求）完成时，继续执行其他任务，而不必阻塞程序的执行流。 回调函数：函数可以作为参数传递到另一个函数中，在异步操作完成后执行。123setTimeout(function() { console.log(&quot;1秒后执行&quot;);}, 1000); 1234567891011function fetchData(callback) { setTimeout(() =&gt; { let data = &quot;数据加载完成&quot;; callback(data); // 异步任务完成后调用回调函数 }, 2000);}fetchData((result) =&gt; { console.log(result); // 输出 &quot;数据加载完成&quot;}); 但它存在一个问题，即回调地狱（Callback Hell）：当多个异步任务依赖于彼此时，回调函数会不断嵌套，代码难以维护和阅读。 Promise：用于处理异步操作的对象。 解决回调地狱：Promise 提供了链式调用 . then () 的方式，避免了多层嵌套的回调函数。 增强可读性：通过链式调用，代码逻辑更加线性和直观，易于理解。 错误处理机制：通过 . catch () 统一处理异步操作中的错误。 更灵活的异步控制：通过 Promise.all ()、Promise.race () 等方法，控制多个异步任务的执行方式。 1234567891011121314let promise = new Promise(function(resolve, reject) { let success = true; if (success) { resolve(&quot;操作成功！&quot;); } else { reject(&quot;操作失败！&quot;); }});promise.then(function(result) { console.log(result); // 输出 &quot;操作成功！&quot;}).catch(function(error) { console.log(error);}); Promise 是 JavaScript 中用于处理异步操作的对象，它提供了一种更优雅、简洁的方式来处理异步任务，避免了传统的回调函数（callback）方式容易导致的“回调地狱”（callback hell）问题。Promise 可以通过 .then() 和 .catch() 方法进行链式调用，并提供了错误处理机制。 Promise 是一个代表异步操作最终完成或失败的对象。它有三种状态： 待定（Pending）：异步操作尚未完成，Promise 还没有被解决或拒绝。 已解决（Fulfilled）：异步操作成功完成，Promise 被解决，返回结果。 已拒绝（Rejected）：异步操作失败，Promise 被拒绝，返回错误。 Promise 的基本语法 **resolve**：表示异步操作成功时调用，通常会传递成功的结果。 **reject**：表示异步操作失败时调用，通常会传递失败的原因或错误信息。 下面是一个使用 Promise 的简单示例，模拟一个异步任务（例如，从服务器获取数据）。 1234567891011121314151617181920let myPromise = new Promise(function(resolve, reject) { // 模拟一个耗时的异步操作，使用 setTimeout setTimeout(function() { let success = true; // 模拟成功或失败的条件 if (success) { resolve(&quot;数据获取成功&quot;); } else { reject(&quot;数据获取失败&quot;); } }, 2000);});// 使用 .then() 处理成功的结果，使用 .catch() 处理失败myPromise .then(function(result) { console.log(result); // 输出: &quot;数据获取成功&quot; }) .catch(function(error) { console.log(error); // 输出: &quot;数据获取失败&quot;（如果失败） }); 在这个例子中，myPromise 是一个 Promise 对象，它表示一个异步操作，模拟了 2 秒后异步任务的完成。根据 success 的值决定是否调用 resolve（成功）或 reject（失败）。我们可以使用 .then() 来处理成功的结果，使用 .catch() 来处理失败的情况。 Promise 状态转换Promise 的状态一旦从“待定”变为“已解决”或“已拒绝”，就不能再变更。这意味着： 如果 Promise 被解决（resolve），它的结果值就固定下来了，不会再变化。 如果 Promise 被拒绝（reject），它的错误信息也固定了。 无论 Promise 成功还是失败，它只会改变一次。 链式调用 .then() Promise 的一个强大特性是 .then() 方法可以链式调用。当一个异步操作成功完成并返回结果时，可以通过 .then() 来处理这个结果。如果 .then() 方法返回一个新的 Promise，那么可以继续链式调用后续的 .then()。 12345678910111213141516let promise = new Promise(function(resolve, reject) { setTimeout(() =&gt; resolve(10), 1000); // 1 秒后返回结果 10});promise .then(function(result) { console.log(result); // 输出: 10 return result * 2; // 返回新的值 20 }) .then(function(result) { console.log(result); // 输出: 20 return result * 3; // 返回新的值 60 }) .then(function(result) { console.log(result); // 输出: 60 }); 在这个例子中，每个 .then() 的返回值会传递给下一个 .then()，形成链式结构，依次处理结果。这种链式调用机制让异步操作之间的依赖关系更加清晰。 错误处理：.catch() 和 .finally() .catch() 方法.catch() 用于捕获 Promise 链中的错误。如果 Promise 被拒绝，或者在 .then() 中发生了错误，.catch() 都会捕获到这些错误。 1234567891011let promise = new Promise(function(resolve, reject) { setTimeout(() =&gt; reject(&quot;网络请求失败&quot;), 1000); // 模拟异步操作失败});promise .then(function(result) { console.log(result); // 不会被执行 }) .catch(function(error) { console.log(&quot;发生错误: &quot; + error); // 输出: &quot;发生错误: 网络请求失败&quot; }); .finally() 方法.finally() 无论 Promise 成功或失败，都会执行。它用于编写在 Promise 结束后都需要执行的逻辑，比如关闭加载动画或清理资源。 1234567891011121314let promise = new Promise (function (resolve, reject) { setTimeout (() =&gt; resolve (&quot;操作成功&quot;), 1000);});promise .then (function (result) { console.log (result); // 输出: 操作成功 }) .catch (function (error) { console.log (error); // 不会被执行 }) .finally (function () { console.log (&quot;操作结束&quot;); // 无论成功或失败，都会执行 }); Promise.all () 并行执行多个异步操作 Promise.all () 用于并行执行多个 Promise，等待所有 Promise 都成功后再返回。如果其中一个 Promise 被拒绝，整个 Promise.all () 都会被拒绝。 语法： 123456789Promise.all ([promise 1, promise 2, promise 3]) .then (function (results) { // 所有 Promise 都成功时执行 console.log (results); // 是一个包含每个 Promise 结果的数组 }) .catch (function (error) { // 只要有一个 Promise 被拒绝，执行此处 console.log (error); }); Promise.race ()：竞争模式 Promise.race () 类似于比赛，它会返回第一个解决或拒绝的 Promise，无论是成功还是失败。也就是说，它会返回最快执行的那个 Promise 的结果或错误。 1234567891011let promise 1 = new Promise ((resolve) =&gt; setTimeout (() =&gt; resolve (&quot;结果 1&quot;), 1000));let promise 2 = new Promise ((resolve) =&gt; setTimeout (() =&gt; resolve (&quot;结果 2&quot;), 500));let promise 3 = new Promise ((resolve) =&gt; setTimeout (() =&gt; resolve (&quot;结果 3&quot;), 1500));Promise.race ([promise 1, promise 2, promise 3]) .then (function (result) { console.log (result); // 输出: &quot;结果 2&quot; （因为它最快完成） }) .catch (function (error) { console.log (&quot;某个 Promise 失败&quot;, error); }); Promise.resolve () 和 Promise.reject () Promise.resolve ()Promise.resolve () 方法返回一个已解决的 Promise，可以快速返回一个成功的结果。 12345let promise = Promise.resolve (&quot;快速成功的结果&quot;);promise.then (function (result) { console.log (result); // 输出: 快速成功的结果}); Promise.reject ()Promise.reject () 方法返回一个已拒绝的 Promise，用于快速返回一个失败的结果。 示例： 12345let promise = Promise.reject (&quot;快速失败的原因&quot;);promise.catch (function (error) { console.log (error); // 输出: 快速失败的原因}); async/await：基于 Promise的语法糖，使异步代码更加直观。async 用于声明一个异步函数，而 await 用于等待一个异步操作完成。使用 await 可以让代码看起来像是同步执行的，避免了复杂的 then 链式调用，提升了代码的可读性。 async 函数会返回一个 Promise 对象。 await 只能在 async 函数中使用，它会暂停函数的执行，等待 Promise 完成。123456async function fetchData() { let response = await fetch(&quot;https://api.example.com/data&quot;); let data = await response.json(); console.log(data);}fetchData(); 1234567891011async function fetchData(){try{ let result1=await asyncTask1(); let result2=await asyncTask2(result1); let result3=await asyncTask3(result2); console.log(&quot;所有任务完成&quot;,result3);}catch(error){ console.log(&quot;任务失败&quot;,error);}}fetchData(); 12345678async function myFunction(){ let promise=new Promise((resolve,reject)=&gt;{ setTimeout(()=&gt;resolve(&quot;数据已获取&quot;),2000); }); let result =await promise; console.log(result);}myFunction(); 常见的异步操作 定时器：如 setTimeout 和 setInterval，用于延时和周期性任务。 网络请求：如 fetch 或 XMLHttpRequest，用于异步数据加载。 文件操作：在Node.js中，文件系统操作通常是异步的。","link":"/2024/10/05/%E5%89%8D%E7%AB%AF%E4%B8%89%E4%BB%B6%E5%A5%97/"},{"title":"算法","text":"初级算法 - LeetBook - 力扣（LeetCode） 数组 删除排序数组中的重复项给你一个非严格递增排列的数组 nums ，请你原地删除重复出现的元素，使每个元素只出现一次，返回删除后数组的新长度。元素的相对顺序应该保持一致。然后返回 nums 中唯一元素的个数。 考虑 nums 的唯一元素的数量为 k ，你需要做以下事情确保你的题解可以被通过： 更改数组 nums ，使 nums 的前 k 个元素包含唯一元素，并按照它们最初在 nums 中出现的顺序排列。nums 的其余元素与 nums 的大小不重要。返回 k 。 双指针解题 12345678910111213141516171819class Solution{public:int removeDuplicates(vector&lt;int&gt;&amp; nums){ int n=nums.size(); if(n=0){ return 0; } int fast=1,slow=1; while(fast&lt;n){ if(nums[fast]!=nums[fast-1]){ nums[slow]=nums[fast]; ++slow; } ++fast; } return slow;}}; 买卖股票的最佳时机 II给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。 在每一天，你可以决定是否购买和/或出售股票。你在任何时候最多只能持有一股股票。你也可以先购买，然后在同一天出售。 返回你能获得的最大利润。 12345678910111213class Solution{public: int maxProfit(vector&lt;int&gt;&amp;prices){ int n=prices.size(); int tot=0; for(int i=1;i&lt;n;i++){ if(prices[i]&gt;price[i-1]){ tot+=price[i]-price[i-1]; } } return tot; }}; 旋转数组 给定一个整数数组 nums，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。 使用一个新的数组 123456789101112131415161718class Solution{public: void rotate(vector&lt;int&gt;&amp;nums,int k){ int len=nums.size(); k=k%len; vector&lt;int&gt;res(len); //将后k个元素移到前面 for(int i=0;i&lt;k;i++){ res[i]=nums[len-k+i]; } //将前len-k个元素移到后面 for(int i=0;i&lt;len-k;i++){ res[k+i]=nums[i]; } //将结果复制回nums nums=res; }};也可以这样 1234567891011class Solution{public: void rotate(vector&lt;int&gt;&amp;nums,int k){ int n=nums.size(); vector&lt;int&gt;newArr(n); for(int i=0;i&lt;n;i++){ newArr[(i+k)%n]=nums[i]; } nums.assign(newArr.begin(),newArr.end()); }}; 存在重复元素给你一个整数数组 nums 。如果任一值在数组中出现 至少两次 ，返回 true ；如果数组中每个元素互不相同，返回 false 。题解：考虑排序，排序后数组的重复元素一定出现在相邻位置中 12345678910111213class Solution {public: bool containsDuplicate(vector&lt;int&gt;&amp; nums) { sort(nums.begin(),nums.end()); int n=nums.size(); for(int i=0;i&lt;n-1;i++){ if(nums[i]==nums[i+1]){ return true; } } return false;}; 只出现一次的数字 给你一个非空整数数组 nums ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。 第一次的解法（没有考虑线性时间复杂度）这么写是因为收到前面思路的影响 1234567891011121314151617181920212223242526272829303132class Solution {public: int singleNumber(vector&lt;int&gt;&amp; nums) { sort(nums.begin(), nums.end()); int n = nums.size(); // 如果数组只有一个元素，直接返回 if (n == 1) { return nums[0]; } // 检查第一个元素是否是唯一的 if (nums[0] != nums[1]) { return nums[0]; } // 检查最后一个元素是否是唯一的 if (nums[n - 1] != nums[n - 2]) { return nums[n - 1]; } // 从第二个元素到倒数第二个元素进行检查 for (int i = 1; i &lt; n - 1; i++) { if (nums[i] != nums[i - 1] &amp;&amp; nums[i] != nums[i + 1]) { return nums[i]; } } return -1; }}; 如果要考虑线性时间复杂度 O (n): 12345678910111213141516171819class Solution {public: int singleNumber(vector&lt;int&gt;&amp; nums) { int result = 0; for (int num : nums) { result ^= num; } return result; }}; 这个异或解法的时间复杂度是 O(n)，空间复杂度是 O(1)考虑线性时间复杂度和常量空间复杂度：异或运算异或运算有以下性质： a ^ a = 0（任何数与自己异或的结果是0） a ^ 0 = a（任何数与0异或的结果是这个数本身） 异或运算满足交换律和结合律。 因此，如果数组中除了一个数以外其他数都出现两次，那么将所有数进行异或运算，结果就是那个只出现一次的数。 ps: 复习位运算的规律：（相同为０不同为１）1^1=0;1^0=1;0^1=1;0^0=0;6. 两个数组的交集Ⅱ 给你两个整数数组 nums 1 和 nums 2 ，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。法一：哈希表遍历第一个数组，在哈希表中记录第一个数组中每个数字以及出现的次数，然后遍历第二个数组，如果哈希表中存在这个数字，将这个数字添加到答案，并减少哈希表中该数字出现的次数。 123456789101112131415161718192021222324class Solution{public: vector&lt;int&gt;intersect(vector&lt;int&gt;&amp;nums1,vector&lt;int&gt;&amp;nums2){ if(nums1.size()&gt;nums2.size()){ return intersect(nums2,nums1); } unordered_map&lt;int,int&gt;m; for(int num:nums1){ ++m[num]; } vector&lt;int&gt;intersection; for(int num:nums2){ if(m.count(num)){ intersection.push_back(num); --m[num]; if(m[num]==0){ m.erase(num); } } } return intersection; }}","link":"/2024/09/14/%E6%89%93%E5%8D%A1%E8%B4%B4/"}],"tags":[{"name":"unity","slug":"unity","link":"/tags/unity/"},{"name":"c#","slug":"c","link":"/tags/c/"},{"name":"cpp","slug":"cpp","link":"/tags/cpp/"},{"name":"springboot","slug":"springboot","link":"/tags/springboot/"},{"name":"web","slug":"web","link":"/tags/web/"},{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"mysql","slug":"mysql","link":"/tags/mysql/"},{"name":"docker","slug":"docker","link":"/tags/docker/"},{"name":"ctf","slug":"ctf","link":"/tags/ctf/"},{"name":"前端三件套","slug":"前端三件套","link":"/tags/%E5%89%8D%E7%AB%AF%E4%B8%89%E4%BB%B6%E5%A5%97/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"}],"categories":[{"name":"游戏开发","slug":"游戏开发","link":"/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"},{"name":"STL","slug":"STL","link":"/categories/STL/"},{"name":"web开发","slug":"web开发","link":"/categories/web%E5%BC%80%E5%8F%91/"},{"name":"打卡","slug":"打卡","link":"/categories/%E6%89%93%E5%8D%A1/"},{"name":"CTF","slug":"CTF","link":"/categories/CTF/"},{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"}],"pages":[{"title":"about","text":"关于我：人工智能专业大二在读。正在努力学东西。","link":"/about/index.html"}]}